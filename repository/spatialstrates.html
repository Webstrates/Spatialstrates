<!doctype html>
<html data-protected="all">
        <body>
            <CODE-FOLDER name="Bundles"><WPM-PACKAGE name="SpatialstratesBasicBundle" id="SpatialstratesBasicBundle"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A bundle with all basic Spatialstrates packages",
    "dependencies": [
        "#Spatialstrates",
        "#Menu",
        "#ControllerMenu",
        "#BasicMenu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="SpatialstratesAddOnsBundle" name="SpatialstratesAddOnsBundle"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A bundle with Spatialstrates add-ons",
    "dependencies": [
        "#SpatialstratesLogo",
        "#CalibrationPoint",
        "#UserManager",
        "#Avatar"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="StreamingBundle" name="StreamingBundle"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A bundle of packages for WebRTC streaming",
    "dependencies": [
        "#StreamManager",
        "#ScreenStreamManager",
        "#VideoStreamManager",
        "#AudioStreamManager",
        "#ScreenStream",
        "#VideoStream",
        "#AudioStream"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="MovableBundle" id="MovableBundle"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A bundle for the Movable mechanism and basic components",
    "dependencies": [
        "#Movable",
        "#StickyNote",
        "#Image",
        "#Trashcan",
        "#Screenshots"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Core"><WPM-PACKAGE id="ImportMapping" name="ImportMapping"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Import map for Spatialstrates",
    "dependencies": [],
    "assets": [
        "use-gesture-fix.zip"
    ],
    "version": "0.1.1"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><SCRIPT name="Import Mapping" type="importmap" class="import-map">{
    "imports": {
        "three": "https://esm.sh/v135/three@0.169.0?dev=&target=es2024&external=*",
        "three/": "https://esm.sh/v135/three@0.169.0&dev&target=es2024&external=*/",
        "three-stdlib": "https://esm.sh/v135/three-stdlib@2.30.4?dev=&target=es2024&external=*",
        "three-mesh-bvh": "https://esm.sh/v135/three-mesh-bvh@0.7.6?dev=&target=es2024&external=*",
        "react": "https://esm.sh/v135/react@18.3.1?dev=&target=es2024&external=*",
        "react/": "https://esm.sh/v135/react@18.3.1&dev&target=es2024&external=*/",
        "react-dom": "https://esm.sh/v135/react-dom@18.3.1?dev=&target=es2024&external=*",
        "react-dom/": "https://esm.sh/v135/react-dom@18.3.1&dev&target=es2024&external=*/",
        "react-is": "https://esm.sh/v135/react-is@18.3.1?dev=&target=es2024&external=*",
        "react-composer": "https://esm.sh/v135/react-composer@5.0.3?dev=&target=es2024&external=*",
        "react-use-measure": "https://esm.sh/v135/react-use-measure@2.1.1?dev=&target=es2024&external=*",
        "react-merge-refs": "https://esm.sh/v135/react-merge-refs@1.1.0?dev=&target=es2024&external=*",
        "react-reconciler": "https://esm.sh/v135/react-reconciler@0.29.2?dev=&target=es2024&external=*",
        "react-reconciler/": "https://esm.sh/v135/react-reconciler@0.29.2&dev&target=es2024&external=*/",
        "react-error-boundary": "https://esm.sh/v135/react-error-boundary@4.0.13?dev=&target=es2024&external=*",
        "@react-three/fiber": "https://esm.sh/v135/@react-three/fiber@8.17.10?dev=&target=es2024&external=*",
        "@react-three/drei": "https://esm.sh/v135/@react-three/drei@9.114.4?dev=&target=es2024&external=*",
        "@react-three/xr": "https://esm.sh/v135/@react-three/xr@6.2.15?dev=&target=es2024&external=*",
        "@pmndrs/xr": "https://esm.sh/v135/@pmndrs/xr@6.2.15?dev=&target=es2024&external=*",
        "@pmndrs/xr/": "https://esm.sh/v135/@pmndrs/xr@6.2.15&dev&target=es2024&external=*/",
        "@pmndrs/pointer-events": "https://esm.sh/v135/@pmndrs/pointer-events@6.2.15?dev=&target=es2024&external=*",
        "@iwer/devui": "https://esm.sh/v135/@iwer/devui@0.1.1?dev=&target=es2024&external=*",
        "@react-three/uikit": "https://esm.sh/v135/@react-three/uikit@0.6.0?dev=&target=es2024&external=*",
        "@react-three/uikit-apfel": "https://esm.sh/v135/@react-three/uikit-apfel@0.6.0?dev=&target=es2024&external=*",
        "@react-three/uikit-lucide": "https://esm.sh/v135/@react-three/uikit-lucide@0.6.0?dev=&target=es2024&external=*",
        "@pmndrs/uikit": "https://esm.sh/v135/@pmndrs/uikit@0.6.0?dev=&target=es2024&external=*",
        "@pmndrs/uikit/": "https://esm.sh/v135/@pmndrs/uikit@0.6.0&dev&target=es2024&external=*/",
        "@react-spring/three": "https://esm.sh/v135/@react-spring/three@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/core": "https://esm.sh/v135/@react-spring/core@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/shared": "https://esm.sh/v135/@react-spring/shared@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/animated": "https://esm.sh/v135/@react-spring/animated@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/types": "https://esm.sh/v135/@react-spring/types@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/rafz": "https://esm.sh/v135/@react-spring/rafz@9.7.3?dev=&target=es2024&external=*",
        "zustand": "https://esm.sh/v135/zustand@4.5.5?dev=&target=es2024&external=*",
        "zustand/": "https://esm.sh/v135/zustand@4.5.5&dev&target=es2024&external=*/",
        "lodash": "https://esm.sh/v135/lodash@4.17.21?dev=&target=es2024&external=*",
        "lodash.pick": "https://esm.sh/v135/lodash.pick@4.4.0?dev=&target=es2024&external=*",
        "lodash.omit": "https://esm.sh/v135/lodash.omit@4.5.0?dev=&target=es2024&external=*",
        "lodash.clamp": "https://esm.sh/v135/lodash.clamp@4.0.3?dev=&target=es2024&external=*",
        "lodash.merge": "https://esm.sh/v135/lodash.merge@4.6.2?dev=&target=es2024&external=*",
        "lodash.mergewith": "https://esm.sh/v135/lodash.mergewith@4.6.2?dev=&target=es2024&external=*",
        "@babel/runtime/helpers/esm/extends": "https://esm.sh/v135/@babel/runtime@7.24.8/helpers/extends?dev=&target=es2024&external=*",
        "@monogrid/gainmap-js": "https://esm.sh/v135/@monogrid/gainmap-js@3.0.5?dev=&target=es2024&external=*",
        "@preact/signals-core": "https://esm.sh/v135/@preact/signals-core@1.6.1?dev=&target=es2024&external=*",
        "bidi-js": "https://esm.sh/v135/bidi-js@1.0.3?dev=&target=es2024&external=*",
        "camera-controls": "https://esm.sh/v135/camera-controls@2.8.5?dev=&target=es2024&external=*",
        "debounce": "https://esm.sh/v135/debounce@2.1.0?dev=&target=es2024&external=*",
        "detect-gpu": "https://esm.sh/v135/detect-gpu@5.0.40?dev=&target=es2024&external=*",
        "fast-json-patch": "https://esm.sh/v135/fast-json-patch@3.1.1?dev=&target=es2024&external=*",
        "fflate": "https://esm.sh/v135/fflate@0.8.2?dev=&target=es2024&external=*",
        "inline-style-parser": "https://esm.sh/v135/inline-style-parser@0.2.3?dev=&target=es2024&external=*",
        "its-fine": "https://esm.sh/v135/its-fine@1.2.5?dev=&target=es2024&external=*",
        "json-stringify-pretty-compact": "https://esm.sh/v135/json-stringify-pretty-compact@4.0.0?dev=&target=es2024&external=*",
        "maath": "https://esm.sh/v135/maath@0.10.8?dev=&target=es2024&external=*",
        "meshline": "https://esm.sh/v135/meshline@3.1.6?dev=&target=es2024&external=*",
        "node-html-parser": "https://esm.sh/v135/node-html-parser@6.1.13?dev=&target=es2024",
        "object-assign": "https://esm.sh/v135/object-assign@4.1.1?dev=&target=es2024&external=*",
        "potpack": "https://esm.sh/v135/potpack@2.0.0?dev=&target=es2024&external=*",
        "prettier/": "https://esm.sh/v135/prettier@3.3.2&dev&target=es2024&external=*/",
        "prop-types": "https://esm.sh/v135/prop-types@15.8.1?dev=&target=es2024&external=*",
        "scheduler": "https://esm.sh/v135/scheduler@0.23.2?dev=&target=es2024&external=*",
        "stats.js": "https://esm.sh/v135/stats.js@0.17.0?dev=&target=es2024&external=*",
        "stats-gl": "https://esm.sh/v135/stats-gl@2.2.8?dev=&target=es2024&external=*",
        "suspend-react": "https://esm.sh/v135/suspend-react@0.1.3?dev=&target=es2024&external=*",
        "tunnel-rat": "https://esm.sh/v135/tunnel-rat@0.1.2?dev=&target=es2024&external=*",
        "tw-to-css": "https://esm.sh/v135/tw-to-css@0.0.12?dev=&target=es2024&external=*",
        "troika-three-text": "https://esm.sh/v135/troika-three-text@0.49.0?dev=&target=es2024&external=*",
        "troika-three-utils": "https://esm.sh/v135/troika-three-utils@0.49.0?dev=&target=es2024&external=*",
        "troika-worker-utils": "https://esm.sh/v135/troika-worker-utils@0.49.0?dev=&target=es2024&external=*",
        "use-sync-external-store": "https://esm.sh/v135/use-sync-external-store@1.2.2?dev=&target=es2024&external=*",
        "use-sync-external-store/": "https://esm.sh/v135/use-sync-external-store@1.2.2&dev&target=es2024&external=*/",
        "uuid": "https://esm.sh/v135/uuid@10.0.0?dev=&target=es2024&external=*",
        "webgl-sdf-generator": "https://esm.sh/v135/webgl-sdf-generator@1.1.1?dev=&target=es2024&external=*",
        "yoga-layout/": "https://esm.sh/v135/yoga-layout@3.0.4&dev&target=es2024&external=*/",
        "vega": "https://esm.sh/v135/vega@5.30.0?dev=&target=es2024",
        "vega-embed": "https://esm.sh/v135/vega-embed@6.26.0?dev=&target=es2024",
        "d3": "https://esm.sh/v135/d3@7.9.0?dev=&target=es2024",
        "@use-gesture/core": "./use-gesture-fix.zip/use-gesture-core.esm.js",
        "@use-gesture/core/actions": "./use-gesture-fix.zip/use-gesture-core-actions.esm.js",
        "@use-gesture/react": "https://esm.sh/v135/@use-gesture/react@10.3.1?dev=&external=*&target=es2024",
        "@use-gesture/core/types": "https://esm.sh/v135/@use-gesture/core@10.3.1/types?dev=&external=*&target=es2024",
        "@use-gesture/core/utils": "https://esm.sh/v135/@use-gesture/core@10.3.1/utils?dev=&external=*&target=es2024",
        "tldraw": "https://esm.sh/v135/tldraw@3.7.0?dev=&external=react,react-dom,@use-gesture/react,@use-gesture/core,@use-gesture/core/actions&target=es2024"
    }
}
</SCRIPT><CODE-FRAGMENT data-type="application/json" name="Import Mapping JSON Copy">{
    "imports": {
        "three": "https://esm.sh/v135/three@0.169.0?dev=&target=es2024&external=*",
        "three/": "https://esm.sh/v135/three@0.169.0&dev&target=es2024&external=*/",
        "three-stdlib": "https://esm.sh/v135/three-stdlib@2.30.4?dev=&target=es2024&external=*",
        "three-mesh-bvh": "https://esm.sh/v135/three-mesh-bvh@0.7.6?dev=&target=es2024&external=*",
        "react": "https://esm.sh/v135/react@18.3.1?dev=&target=es2024&external=*",
        "react/": "https://esm.sh/v135/react@18.3.1&dev&target=es2024&external=*/",
        "react-dom": "https://esm.sh/v135/react-dom@18.3.1?dev=&target=es2024&external=*",
        "react-dom/": "https://esm.sh/v135/react-dom@18.3.1&dev&target=es2024&external=*/",
        "react-is": "https://esm.sh/v135/react-is@18.3.1?dev=&target=es2024&external=*",
        "react-composer": "https://esm.sh/v135/react-composer@5.0.3?dev=&target=es2024&external=*",
        "react-use-measure": "https://esm.sh/v135/react-use-measure@2.1.1?dev=&target=es2024&external=*",
        "react-merge-refs": "https://esm.sh/v135/react-merge-refs@1.1.0?dev=&target=es2024&external=*",
        "react-reconciler": "https://esm.sh/v135/react-reconciler@0.29.2?dev=&target=es2024&external=*",
        "react-reconciler/": "https://esm.sh/v135/react-reconciler@0.29.2&dev&target=es2024&external=*/",
        "react-error-boundary": "https://esm.sh/v135/react-error-boundary@4.0.13?dev=&target=es2024&external=*",
        "@react-three/fiber": "https://esm.sh/v135/@react-three/fiber@8.17.10?dev=&target=es2024&external=*",
        "@react-three/drei": "https://esm.sh/v135/@react-three/drei@9.114.4?dev=&target=es2024&external=*",
        "@react-three/xr": "https://esm.sh/v135/@react-three/xr@6.2.15?dev=&target=es2024&external=*",
        "@pmndrs/xr": "https://esm.sh/v135/@pmndrs/xr@6.2.15?dev=&target=es2024&external=*",
        "@pmndrs/xr/": "https://esm.sh/v135/@pmndrs/xr@6.2.15&dev&target=es2024&external=*/",
        "@pmndrs/pointer-events": "https://esm.sh/v135/@pmndrs/pointer-events@6.2.15?dev=&target=es2024&external=*",
        "@iwer/devui": "https://esm.sh/v135/@iwer/devui@0.1.1?dev=&target=es2024&external=*",
        "@react-three/uikit": "https://esm.sh/v135/@react-three/uikit@0.6.0?dev=&target=es2024&external=*",
        "@react-three/uikit-apfel": "https://esm.sh/v135/@react-three/uikit-apfel@0.6.0?dev=&target=es2024&external=*",
        "@react-three/uikit-lucide": "https://esm.sh/v135/@react-three/uikit-lucide@0.6.0?dev=&target=es2024&external=*",
        "@pmndrs/uikit": "https://esm.sh/v135/@pmndrs/uikit@0.6.0?dev=&target=es2024&external=*",
        "@pmndrs/uikit/": "https://esm.sh/v135/@pmndrs/uikit@0.6.0&dev&target=es2024&external=*/",
        "@react-spring/three": "https://esm.sh/v135/@react-spring/three@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/core": "https://esm.sh/v135/@react-spring/core@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/shared": "https://esm.sh/v135/@react-spring/shared@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/animated": "https://esm.sh/v135/@react-spring/animated@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/types": "https://esm.sh/v135/@react-spring/types@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/rafz": "https://esm.sh/v135/@react-spring/rafz@9.7.3?dev=&target=es2024&external=*",
        "zustand": "https://esm.sh/v135/zustand@4.5.5?dev=&target=es2024&external=*",
        "zustand/": "https://esm.sh/v135/zustand@4.5.5&dev&target=es2024&external=*/",
        "lodash": "https://esm.sh/v135/lodash@4.17.21?dev=&target=es2024&external=*",
        "lodash.pick": "https://esm.sh/v135/lodash.pick@4.4.0?dev=&target=es2024&external=*",
        "lodash.omit": "https://esm.sh/v135/lodash.omit@4.5.0?dev=&target=es2024&external=*",
        "lodash.clamp": "https://esm.sh/v135/lodash.clamp@4.0.3?dev=&target=es2024&external=*",
        "lodash.merge": "https://esm.sh/v135/lodash.merge@4.6.2?dev=&target=es2024&external=*",
        "lodash.mergewith": "https://esm.sh/v135/lodash.mergewith@4.6.2?dev=&target=es2024&external=*",
        "@babel/runtime/helpers/esm/extends": "https://esm.sh/v135/@babel/runtime@7.24.8/helpers/extends?dev=&target=es2024&external=*",
        "@monogrid/gainmap-js": "https://esm.sh/v135/@monogrid/gainmap-js@3.0.5?dev=&target=es2024&external=*",
        "@preact/signals-core": "https://esm.sh/v135/@preact/signals-core@1.6.1?dev=&target=es2024&external=*",
        "bidi-js": "https://esm.sh/v135/bidi-js@1.0.3?dev=&target=es2024&external=*",
        "camera-controls": "https://esm.sh/v135/camera-controls@2.8.5?dev=&target=es2024&external=*",
        "debounce": "https://esm.sh/v135/debounce@2.1.0?dev=&target=es2024&external=*",
        "detect-gpu": "https://esm.sh/v135/detect-gpu@5.0.40?dev=&target=es2024&external=*",
        "fast-json-patch": "https://esm.sh/v135/fast-json-patch@3.1.1?dev=&target=es2024&external=*",
        "fflate": "https://esm.sh/v135/fflate@0.8.2?dev=&target=es2024&external=*",
        "inline-style-parser": "https://esm.sh/v135/inline-style-parser@0.2.3?dev=&target=es2024&external=*",
        "its-fine": "https://esm.sh/v135/its-fine@1.2.5?dev=&target=es2024&external=*",
        "json-stringify-pretty-compact": "https://esm.sh/v135/json-stringify-pretty-compact@4.0.0?dev=&target=es2024&external=*",
        "maath": "https://esm.sh/v135/maath@0.10.8?dev=&target=es2024&external=*",
        "meshline": "https://esm.sh/v135/meshline@3.1.6?dev=&target=es2024&external=*",
        "node-html-parser": "https://esm.sh/v135/node-html-parser@6.1.13?dev=&target=es2024",
        "object-assign": "https://esm.sh/v135/object-assign@4.1.1?dev=&target=es2024&external=*",
        "potpack": "https://esm.sh/v135/potpack@2.0.0?dev=&target=es2024&external=*",
        "prettier/": "https://esm.sh/v135/prettier@3.3.2&dev&target=es2024&external=*/",
        "prop-types": "https://esm.sh/v135/prop-types@15.8.1?dev=&target=es2024&external=*",
        "scheduler": "https://esm.sh/v135/scheduler@0.23.2?dev=&target=es2024&external=*",
        "stats.js": "https://esm.sh/v135/stats.js@0.17.0?dev=&target=es2024&external=*",
        "stats-gl": "https://esm.sh/v135/stats-gl@2.2.8?dev=&target=es2024&external=*",
        "suspend-react": "https://esm.sh/v135/suspend-react@0.1.3?dev=&target=es2024&external=*",
        "tunnel-rat": "https://esm.sh/v135/tunnel-rat@0.1.2?dev=&target=es2024&external=*",
        "tw-to-css": "https://esm.sh/v135/tw-to-css@0.0.12?dev=&target=es2024&external=*",
        "troika-three-text": "https://esm.sh/v135/troika-three-text@0.49.0?dev=&target=es2024&external=*",
        "troika-three-utils": "https://esm.sh/v135/troika-three-utils@0.49.0?dev=&target=es2024&external=*",
        "troika-worker-utils": "https://esm.sh/v135/troika-worker-utils@0.49.0?dev=&target=es2024&external=*",
        "use-sync-external-store": "https://esm.sh/v135/use-sync-external-store@1.2.2?dev=&target=es2024&external=*",
        "use-sync-external-store/": "https://esm.sh/v135/use-sync-external-store@1.2.2&dev&target=es2024&external=*/",
        "uuid": "https://esm.sh/v135/uuid@10.0.0?dev=&target=es2024&external=*",
        "webgl-sdf-generator": "https://esm.sh/v135/webgl-sdf-generator@1.1.1?dev=&target=es2024&external=*",
        "yoga-layout/": "https://esm.sh/v135/yoga-layout@3.0.4&dev&target=es2024&external=*/",
        "vega": "https://esm.sh/v135/vega@5.30.0?dev=&target=es2024",
        "vega-embed": "https://esm.sh/v135/vega-embed@6.26.0?dev=&target=es2024",
        "d3": "https://esm.sh/v135/d3@7.9.0?dev=&target=es2024",
        "@use-gesture/core": "./use-gesture-fix.zip/use-gesture-core.esm.js",
        "@use-gesture/core/actions": "./use-gesture-fix.zip/use-gesture-core-actions.esm.js",
        "@use-gesture/react": "https://esm.sh/v135/@use-gesture/react@10.3.1?dev=&external=*&target=es2024",
        "@use-gesture/core/types": "https://esm.sh/v135/@use-gesture/core@10.3.1/types?dev=&external=*&target=es2024",
        "@use-gesture/core/utils": "https://esm.sh/v135/@use-gesture/core@10.3.1/utils?dev=&external=*&target=es2024",
        "tldraw": "https://esm.sh/v135/tldraw@3.7.0?dev=&external=react,react-dom,@use-gesture/react,@use-gesture/core,@use-gesture/core/actions&target=es2024"
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="MyWebstrates Import Mapping" auto>if (webstrate.importMap) {
    const scriptElement = document.querySelector('#ImportMapping .import-map');
    webstrate.importMap.create();
    webstrate.importMap.content = JSON.parse(scriptElement.innerHTML)
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Spatialstrates" name="Spatialstrates"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The Spatialstrates core package and implementation",
    "dependencies": [
        "varv-repos varv-react"
    ],
    "assets": [
        "inter-variable.zip"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT auto data-type="text/javascript+babel" name="React Reloader">import React from 'react';
import { createRoot } from 'react-dom/client';



// Automatically reload this view if certain other fragments change
const changeFragments = [
    '#Spatialstrates [data-type="text/javascript+babel"]'
];

// Start the app
async function render() {
    if (!window.cachedAppRoot) {
        let element = document.createElement('transient');
        element.id = 'app-root';
        document.body.appendChild(element);
        window.cachedAppRoot = createRoot(element);
    }

    let content = await Fragment.one("#Spatialstrates [name='App']").require();
    window.cachedAppRoot.render(React.createElement(content.App));
};

let reloadTimer = null;
const reload = () => {
    clearTimeout(reloadTimer);
    reloadTimer = setTimeout(async function reloadReact() {
        try {
            render();
        } catch (ex) {
            console.log(ex);
        }
    }, 1000);
};

changeFragments.forEach(frag => {
    let lookedUpFragments = Fragment.find(frag);
    lookedUpFragments.forEach((lookedUpFragment) => {
        lookedUpFragment.registerOnFragmentChangedHandler(() => {
            if (fragmentSelfReference.auto) {
                reload();
            }
        });
    });
});

if (VarvEngine) {
    VarvEngine.registerEventCallback('engineReloaded', () => {
        reload();
    });
}

reload();
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="App" class="component">import React from 'react';
const { useEffect } = React;
import { Canvas, useThree } from '@react-three/fiber';
import { XR, createXRStore, IfInSessionMode, useXRInputSourceState } from '@react-three/xr';
import { Stats, Environment } from '@react-three/drei';
import { BackSide } from 'three';

import { DynamicComponents } from '#Spatialstrates .dynamic-components';
import { CustomCamera } from '#Spatialstrates .camera';
import { GlobalEventProvider } from '#Spatialstrates .global-events';





if (!window.moduleDeviceManager) {
    window.moduleDeviceManager = {};
}

function Scene() {
    // The Quest renders in lower resolution by default, this increases the resolution
    // https://discourse.threejs.org/t/webxr-quality-problems/24603/2
    const { gl } = useThree();
    useEffect(() => {
        gl?.xr.setFramebufferScaleFactor(2.0);
    }, [gl]);

    // Used for access to the camera in non-React components
    const { camera } = useThree();
    const xrCamera = useThree((s) => s.gl.xr.getCamera());
    const controllerRight = useXRInputSourceState('controller', 'right');
    const controllerLeft = useXRInputSourceState('controller', 'left');
    const handRight = useXRInputSourceState('hand', 'right');
    const handLeft = useXRInputSourceState('hand', 'left');
    useEffect(() => {
        window.moduleDeviceManager.camera = camera;
    }, [camera]);
    useEffect(() => {
        window.moduleDeviceManager.xrCamera = xrCamera;
    }, [xrCamera]);
    useEffect(() => {
        window.moduleDeviceManager.controllerRight = controllerRight;
    }, [controllerRight]);
    useEffect(() => {
        window.moduleDeviceManager.controllerLeft = controllerLeft;
    }, [controllerLeft]);
    useEffect(() => {
        window.moduleDeviceManager.handRight = handRight;
    }, [handRight]);
    useEffect(() => {
        window.moduleDeviceManager.handLeft = handLeft;
    }, [handLeft]);

    return &lt;>
        &lt;IfInSessionMode deny={['immersive-ar']}>
            &lt;gridHelper />
            &lt;color attach="background" args={[0xE5E4E2]} />
            &lt;mesh scale={200}>
                &lt;sphereGeometry />
                &lt;meshStandardMaterial color="#E5E4E2" side={BackSide} transparent={true} opacity={0.4} />
            &lt;/mesh>
        &lt;/IfInSessionMode>

        &lt;IfInSessionMode deny={['immersive-ar', 'immersive-vr']}>
            &lt;CustomCamera />
            &lt;Stats className="spatial-strates-stats" />
        &lt;/IfInSessionMode>

        &lt;Environment preset="city" />
        &lt;DynamicComponents selector=".dynamic-scene-component" />
    &lt;/>;
}

// https://github.com/pmndrs/xr/blob/1793fe3a4ecf07a30ea98ff2585811d3100d6b51/packages/xr/src/init.ts#L54
const store = createXRStore({
    frameRate: 'low',
    handTracking: true,
    hitTest: true,
    depthSensing: true,
    domOverlay: document.querySelector('#app-root')
});
window.xrStore = store;


export function App() {
    return &lt;>
        &lt;div className="crosshair">&lt;/div>
        &lt;DynamicComponents selector=".dynamic-gui-component" />
        &lt;Canvas dpr={2}
        gl={{ preserveDrawingBuffer: true, localClippingEnabled: true }}
        mode="concurrent">
            &lt;XR store={store}>
                &lt;GlobalEventProvider>
                    &lt;Scene />
                &lt;/GlobalEventProvider>
            &lt;/XR>
        &lt;/Canvas>
    &lt;/>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/css" auto name="Inter Font">@font-face {
    font-family: "Inter";
    font-weight: 100 900;
    font-display: swap;
    font-style: normal;
    src: url("inter-variable.zip/inter-variable.woff2") format("woff2-variations"),
         url("inter-variable.zip/inter-variable.woff2") format("woff2");
    src: url("inter-variable.zip/inter-variable.woff2") format("woff2") tech("variations");
}

@font-face {
    font-family: "Inter";
    font-weight: 100 900;
    font-display: swap;
    font-style: italic;
    src: url("inter-variable.zip/inter-variable-Italic.woff2") format("woff2-variations"),
         url("inter-variable.zip/inter-variable-Italic.woff2") format("woff2");
    src: url("inter-variable.zip/inter-variable-Italic.woff2") format("woff2") tech("variations");
}
</CODE-FRAGMENT><CODE-FRAGMENT auto data-type="text/x-scss" name="Core Style">body {
    margin: 0;
    font-family: Inter, sans-serif;
    height: 100vh;
}

#cauldron-edit-button {
    z-index: 100001;
    user-select: none;
    cursor: pointer;

    border-radius: 4px;
    height: 24px;
    box-sizing: unset;
    line-height: 24px;
    font-family: 'Inter', sans-serif;
    padding: 0 8px;
    top: 12px !important;
    right: 12px !important;
    font-weight: 500;
    font-size: 13px;

    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60) !important;
    border: 1px solid #cccccc70;

    &:hover {
        background: rgba(255, 255, 255, .80) !important;
    }
}

.crosshair {
    display: none;
    position: absolute;
    left: 50%;
    top: 50%;
    background: #FF3D00;
    outline: 2px solid #E4E3DF;
    border: 2px solid #231F20;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
}

.spatial-strates-stats {
    top: 48px !important;
    right: 12px !important;
    left: auto !important;

    canvas {
        border-radius: 3px;
    }
}
</CODE-FRAGMENT><CODE-FOLDER id name="Core Components"><CODE-FRAGMENT data-type="text/javascript+babel" id name="Camera" class="component camera">import React from 'react';
const { useRef, useEffect } = React;
import { Vector3 } from 'three';
import { useFrame } from '@react-three/fiber';
import { PointerLockControls } from '@react-three/drei';



const SPEED = 1.4;



export function CustomCamera() {
    const controls = useRef();
    const crosshair = useRef(document.querySelector('.crosshair'));
    const moveDirection = useRef(new Vector3());

    useEffect(() => {
        window.moduleCameraControls = { controlsRef: controls };

        return () => {
            window.moduleCameraControls = {};
        };
    }, []);

    useEffect(() => {
        const handleKeyDown = (event) => {
            if (!controls.current.isLocked) return;
            switch (event.code) {
                case 'KeyW':
                    moveDirection.current.z = -1;
                    break;
                case 'KeyS':
                    moveDirection.current.z = 1;
                    break;
                case 'KeyA':
                    moveDirection.current.x = -1;
                    break;
                case 'KeyD':
                    moveDirection.current.x = 1;
                    break;
                case 'Space':
                    moveDirection.current.y = 1;
                    break;
                case 'ShiftLeft':
                    moveDirection.current.y = -1;
                    break;
                default:
                    break;
            }
        };

        const handleKeyUp = (event) => {
            switch (event.code) {
                case 'KeyW':
                case 'KeyS':
                    moveDirection.current.z = 0;
                    break;
                case 'KeyA':
                case 'KeyD':
                    moveDirection.current.x = 0;
                    break;
                case 'Space':
                case 'ShiftLeft':
                    moveDirection.current.y = 0;
                    break;
                default:
                    break;
            }
        };

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        controls.current.camera.position.set(0, 1.5, 1);

        return () => {
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
        };
    }, []);

    useFrame((state, delta) => {
        if (moveDirection.current.x != 0 || moveDirection.current.y != 0 || moveDirection.current.z != 0) {
            const timeBasedSpeed = SPEED * delta;
            controls.current.getObject().translateX(moveDirection.current.x * timeBasedSpeed);
            controls.current.getObject().translateY(moveDirection.current.y * timeBasedSpeed * 0.5);
            controls.current.getObject().translateZ(moveDirection.current.z * timeBasedSpeed);
        }
        controls.current.getObject().updateMatrix();
        controls.current.getObject().updateMatrixWorld();
    });

    const handleOnLock = (e) => { crosshair.current.style.display = 'block'; };
    const handleOnUnlock = (e) => { crosshair.current.style.display = 'none'; };

    return &lt;PointerLockControls ref={controls} selector={'.do-not-use'} onLock={handleOnLock} onUnlock={handleOnUnlock} />;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="module transform-helpers" name="Transform Helpers">import * as THREE from 'three';



export const devicePositionWithOffset = (device, offset = 0) => {
    let x = 0;
    let y = 0;
    let z = 0;

    if (device) {
        let position = device.position;

        // If the distance option is given we move the position in the direction the device is looking
        if (offset != 0) {
            const direction = new THREE.Vector3(0, 0, -1);
            direction.normalize();
            direction.applyQuaternion(device.quaternion);

            position = new THREE.Vector3();
            position.copy(device.position).add(direction.multiplyScalar(offset));
        }

        x = position.x;
        y = position.y;
        z = position.z;
    }

    return [x, y, z];
};

export const deviceRotation = (device) => {
    let x = 0;
    let y = 0;
    let z = 0;

    if (device) {
        x = device.rotation._x;
        y = device.rotation._y;
        z = device.rotation._z;
    }

    return [x, y, z];
};

export const getDeviceFromInputEvent = (e) => {
    let device;

    if (e.nativeEvent?.inputSource?.handedness) {
        if (e.nativeEvent?.inputSource?.hand === null) {
            device = e.nativeEvent.inputSource.handedness === 'right' ? window.moduleDeviceManager.controllerRight?.object : window.moduleDeviceManager.controllerLeft?.object;
        } else {
            device = e.nativeEvent.inputSource.handedness === 'right' ? window.moduleDeviceManager.handRight?.object : window.moduleDeviceManager.handLeft?.object;
        }
    } else {
        device = window.moduleDeviceManager.camera;
    }

    if (!device) {
        console.warn('No device found.');
        return;
    } else {
        return device;
    }
};
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="module global-events" name="Global Events">import React from 'react';
const { useRef, useContext, createContext, useCallback, useMemo } = React;



// Send messages between components
if (!window.GlobalEventContext) window.GlobalEventContext = createContext();

export const GlobalEventProvider = ({ children }) => {
    const eventsRef = useRef({});

    const triggerEvent = useCallback((eventName, data) => {
        if (eventsRef.current[eventName]) {
            eventsRef.current[eventName].forEach(callback => callback(data));
        }
    }, []);

    const subscribeEvent = useCallback((eventName, callback) => {
        if (!eventsRef.current[eventName]) {
            eventsRef.current[eventName] = [];
        }
        eventsRef.current[eventName].push(callback);

        // Return unsubscribe function
        return () => {
            eventsRef.current[eventName] = eventsRef.current[eventName].filter(cb => cb !== callback);
        };
    }, []);

    // Memoize context value to avoid unnecessary rerenders
    const value = useMemo(() => ({
        triggerEvent,
        subscribeEvent,
    }), [triggerEvent, subscribeEvent]);

    return (
        &lt;GlobalEventContext.Provider value={value}>
            {children}
        &lt;/GlobalEventContext.Provider>
    );
};


export const useGlobalEvents = () => useContext(GlobalEventContext);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="component dynamic-components" name="Dynamic Components">import React from 'react';
const { useEffect, useState, useRef } = React;
import { ErrorBoundary } from 'react-error-boundary';



function DynamicComponent({ fragment }) {
    const [component, setComponent] = useState(null);
    const boundaryRef = useRef(null);

    const updateComponent = async () => {
        if (!fragment) return;
        const module = await fragment.require();
        const Main = module['Main'];
        setComponent(&lt;Main />);
        boundaryRef.current?.resetErrorBoundary();
    };

    useEffect(() => {
        fragment?.registerOnFragmentChangedHandler(updateComponent);
        updateComponent();

        return () => {
            fragment?.unRegisterOnFragmentChangedHandler(updateComponent);
        };
    }, [fragment]);

    return &lt;ErrorBoundary ref={boundaryRef} fallback={null}>
        {component}
    &lt;/ErrorBoundary>;
};

// This is a component that dynamically loads components from fragments
export function DynamicComponents({ selector }) {
    const [output, setOutput] = useState([]);
    const fragmentsMap = useRef(new Map());

    useEffect(() => {
        if (!selector) return;
        const query = cQuery(document).liveQuery(selector, {
            added: async (fragmentElement) => {
                const fragment = Fragment.one(fragmentElement);
                if (!fragment) return;

                fragmentsMap.current.set(fragment.uuid, fragment);
                setOutput(Array.from(fragmentsMap.current.entries()));
            },
            removed: (fragmentElement) => {
                const fragment = Fragment.one(fragmentElement);
                if (!fragment) return;

                fragmentsMap.current.delete(fragment.uuid);
                setOutput(Array.from(fragmentsMap.current.entries()));
            }
        });
        return () => {
            query.stop();
        };
    }, []);

    return output.map((entry) => {
        const [id, fragment] = entry;
        return &lt;DynamicComponent fragment={fragment} key={fragment.uuid} />;
    });
}
</CODE-FRAGMENT></CODE-FOLDER></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Basic" id><CODE-FOLDER name="Utils"><WPM-PACKAGE name="Icon" id="Icon"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A util for themed icons using custom 3D models",
    "dependencies": [],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Icon" class="default component">import React from 'react';
import { Clone } from '@react-three/drei';



export const SELECTED_COLOR_PRIMARY = 'hsl(14, 100%, 50%)';
export const SELECTED_COLOR_SECONDARY = 'hsl(26, 100%, 60%)';
export const HOVERED_SELECTED_COLOR_PRIMARY = 'hsl(14, 100%, 65%)';
export const HOVERED_SELECTED_COLOR_SECONDARY = 'hsl(26, 100%, 75%)';



export const themes = {
    '': { primary: 'rgb(255,0,255)', secondary: 'rgb(255,255,0)' },
    ':hovered': { primary: 'rgb(255,0,0)', secondary: 'rgb(255,0,0)' },
    ':selected': { primary: 'rgb(0,255,0)', secondary: 'rgb(255,0,0)' },
    ':selected:hovered': { primary: 'rgb(0,255,255)', secondary: 'rgb(255,0,0)' }
};



export function Icon(props) {
    const { model, theme = '', themesOverride = false } = props;
    if (model == null) return null;

    const finalThemes = themesOverride || themes;

    try {
        if (model.materials['Primary']) model.materials['Primary'].color.set(finalThemes[theme].primary);
        if (model.materials['Secondary']) model.materials['Secondary'].color.set(finalThemes[theme].secondary);
    } catch (ex) {
        console.log('Missing colour for ' + theme);
    }

    return &lt;group {...props}>
        &lt;Clone object={model ? model.scene : null} deep={'materialsOnly'} />
    &lt;/group>;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="Text" id="Text"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A helper component to globally control the font and text rendering.",
    "dependencies": [],
    "assets": [
        "inter-medium.woff"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Text Component" class="default component">import React from 'react';
import { Text as TextDrei } from '@react-three/drei';



// https://www.cdnfonts.com/
// Inter: https://fonts.cdnfonts.com/s/19795/Inter-Medium.woff
// Poppins: https://fonts.cdnfonts.com/s/16009/Poppins-Medium.woff



// Set Global Properties for the Text Component
export function Text(props) {
    const { children, ...rest } = props;
    return (
        &lt;TextDrei
            font="inter-medium.woff"
            {...rest}>
            {children}
        &lt;/TextDrei>
    );
}
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Components"><WPM-PACKAGE id="Menu" name="Menu"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple menu GUI for Spatialstrates",
    "dependencies": [
        "#Spatialstrates"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Menu" class="default component dynamic-gui-component">import React from 'react';
const { useState, useEffect } = React;



if (!window.moduleMenu) {
    window.moduleMenu = {
        subMenus: new Map(),
        menuNeedsUpdate: true
    };
}

class MenuItem {
    constructor(id, element, weight) {
        this.id = id;
        this.element = element;
        this.weight = weight;
    }
}

class SubMenu {
    constructor(id, weight, alwaysVisible = false) {
        this.id = id;
        this.weight = weight;
        this.alwaysVisible = alwaysVisible;
        this.items = new Map();
    }

    addItem(item) {
        this.items.set(item.id, item);
    }
}

export const addSubMenu = (id, weight, alwaysVisible) => {
    if (window.moduleMenu.subMenus.has(id)) {
        return window.moduleMenu.subMenus.get(id);
    }
    const subMenu = new SubMenu(id, weight, alwaysVisible);
    window.moduleMenu.subMenus.set(id, subMenu);
    window.moduleMenu.menuNeedsUpdate = true;
    return subMenu;
};

export const addItemToSubMenu = (subMenuId, id, element, weight) => {
    const menuItem = new MenuItem(id, element, weight);
    const subMenu = window.moduleMenu.subMenus.get(subMenuId);
    if (!subMenu) {
        console.error(`SubMenu ${subMenuId} not found`);
        return;
    }
    subMenu.addItem(menuItem);
    window.moduleMenu.menuNeedsUpdate = true;
    return menuItem;
};

export function MenuTitle({ title }) {
    return &lt;div className="title">{title}&lt;/div>;
}

export function MenuSpacer() {
    return &lt;div className="spacer">&lt;/div>;
}

export function MenuButton({ onClick, toggled, children, className }) {
    return &lt;button className={className} onClick={onClick} toggled={toggled ? 'true' : null} tabIndex="-1">{children}&lt;/button>;
}

/**
 * A heads-up display with buttons
 */
function Menu() {
    const [output, setOutput] = useState(null);

    const updateMenu = () => {
        const subMenus = Array.from(window.moduleMenu.subMenus.values());
        subMenus.sort((a, b) => a.weight - b.weight);

        setOutput(&lt;div className="floating-menus">
            {subMenus.map(subMenu => {
                const items = Array.from(subMenu.items.values());
                items.sort((a, b) => a.weight - b.weight);
                return &lt;div key={subMenu.id} className={`floating-menu${subMenu.alwaysVisible ? ' always-visible' : ''}`}>
                    {items.map((item, index) => {
                        const componentWithKey = React.cloneElement(item.element, { key: index });
                        return componentWithKey;
                    })}
                &lt;/div>;
            })}
        &lt;/div>);
    };

    useEffect(() => {
        if (window.moduleMenu.menuNeedsUpdate) {
            window.moduleMenu.menuNeedsUpdate = false;
            updateMenu();
        }
    });

    useEffect(() => {
        updateMenu();
    }, []);

    return output;
}



export function Main() {
    return &lt;Menu />;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Menu Style" auto>@mixin heading-font {
    font-weight: 500;
    font-size: 13px;
    letter-spacing: 0.25px;
}

.floating-menus {
    position: absolute;
    bottom: 8px;
    left: 8px;
    right: 8px;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    align-items: flex-end;
    justify-content: space-between;
    gap: 8px;
}

.floating-menu {
    z-index: 99999;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60) !important;
    border-radius: 12px;
    border: 1px solid #cccccc70;
    box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.025);
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 12px;
    flex: 0 1 192px;

    max-height: 40px;
    overflow: hidden;
    transition: max-height 500ms ease-in-out;

    &:hover:not(.always-visible) {
        max-height: initial;

        .title {
            order: 999;
        }
    }

    &.always-visible {
        max-height: initial;
    }

    .spacer {
        border-bottom: 1px solid #63636370;
        margin: 0 32px;
    }

    .title {
        @include heading-font;
        min-height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;

        user-select: none;
        text-align: center;
        cursor: default;
        color: #636363dd;
    }

    button {
        @include heading-font;
        min-height: 40px;

        user-select: none;
        border-radius: 4px;
        padding: 4px 8px;
        background: #63636390;
        color: #fff;
        vertical-align: middle;
        text-align: center;
        cursor: pointer;
        border: none;

        &:hover {
            background: #848484cc;
        }

        &:active {
            background: #606060cc;
        }

        &.red {
            background: #d32f2f90 !important;

            &:hover {
                background: #ff6659cc !important;
            }

            &:active {
                background: #9a0007cc !important;
            }
        }

        &.green {
            background: #2e7d3290 !important;

            &:hover {
                background: #61ad5ecc !important;
            }

            &:active {
                background: #005005cc !important;
            }
        }

        &[toggled="true"] {
            background: #FF910090 !important;
        }
    }

    .upload-drop-zone {
        @include heading-font;
        min-height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;

        user-select: none;
        text-align: center;
        cursor: pointer;
        background: #ddd;
        border-radius: 4px;

        &.upload-drop-zone--over {
            background: #ccc;
            cursor: copy;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ControllerMenu" name="ControllerMenu"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple controller menu for immersive XR",
    "dependencies": [
        "#Spatialstrates",
        "#Icon",
        "#Text"
    ],
    "assets": [
        "button.glb"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Controller Menu" id class="default component dynamic-scene-component">import React from 'react';
let { useState, useEffect, useMemo } = React;
import { useXRInputSourceState } from '@react-three/xr';
import { createPortal } from '@react-three/fiber';
import { useGLTF } from '@react-three/drei';

import { Icon } from "#Icon .default";
import { Text } from '#Text .default';



if (!window.moduleControllerMenu) {
    window.moduleControllerMenu = {
        menu: new Map(),
        menuNeedsUpdate: true
    };
}

class MenuItem {
    constructor(id, element) {
        this.id = id;
        this.element = element;
    }
}

export const addItem = (id, element) => {
    const menuItem = new MenuItem(id, element);
    window.moduleControllerMenu.menu.set(id, menuItem);
    window.moduleControllerMenu.menuNeedsUpdate = true;
    return menuItem;
};



const themes = {
    'button': { primary: 'hsl(200, 18%, 50%)', secondary: 'hsl(198, 16%, 84%)' },
    'button:hovered': { primary: 'hsl(200, 18%, 60%)', secondary: 'hsl(198, 16%, 84%)' },
    'button:disabled': { primary: 'rgb(0,0,0)', secondary: 'rgb(0,0,0)' },
    'button:toggled': { primary: 'hsl(200, 18%, 50%)', secondary: 'hsl(47, 100%, 63%)' },
    'button:toggled:hovered': { primary: 'hsl(200, 18%, 60%)', secondary: 'hsl(47, 100%, 73%)' },

    'deleteButton': { primary: 'hsl(0, 73%, 40%)', secondary: 'hsl(4, 90%, 60%)' },
    'deleteButton:hovered': { primary: 'hsl(0, 73%, 50%)', secondary: 'hsl(4, 90%, 70%)' }
};
useGLTF.preload('button.glb');



export function ControllerMenuButton({ position, name, theme = 'button', callback }) {
    const controllerButton = useGLTF('button.glb');
    const [hovered, setHovered] = useState();

    return &lt;group position={position} scale={hovered ? 1.1 : 1} autoUpdateMatrix={false}>
        &lt;Icon theme={theme + (hovered ? ':hovered' : '')}
            model={controllerButton}
            themesOverride={themes}
            onClick={callback}
            onPointerOver={() => setHovered(true)}
            onPointerOut={() => setHovered(false)} />
        &lt;Text
            position={[0, 0, 0.005]} autoUpdateMatrix={false}
            maxWidth={0.045}
            textAlign="center"
            anchorX="center"
            anchorY="middle"
            color="black"
            fontSize={0.007}>
            {name}
        &lt;/Text>
    &lt;/group>;
}

function ControllerMenu() {
    const [showMenu, setShowMenu] = useState(false);
    const [output, setOutput] = useState(null);

    // Attach the menu
    const controllerLeft = useXRInputSourceState('controller', 'left');
    const handLeft = useXRInputSourceState('hand', 'left');

    // FIXME: Sometimes the parent is not set correclty and the menu only shows when switching back and forth between hands
    const parent = useMemo(() => controllerLeft ? controllerLeft.object : handLeft ? handLeft.object : null, [controllerLeft, handLeft]);

    const menuGroup = useMemo(() => parent ? createPortal(&lt;group position={[0, 0.06, -0.15]} rotation={false ? [-Math.PI / 2, 0.2, 0.2] : [-Math.PI / 2, 0, 0]}>
        &lt;ControllerMenuButton position={[0, -0.06, 0]} name={'Show Menu'} callback={() => setShowMenu(!showMenu)} theme={showMenu ? 'button:toggled' : 'button'} />
        {showMenu ? output : null}
    &lt;/group>, parent) : null, [parent, output, showMenu, controllerLeft, handLeft]);

    const updateMenu = () => {
        setOutput(Array.from(window.moduleControllerMenu.menu.values())
            .sort((a, b) => a.weight - b.weight)
            .map(menuItem => menuItem.element));
    }

    useEffect(() => {
        if (window.moduleControllerMenu.menuNeedsUpdate) {
            window.moduleControllerMenu.menuNeedsUpdate = false;
            updateMenu();
        }
    });

    useEffect(() => {
        updateMenu();
    }, []);

    return menuGroup;
}



export function Main() {
    return &lt;ControllerMenu />;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="BasicMenu" name="BasicMenu"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Basic menu entries to move the camera and toggle XR",
    "dependencies": [
        "#Spatialstrates",
        "#Menu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Basic Menu" class auto>import React from 'react';
import {
    addSubMenu,
    addItemToSubMenu,
    MenuTitle,
    MenuSpacer,
    MenuButton
} from '#Menu .default';



const toggleAR = async () => {
    if (!navigator?.xr) {
        alert('WebXR is not supported by your browser.');
        return;
    }

    const sessionMode = 'immersive-ar';
    if (!await navigator.xr.isSessionSupported(sessionMode)) {
        alert('AR sessions are not supported by your browser.');
        return;
    }

    if (!window.xrStore) {
        console.warn('No xrStore found');
        return;
    }
    if (!window.xrStore.getState().session) {
        window.xrStore?.enterAR();
    } else {
        await window.xrStore.getState().session.end();
        window.xrStore.setState({ session: null });
    }
};

const toggleVR = async () => {
    if (!navigator?.xr) {
        alert('WebXR is not supported by your browser.');
        return;
    }

    const sessionMode = 'immersive-vr';
    if (!await navigator.xr.isSessionSupported(sessionMode)) {
        alert('VR sessions are not supported by your browser.');
        return;
    }

    if (!window.xrStore) {
        console.warn('No xrStore found');
        return;
    }
    if (!window.xrStore.getState().session) {
        window.xrStore?.enterVR();
    } else {
        await window.xrStore.getState().session.end();
        window.xrStore.setState({ session: null });
    }
};

const shareLink = () => {
    let sendToQuestUrl = new URL('https://oculus.com/open_url/');
    sendToQuestUrl.searchParams.set('url', location.protocol + '//' + location.host + location.pathname);
    window.open(sendToQuestUrl, '_blank');
};



addSubMenu('camera', 1000, true);
addItemToSubMenu('camera', 'move-camera', &lt;MenuButton className="mouse-lock" onClick={() => {
    if (!window.moduleCameraControls?.controlsRef?.current) return;
    if (!window.moduleCameraControls.controlsRef.current.isLocked) {
        window.moduleCameraControls.controlsRef.current.lock();
    } else {
        window.moduleCameraControls.controlsRef.current.unlock();
    }
}}>Move Camera&lt;/MenuButton>, 0);
addItemToSubMenu('camera', 'spacer1', &lt;MenuSpacer />, 1);
addItemToSubMenu('camera', 'toggle-ar', &lt;MenuButton onClick={toggleAR}>Toggle AR&lt;/MenuButton>, 2);
addItemToSubMenu('camera', 'toggle-vr', &lt;MenuButton onClick={toggleVR}>Toggle VR&lt;/MenuButton>, 3);


addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'title', &lt;MenuTitle title="Media Sharing" />, 0);
addItemToSubMenu('media-sharing', 'share-link', &lt;MenuButton onClick={shareLink}>Send to Quest&lt;/MenuButton>, 1000);
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER></CODE-FOLDER><CODE-FOLDER name="Add-ons"><CODE-FOLDER name="Utils"><WPM-PACKAGE name="AIHelpers" id="AIHelpers"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Helper functions to call the OpenAI API",
    "dependencies": [],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="AI Helpers" class="default module">export const recordAudio = (duration) => {
    return new Promise((resolve, reject) => {
        let chunks = [];

        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
            const mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = (event) => {
                chunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(chunks, { type: 'audio/wav' });
                resolve(audioBlob);
            };

            mediaRecorder.start();

            setTimeout(() => {
                mediaRecorder.stop();
            }, duration);
        }).catch(error => {
            reject(error);
        });
    });
};

export const transcribeAudio = async (duration, audioBlob = false, recordingEndedCallback = false) => {
    if (!window.API_KEY) {
        window.API_KEY = prompt('Please enter your OpenAI API key:');
        if (!window.API_KEY) {
            if (recordingEndedCallback) recordingEndedCallback();
            console.error('An API_KEY is required to transcribe audio.');
            return;
        }
    }

    let audioBlobToTranscribe = audioBlob;
    if (!audioBlobToTranscribe) {
        audioBlobToTranscribe = await recordAudio(duration);
    }

    if (recordingEndedCallback) recordingEndedCallback();

    const formData = new FormData();
    formData.append('file', audioBlobToTranscribe, 'recording.wav');
    formData.append('model', 'whisper-1');

    const whisperResponse = await fetch('https://api.openai.com/v1/audio/transcriptions', {
        method: 'POST',
        mode: 'cors',
        headers: { 'Authorization': `Bearer ${API_KEY}` },
        body: formData,
    });
    const whisperData = await whisperResponse.json();

    return whisperData.text;
};

export const sendGPTPrompt = async (body) => {
    if (!window.API_KEY) {
        window.API_KEY = prompt('Please enter your OpenAI API key:');
        if (!window.API_KEY) {
            console.error('An API_KEY is required to transcribe audio.');
            return;
        }
    }

    const options = {
        method: 'POST',
        mode: 'cors',
        headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${API_KEY}`
        },
        body: JSON.stringify(body)
    };
    console.log('OpenAI API call options:', options);

    const gptResponse = await fetch('https://api.openai.com/v1/chat/completions', options);
    const gptData = await gptResponse.json();
    return gptData;
};

export const getGPTContent = (gptData) => gptData.choices[0].message.content;
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Components"><WPM-PACKAGE id="SpatialstratesLogo" name="SpatialstratesLogo"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Spatialstrates logo with version information",
    "dependencies": [],
    "assets": [],
    "version": "0.1.1"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Spatialstrates App Header" class="component dynamic-gui-component">import React from 'react';
const { useState } = React;



export function Main() {
    const [showDialog, setShowDialog] = useState(false);

    return &lt;>
        &lt;div className="spatialstrates-title" onClick={() => setShowDialog(!showDialog)}>
            &lt;h1>Spatialstrates&lt;/h1>
        &lt;/div>
        {showDialog ? &lt;div className="spatialstrates-dialog-modal" onClick={() => setShowDialog(false)}>
            &lt;div className="spatialstrates-dialog" onClick={(e) => e.stopPropagation()}>
                &lt;h2>Spatialstrates&lt;/h2>
                &lt;p>Version 0.1.1 | &lt;a href="https://github.com/Webstrates/Spatialstrates" target="_blank">GitHub&lt;/a>&lt;/p>
            &lt;/div>
        &lt;/div> : null}
    &lt;/>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Spatialstrates App Style" auto>.spatialstrates-title {
    position: fixed;
    top: 12px;
    left: 12px;
    z-index: 1000;
    padding: 4px 5px;
    border-radius: 4px;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    gap: 8px;
    height: 32px;
    user-select: none;
    cursor: pointer;

    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(242, 242, 242, .60) !important;
    border: 1px solid #cccccc70;
    box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.025);

    &:hover {
        background: rgba(242, 242, 242, .80) !important;
    }

    h1 {
        margin: 0;
        font-size: 22px;
        line-height: 32px;
        font-weight: 600;
        letter-spacing: -0.01em;
        padding-left: 4px;
        padding-right: 4px;
    }
}

.spatialstrates-dialog-modal {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    z-index: 100000;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(5px);
    background: rgba(192, 192, 192, .60) !important;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 12px;
}

.spatialstrates-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    padding: 20px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    border: 1px solid #cccccc70;
    background: #fafafa;
    box-shadow: 0 0 12px 0 rgba(0, 0, 0, 0.25);

    h2, p {
        margin: 0;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="CalibrationPoint" name="CalibrationPoint"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Calibration widget for immersive XR",
    "dependencies": [
        "#Spatialstrates",
        "#Icon"
    ],
    "assets": [
        "calibration_point.glb"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Calibration Point" id class="default component dynamic-scene-component">import React from 'react';
const { useRef } = React;
import { useFrame, useThree } from '@react-three/fiber';
import { useXRInputSourceEvent, useXRInputSourceState, IfInSessionMode } from '@react-three/xr';
import { useGLTF } from '@react-three/drei';
import * as THREE from 'three';

import { Icon } from "#Icon .default";



const themes = {
    'calibrationPoint': { primary: 'hsl(65, 100%, 40%)', secondary: 'hsl(200, 18%, 50%)' },
    'calibrationPoint:hovered': { primary: 'hsl(65, 100%, 60%)', secondary: 'hsl(200, 18%, 60%)' }
};
useGLTF.preload('calibration_point.glb');

/**
 * Move the entire scene view based on a calibration marker or a cube that can be moved around
*/
function CalibrationPoint() {
    const calibrateIcon = useGLTF('calibration_point.glb');
    let offsetUpdate = false;
    const grabbingController = useRef();
    const previousTransform = React.useMemo(() => new THREE.Matrix4(), [])
    const dragRef = useRef();

    // If a new offset has been set, inform the XR manager
    useFrame((state) => {
        if (offsetUpdate) {
            const referenceSpace = state.gl.xr.getReferenceSpace()
            state.gl.xr.setReferenceSpace(referenceSpace.getOffsetReferenceSpace(offsetUpdate));
            offsetUpdate = false;
        }

        const controller = grabbingController.current;
        if (!controller) return;

        dragRef.current.applyMatrix4(previousTransform);
        dragRef.current.applyMatrix4(controller.matrixWorld);
        dragRef.current.rotation.reorder('YXZ');
        dragRef.current.rotation.x = 0;
        dragRef.current.rotation.z = 0;
        dragRef.current.updateMatrixWorld();
        previousTransform.copy(controller.matrixWorld).invert();
    });

    // When the reference has moved, store the offset and reset it back (but not in height)
    const calibrate = () => {
        if (!dragRef.current) return;
        dragRef.current.rotation.reorder('YXZ');
        dragRef.current.rotation.x = 0;
        dragRef.current.rotation.z = 0;
        offsetUpdate = new XRRigidTransform({
            x: dragRef.current.position.x,
            y: 0,
            z: dragRef.current.position.z
        }, dragRef.current.quaternion);
        dragRef.current.rotation.y = 0;
        dragRef.current.position.x = 0;
        dragRef.current.position.z = 0;
    };

    const { camera } = useThree();
    const controllerRight = useXRInputSourceState('controller', 'right');
    const controllerLeft = useXRInputSourceState('controller', 'left');
    const handRight = useXRInputSourceState('hand', 'right');
    const handLeft = useXRInputSourceState('hand', 'left');

    useXRInputSourceEvent('all', 'selectend', (e) => {
        if (e.target.controller === grabbingController.current) {
            grabbingController.current = undefined;
            calibrate();
        }
    }, []);

    return &lt;>
        &lt;group ref={dragRef} onPointerDown={(e) => {
            if (grabbingController.current) return;
            if (e.nativeEvent?.inputSource) {
                if (e.nativeEvent.inputSource.hand === null) {
                    grabbingController.current = e.nativeEvent.inputSource.handedness === 'right' ? controllerRight?.object : controllerLeft?.object;
                } else {
                    grabbingController.current = e.nativeEvent.inputSource.handedness === 'right' ? handRight?.object : handLeft?.object;
                }
            } else if (e.nativeEvent?.button === 0) {
                grabbingController.current = camera;
            }
            if (grabbingController.current) {
                previousTransform.copy(grabbingController.current.matrixWorld).invert();
            }
        }}
            onPointerUp={() => {
                if (grabbingController.current) {
                    grabbingController.current = undefined;
                    calibrate();
                }
            }}>
            &lt;Icon theme="calibrationPoint" model={calibrateIcon} themesOverride={themes} />
        &lt;/group>
    &lt;/>;
}



export function Main() {
    return &lt;IfInSessionMode allow={['immersive-ar', 'immersive-vr']}>
        &lt;CalibrationPoint />
    &lt;/IfInSessionMode>;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="UserManager" name="UserManager"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple user manager component",
    "dependencies": [
        "#Spatialstrates",
        "webstrate-components-repos MaterialDesignOutlinedIcons"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="User Manager Concepts" auto>{
    "concepts": {
        "UserManager": {
            "schema": {
                "placeholder": "string",
                "localUser": "User"
            },
            "mappings": {
                "localUser": [ "memory", "cauldron" ]
            }
        },
        "User": {
            "schema": {
                "name": "string"
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="User Manager Component" id class="default component dynamic-gui-component">import React from 'react';
const { useState, useEffect } = React;
import { Varv, useProperty } from '#VarvReact';



function UserRenamer() {
    const [name, setName] = useProperty('name');
    return &lt;label>
        Rename User
        &lt;input value={name ? name : ''} onChange={e => setName(e.target.value)} title='Rename User' />
    &lt;/label>;
}

function UserSelector({ selectUser }) {
    const [name] = useProperty('name');
    const [localUser] = useProperty('localUser');
    const [uuid] = useProperty('concept::uuid');

    const deleteUser = (e) => {
        e.stopPropagation();
        VarvEngine.getConceptFromType('User').delete(uuid);
    };

    return &lt;div className='user' local={localUser == uuid ? 'true' : null} onClick={() => selectUser(uuid)} title={'Select User ' + name}>
        &lt;span className="user-name">{name}&lt;/span>
        &lt;span className="delete-icon material-icons-outlined" onClick={deleteUser} title="Delete User">delete&lt;/span>
    &lt;/div>;
}

function Login() {
    const [enabled, setEnabled] = useState(false);
    const [localUser, setLocalUser] = useProperty('localUser');
    const userConcept = VarvEngine.getConceptFromType('User');

    useEffect(() => {
        if (localUser) return;

        const runAsync = async () => {
            const users = await VarvEngine.lookupInstances('User');
            try {
                if (users.length > 0) {
                    await setLocalUser(users[0]);
                } else {
                    const uuid = await userConcept.create(null, { name: 'Guest' });
                    await setLocalUser(uuid);
                }
            } catch (e) {
                // Sometimes there are timing issues with `setLocalUser`
            }
        };

        runAsync();
    }, [setLocalUser]);

    const addUser = async () => {
        setLocalUser(await userConcept.create(null, { name: 'User ' + Math.floor(Math.random() * 1000) }));
    };

    const selectUser = (userId) => {
        setLocalUser(userId);
    };

    return &lt;>
        {enabled ? &lt;div className="user-manager-modal" onClick={() => setEnabled(false)}>
            &lt;div className="user-manager" onClick={(e) => e.stopPropagation()}>
                &lt;div className="user-headline">User Selection&lt;/div>
                &lt;div className="user-menu">
                    &lt;button title="Add User" onClick={addUser}>Add User&lt;/button>
                    &lt;Varv property="localUser">
                        &lt;UserRenamer />
                    &lt;/Varv>
                &lt;/div>
                &lt;div className="user-list">
                    &lt;Varv concept="User">
                        &lt;UserSelector selectUser={selectUser} />
                    &lt;/Varv>
                &lt;/div>
            &lt;/div>
        &lt;/div> : null}

        &lt;div className="user-manager-button" onClick={() => setEnabled(true)}>User Manager&lt;/div>
    &lt;/>;
}

export function Main() {
    return &lt;Varv concept="UserManager">
        &lt;Login />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="User Manager Style" auto>@mixin heading-font {
    font-weight: 500;
    font-size: 13px;
    letter-spacing: 0.25px;
}

.user-manager-button {
    @include heading-font;
    height: 24px;
    line-height: 24px;
    border-radius: 4px;
    padding: 0 8px;
    background: #ddd;
    position: fixed;
    top: 12px;
    right: 64px;
    z-index: 99999;
    cursor: pointer;
    user-select: none;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60);
    border: 1px solid #cccccc70;

    &.enabled {
        background: rgba(96, 173, 94, .80);
        border: 1px solid rgba(96, 173, 94, .439);
        color: #fff;
    }
}

.user-manager-modal {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    z-index: 100000;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(5px);
    background: rgba(192, 192, 192, .60) !important;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 12px;

    button {
        @include heading-font;

        user-select: none;
        border-radius: 4px;
        padding: 2px 8px;
        background: #636363;
        color: #fff;
        vertical-align: middle;
        text-align: center;
        cursor: pointer;
        border: none;

        &:hover {
            background: #848484;
        }

        &:active {
            background: #606060;
        }

        &.red {
            background: #d32f2f !important;

            &:hover {
                background: #ff6659 !important;
            }

            &:active {
                background: #9a0007 !important;
            }
        }

        &.green {
            background: #2e7d32 !important;

            &:hover {
                background: #60ad5e !important;
            }

            &:active {
                background: #005005 !important;
            }
        }
    }

    label {
        @include heading-font;

        user-select: none;
        white-space: nowrap;

        background: #eeeeee;
        color: #000000;

        border-radius: 4px;
        padding-left: 8px;
        padding-right: 8px;
        padding-right: 0;

        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        align-items: center;
        gap: 4px;

        input[type="checkbox"] {
            width: 24px;
        }

        input:not([type="checkbox"]),
        select {
            border-top-left-radius: 16px;
            border-bottom-left-radius: 16px;
            height: 100%;
        }
    }

    input:not([type="checkbox"]),
    select,
    textarea {
        border-radius: 4px;
        border: none;
        padding: 0 8px;
        text-overflow: ellipsis;
        outline: none;
        color: #000;
        width: 100%;
    }

    .user-manager {
        background: #fafafa;
        border-radius: 8px;
        padding: 16px;
        display: flex;
        flex-direction: column;
        flex-wrap: nowrap;
        gap: 12px;
        max-width: 100%;
        box-shadow: 0 0 12px 0 rgba(0, 0, 0, 0.25);
    }


    .user-headline {
        font-size: 24px;
        font-weight: 700;
        cursor: default;
        user-select: none;
    }

    .user-menu {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 8px;
        min-height: 32px;
        padding: 8px;
        border-radius: 4px;
        background: #ddd;
    }

    .user-list {
        display: flex;
        flex-direction: row;
        gap: 8px;
        padding: 8px;
        border-radius: 4px;
        background: #ddd;
    }

    .user {
        height: 32px;
        cursor: pointer;
        border-radius: 20px;
        background: #eeeeee;
        user-select: none;
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 8px;
        align-items: center;

        .user-name {
            padding-left: 8px;
        }

        .delete-icon {
            font-size: 20px;
            text-align: center;
            line-height: 32px;
            cursor: pointer;
            background: #d32f2f;
            color: #fff;
            border-radius: 50%;
            width: 32px;
            height: 32px;
        }
    }

    .user[local="true"] {
        background: #FFAB40;
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Init Manager Concept" auto>const initConcept = async () => {
    try {
        const managers = await VarvEngine.lookupInstances('UserManager');
        if (managers.length == 0) {
            await VarvEngine.getConceptFromType('UserManager').create(null, {});
        }
    } catch (e) {
        // Ignore
    }
};

VarvEngine.registerEventCallback('engineReloaded', () => {
    initConcept();
});

initConcept();
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Avatar" name="Avatar"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Awareness avatars for remote users",
    "dependencies": [
        "varv-repos varv-signaling",
        "#Spatialstrates",
        "#Text",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [
        "avatar-models.zip"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Avatar Concepts" auto>{
    "concepts": {
        "AvatarManager": {
            "schema": {
                "enabled": "boolean"
            }
        },
        "Avatar": {
            "schema": {
                "type": {
                    "string":{
                        "default": "camera",
                        "enum": [ "camera", "controllerLeft", "controllerRight", "handLeft", "handRight" ]
                    }
                },
                "userAgent": "string",
                "inputSourceProfile": "string",
                "client": "string",
                "clientVideoStream": { "array": {
                    "items": "VideoStream",
                    "derive": {
                        "concepts": [ "VideoStream" ],
                        "properties": [ "client" ],
                        "transform": [
                            { "get": { "property": "client", "as": "client" }},
                            { "select": {
                                "concept": "VideoStream",
                                "where": { "property": "client", "equals": "$client" },
                                "keepContext": true
                            }}
                        ]
                    }
                }},
                "userName": "string",
                "isMine": "boolean",
                "position": { "array": {
                    "items": "number",
                    "default": [ 0, 0, 0 ]
                }},
                "rotation": { "array": {
                    "items": "number",
                    "default": [ 0, 0, 0 ]
                }},
                "remoteControlled": "boolean",
                "remoteControllingClient": "string"
            },
            "defaultMappings": [ "signaling", "memory", "cauldron" ],
            "mappings": {
                "isMine": [ "memory", "cauldron" ]
            }
        }
    },
    "dataStores": {
        "signaling": { "type": "signaling" }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Avatar" class="default component dynamic-scene-component" id>import React from 'react';
let { useState, useEffect } = React;
import { Cone, Gltf, useGLTF } from '@react-three/drei';
import { useXR } from '@react-three/xr';
import { useFrame, useThree } from '@react-three/fiber';

import { Varv, useProperty } from '#VarvReact';
import { Text } from '#Text .default';
let VideoStream;
if (Fragment.one('#VideoStream .default')) {
    const videoStreamModule = await Fragment.one('#VideoStream .default').require();
    VideoStream = videoStreamModule.VideoStream;
}



useGLTF.preload("avatar-models.zip/model-camera.glb");
useGLTF.preload("avatar-models.zip/model-phone.glb");
useGLTF.preload("avatar-models.zip/model-headset.glb");
useGLTF.preload("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/meta-quest-touch-plus/left.glb");
useGLTF.preload("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/meta-quest-touch-plus/right.glb");
useGLTF.preload("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/generic-hand/left.glb");
useGLTF.preload("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/generic-hand/right.glb");

const cameraModel = &lt;Gltf src="avatar-models.zip/model-camera.glb" scale={1} rotation={[0, Math.PI, 0]} />;
const phoneModel = &lt;Gltf src="avatar-models.zip/model-phone.glb" scale={0.01} />;
const headsetModel = &lt;Gltf src="avatar-models.zip/model-headset.glb" scale={0.9} rotation={[0, Math.PI, 0]} position={[0, 0.04, 0.11]} />;

const controllerLeftModel = &lt;Gltf src="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/meta-quest-touch-plus/left.glb" scale={1} rotation={[Math.PI / 4, 0, 0]} />;
const controllerRightModel = &lt;Gltf src="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/meta-quest-touch-plus/right.glb" scale={1} rotation={[Math.PI / 4, 0, 0]} />;
const handLeftModel = &lt;Gltf src="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/generic-hand/left.glb" scale={0.01} />;
const handRightModel = &lt;Gltf src="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/generic-hand/right.glb" scale={0.01} />;

const viewCone = &lt;Cone args={[0.1, 0.1, 32]} position={[0, 0, -0.05]} rotation={[Math.PI / 2, 0, 0]}>
    &lt;meshStandardMaterial color="skyblue" transparent={true} opacity={0.66} />
&lt;/Cone>;



function Avatar() {
    const [type] = useProperty('type');
    const [userAgent] = useProperty('userAgent');
    const [inputSourceProfile] = useProperty('inputSourceProfile');
    const [position] = useProperty('position');
    const [rotation] = useProperty('rotation');
    const [userName] = useProperty('userName');
    const [client] = useProperty('client');

    const [remoteControlled, setRemoteControlled] = useProperty('remoteControlled');
    const [remoteControllingClient, setRemoteControllingClient] = useProperty('remoteControllingClient');

    const [model, setModel] = useState(cameraModel);

    useEffect(() => {
        switch (type) {
            case 'camera':
                if (userAgent.includes('OculusBrowser')) {
                    setModel(&lt;> {headsetModel} {viewCone} &lt;/>);
                } else if (/(iPad|iPhone|iPod|Android)/i.test(userAgent)) {
                    setModel(&lt;> {phoneModel} {viewCone} &lt;/>);
                } else {
                    setModel(&lt;> {cameraModel} {viewCone} &lt;/>);
                }
                break;
            // TODO: Use the inputSourceProfile to determine the correct model
            case 'controllerLeft':
                setModel(controllerLeftModel);
                break;
            case 'controllerRight':
                setModel(controllerRightModel);
                break;
            case 'handLeft':
                setModel(handLeftModel);
                break;
            case 'handRight':
                setModel(handRightModel);
                break;
            default:
                setModel(cameraModel);
        }
    }, [type, userAgent, inputSourceProfile]);

    const remoteControlCallback = (newValue) => {
        // TODO: This feature needs to be re-implemented
        setRemoteControlled(newValue);
        setRemoteControllingClient(newValue ? webstrate.clientId : '');
    };

    return &lt;group position={position} rotation={rotation}>
        {type == 'camera' ? &lt;group
            onPointerDown={() => remoteControlCallback(true)}
            onPointerUp={() => remoteControlCallback(false)}>
            {model}
        &lt;/group> : model}
        {VideoStream ? &lt;Varv property="clientVideoStream">
            &lt;VideoStream client={client} />
        &lt;/Varv> : null}
        {type == 'camera' ? &lt;Text
            position={[0, 0.11, 0]}
            rotation={[0, Math.PI, 0]}
            textAlign="center"
            anchorX="center"
            anchorY="middle"
            color="black"
            outlineWidth="5%"
            outlineColor="white"
            fontSize={0.05}>
            {userName}
        &lt;/Text> : null}
    &lt;/group >;
}

function AvatarRemoteController() {
    const [remoteControlled] = useProperty('remoteControlled');
    const [position] = useProperty('position');
    const [rotation] = useProperty('rotation');

    const camera = useThree(state => state.camera);

    useFrame(() => {
        if (remoteControlled) {
            camera.position.set(position[0], position[1], position[2]);
            camera.rotation.set(rotation[0], rotation[1], rotation[2]);
        }
    });
}

function Avatars() {
    return &lt;>
        &lt;Varv concept="Avatar" if="!isMine">
            &lt;Avatar />
        &lt;/Varv>
        &lt;Varv concept="Avatar" if="isMine">
            &lt;AvatarRemoteController />
        &lt;/Varv>
    &lt;/>;
}



export function Main() {
    return &lt;Varv concept="AvatarManager" if="enabled">
        &lt;Avatars />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Avatar Transmitter" id class="component dynamic-scene-component">import React from 'react';
let { useEffect, useRef } = React;
import { useXRInputSourceState } from '@react-three/xr';
import { useFrame, useThree } from '@react-three/fiber';
import { Varv } from '#VarvReact';



// Remove other people's Avatars when clients leave or join
const cleanup = () => {
    setTimeout(async () => {
        const concept = await VarvEngine.getConceptFromType('Avatar');
        const avatars = await VarvEngine.lookupInstances('Avatar');
        for (let avatar of avatars) {
            if (!webstrate.clients.includes(await concept.getPropertyValue(avatar, 'client'))) {
                concept.delete(avatar);
            }
        }
    }, 0);
};

const SLOW_WRITEBACK_TIMEOUT = 500;
function AvatarTransmitter({ device, type, inputSourceProfiles }) {
    const conceptRef = useRef(null);
    const avatarConcept = VarvEngine.getConceptFromType('Avatar');

    useEffect(() => {
        if (!device) return;

        const avatarFilter = FilterAction.constructFilter({
            and: [
                {
                    property: 'type',
                    equals: type
                },
                {
                    property: 'client',
                    equals: webstrate.clientId
                }
            ]
        });

        const runAsync = async () => {
            let uuid;
            const ids = await VarvEngine.lookupInstances('Avatar', avatarFilter);

            if (ids.length > 0) {
                // Reuse existing concept if available
                uuid = ids[0];
            } else {
                // Otherwise create a new one
                uuid = await avatarConcept.create(null, {
                    type: type,
                    userAgent: window.navigator.userAgent,
                    client: webstrate.clientId,
                    userName: webstrate.user.displayName || 'Anonymous',
                    inputSourceProfile: inputSourceProfiles ? JSON.stringify(inputSourceProfiles) : '',
                    isMine: true
                });
            }
            conceptRef.current = uuid;
        };

        runAsync();
    }, [device, type]);

    const slowWritebackTimeout = useRef(null);
    useFrame(() => {
        if (!device) return;
        if (!conceptRef.current) return;

        if (!slowWritebackTimeout.current) {
            avatarConcept.setPropertyValue(conceptRef.current, 'position', device.position.toArray());
            avatarConcept.setPropertyValue(conceptRef.current, 'rotation', [device.rotation.x, device.rotation.y, device.rotation.z]);

            slowWritebackTimeout.current = setTimeout(() => {
                slowWritebackTimeout.current = null;
            }, SLOW_WRITEBACK_TIMEOUT);
        }
    });
}

function AvatarTransmitters() {
    const { camera } = useThree();
    const controllerRight = useXRInputSourceState('controller', 'right');
    const controllerLeft = useXRInputSourceState('controller', 'left');
    const handRight = useXRInputSourceState('hand', 'right');
    const handLeft = useXRInputSourceState('hand', 'left');

    // Ensure that Avatars are updated in the environement
    useEffect(() => {
        webstrate.on('clientPart', cleanup);
        cleanup();
        return () => webstrate.off('clientPart', cleanup);
    }, []);

    return &lt;>
        &lt;AvatarTransmitter device={camera} type="camera" />
        {controllerRight ? &lt;AvatarTransmitter device={controllerRight?.object} type="controllerRight" inputSourceProfiles={controllerRight.profiles} /> : null}
        {controllerLeft ? &lt;AvatarTransmitter device={controllerLeft?.object} type="controllerLeft" inputSourceProfiles={controllerLeft.profiles} /> : null}
        {handRight ? &lt;AvatarTransmitter device={handRight?.object} type="handRight" inputSourceProfiles={handRight.profiles} /> : null}
        {handLeft ? &lt;AvatarTransmitter device={handLeft?.object} type="handLeft" inputSourceProfiles={handLeft.profiles} /> : null}
    &lt;/>;
}



export function Main() {
    return &lt;Varv concept="AvatarManager" if="enabled">
        &lt;AvatarTransmitters />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Avatar Menu" class auto>import React from 'react';
import {
    addSubMenu,
    addItemToSubMenu,
    MenuTitle,
    MenuSpacer,
    MenuButton
} from '#Menu .default';
import {
    addItem,
    ControllerMenuButton
} from '#ControllerMenu .default';
import { Varv, useProperty } from '#VarvReact';



function AvatarToggleButton() {
    const [enabled, setEnabled] = useProperty('enabled');
    return &lt;MenuButton onClick={() => setEnabled(!enabled)} toggled={enabled ? 'true' : null}>Toggle Avatars ({enabled ? 'On' : 'Off'})&lt;/MenuButton>;
}

addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'title', &lt;MenuTitle title="Media Sharing" />, 0);
addItemToSubMenu('media-sharing', 'avatars', &lt;Varv concept="AvatarManager">
    &lt;AvatarToggleButton />
&lt;/Varv>, 750);
addItemToSubMenu('media-sharing', 'spacer4', &lt;MenuSpacer />, 800);

function AvatarToggleControllerButton() {
    const [enabled, setEnabled] = useProperty('enabled');
    return &lt;ControllerMenuButton position={[-0.18, 0.06, 0]} name={'Toggle Avatars'} theme={enabled ? 'button:toggled' : null} callback={() => setEnabled(!enabled)} />;
}

addItem('avatars', &lt;Varv concept="AvatarManager">
    &lt;AvatarToggleControllerButton />
&lt;/Varv>);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Init Manager Concept" auto>const initConcept = async () => {
    try {
        const managers = await VarvEngine.lookupInstances('AvatarManager');
        if (managers.length == 0) {
            await VarvEngine.getConceptFromType('AvatarManager').create(null, {});
        }
    } catch (e) {
        // Ignore
    }
};

VarvEngine.registerEventCallback('engineReloaded', () => {
    initConcept();
});

initConcept();
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER></CODE-FOLDER><CODE-FOLDER name="Streaming" id><CODE-FOLDER name="Utils"><WPM-PACKAGE name="StreamManager" id="StreamManager"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A generic stream sharing class for Webstrate servers with stream signaling support",
    "dependencies": [],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Stream Manager" id class="default module">const DEBUG = false;



export class StreamShare {
    /**
     * Creates a streamshare using the given element to signal
     * addition and removal of streams. Up to one stream per client
     * is possible for each element.
     */
    constructor(element) {
        let self = this;
        this.clientStreams = new Map();
        this.addedListeners = [];
        if (!element) throw new Error('Must provide an actual DOM element for signalling, was ', element);
        if (element.parentElement === undefined) throw new Error('StreamShare element must be in DOM');
        this.supported = true;
        if (!(element.webstrate && element.webstrate.signalStream)) {
            this.supported = false;
            if (DEBUG) console.log('StreamShare: The webstrate implementation or element does not support webstrate stream signalling, stream sharing is disabled', element);
            return;
        }
        this.element = element;

        this.element.webstrate.on('signalStream', function onSignalStream(clientId, meta, accept) {
            let con = accept(function (stream) {
                if (self.clientStreams.get(clientId)) {
                    if (DEBUG) console.log('StreamShare: Warning: Only one stream per client is supported per element but ' + clientId + ' shared another one...');
                }
                self.clientStreams.set(clientId, stream);
                self._onStreamAdded(clientId, stream);
            });
        });
    }

    stopSharing() {
        if (this.currentSignallingFunction) {
            this.element.webstrate.stopStreamSignal(this.currentSignallingFunction);
            this.currentSignallingFunction = null;
        }
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
            this.currentStream = null;
        }
    }

    async shareStream(media, displayOptions = null) {
        let self = this;
        if (!this.supported) {
            console.log('Tried to share a stream on an unsupported StreamShare, see previous warnings');
            return;
        }

        // Get the stream
        if (!displayOptions) {
            console.error('displayOptions are required to share a stream.');
        }

        if (this.currentStream) {
            this.stopSharing();
        }
        if (media == 'displayMedia') {
            this.currentStream = await navigator.mediaDevices.getDisplayMedia(displayOptions);
        } else {
            this.currentStream = await navigator.mediaDevices.getUserMedia(displayOptions);
        }
        this.currentSignallingFunction = function signalStream(clientId, accept) {
            let con = accept(self.currentStream, {}, () => {
                if (DEBUG) console.log('StreamShare: client ' + clientId + ' started receiving our streamshare');
            });
            con.onclose(() => {
                if (DEBUG) console.log('StreamShare: client ' + clientId + ' stopped receiving our streamshare');
            });
        };

        // Register the stream on the element
        if (DEBUG) console.log('StreamShare: Starting streamshare');
        this._onStreamAdded(webstrate.clientId, this.currentStream);
        this.element.webstrate.signalStream(this.currentSignallingFunction);
        return this.currentStream;
    }

    _onStreamAdded(client, stream) {
        // Notify listeners
        this.clientStreams.set(client, stream);
        this.addedListeners.forEach(listener => {
            listener(client, stream);
        });
    }
    addStreamAddedListener(listener) {
        this.addedListeners.push(listener);

        // Backfill with current streams
        for (let [key, value] of this.clientStreams) {
            listener(key, value);
        }
    }
    removeStreamAddedListener(listener) {
        const index = this.addedListeners.indexOf(listener);
        if (index > -1) {
            this.addedListeners.splice(index, 1);
        }
    }
}

if (!window.moduleStreamManager) {
    window.moduleStreamManager = {
        clicked: false,
        cleanupConceptTypes: []
    };
    document.addEventListener('click', () => { window.moduleStreamManager.clicked = true; });

    const cleanup = async () => {
        // Remove screenshares when a client leaves or joins
        for (const conceptType in window.moduleStreamManager.cleanupConceptTypes) {
            if (webstrate.clients.length &lt; 1) return;
            let concept = VarvEngine.getConceptFromType(conceptType);
            let shares = await (VarvEngine.lookupInstances(conceptType));
            shares.filter(share => !webstrate.clients.includes(concept.getPropertyValue(share, 'client'))).forEach(share => { concept.delete(share); });
        }
    };

    webstrate.on('clientPart', cleanup);
    webstrate.on('clientJoin', cleanup);
}

export const doIfClicked = (callback) => {
    if (window.moduleStreamManager.clicked) {
        setTimeout(() => {
            callback();
        }, 200);
    } else {
        document.addEventListener('click', () => {
            callback();
        });
    }
};

export const addCleanupConceptType = (type) => {
    window.moduleStreamManager.cleanupConceptTypes.push(type);
};
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ScreenStreamManager" name="ScreenStreamManager"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stream manager for screen share streams",
    "dependencies": [
        "#StreamManager"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Screen Stream Manager" id class="default module">import { doIfClicked, StreamShare, addCleanupConceptType } from '#StreamManager .default';



const STREAM_ELEMENT = 'screen-signaling';
let DOM_ELEMENT = document.querySelector(STREAM_ELEMENT);
if (!DOM_ELEMENT) {
    DOM_ELEMENT = document.createElement(STREAM_ELEMENT);
    document.body.appendChild(DOM_ELEMENT);
    WPMv2.stripProtection(DOM_ELEMENT);
}
const CONCEPT_NAME = 'ScreenStream';
const ID_PREFIX = CONCEPT_NAME + '-';
export const QUERY_PREFIX = '#' + ID_PREFIX;



// Hook up new streams with a video element
if (!window.moduleScreenStreamManager) {
    window.moduleScreenStreamManager = {
        streamShare: new StreamShare(DOM_ELEMENT)
    };

    addCleanupConceptType(CONCEPT_NAME);

    window.moduleScreenStreamManager.streamShare.addStreamAddedListener((client, stream) => {
        console.log('Got screenStream from ' + client);

        // Find or create their element
        let element = document.querySelector(QUERY_PREFIX + client);
        if (!element) {
            element = document.createElement('video');
            element.style.position = 'fixed';
            element.style.width = '0px';
            element.id = ID_PREFIX + client;
            element.muted = true;
            document.body.appendChild(element);
        }
        element.srcObject = stream;
        doIfClicked(() => { element.play(); });
    });

    // Convenience functions for managing Varv spawning and despawning
    window.stopSharingMyScreen = async () => {
        window.moduleScreenStreamManager.streamShare.stopSharing();
        const concept = VarvEngine.getConceptFromType(CONCEPT_NAME);
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        instances.forEach(instance => concept.delete(instance));
    };
    window.shareMyScreen = async () => {
        const stream = await window.moduleScreenStreamManager.streamShare.shareStream('displayMedia', {
            video: {
                displaySurface: 'browser',
            },
            audio: {
                suppressLocalAudioPlayback: false,
            },
            preferCurrentTab: false,
            selfBrowserSurface: 'exclude',
            systemAudio: 'exclude',
            surfaceSwitching: 'include',
            monitorTypeSurfaces: 'include',
        });
        if (stream) {
            stream.getVideoTracks()[0].addEventListener('ended', () => {
                window.stopSharingMyScreen();
            });
            return VarvEngine.getConceptFromType(CONCEPT_NAME).create(null, { client: webstrate.clientId });
        }
    };
}

export const streamShare = window.moduleScreenStreamManager.streamShare;
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="VideoStreamManager" name="VideoStreamManager"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stream manager for camera video streams",
    "dependencies": [
        "#StreamManager"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Video Stream Manager" id class="default module">import { doIfClicked, StreamShare, addCleanupConceptType } from '#StreamManager .default';



const STREAM_ELEMENT = 'video-signaling';
let DOM_ELEMENT = document.querySelector(STREAM_ELEMENT);
if (!DOM_ELEMENT) {
    DOM_ELEMENT = document.createElement(STREAM_ELEMENT);
    document.body.appendChild(DOM_ELEMENT);
    WPMv2.stripProtection(DOM_ELEMENT);
}
const CONCEPT_NAME = 'VideoStream';
const ID_PREFIX = CONCEPT_NAME + '-';
export const QUERY_PREFIX = '#' + ID_PREFIX;



// Hook up new streams with a video element
if (!window.moduleVideoStreamManager) {
    window.moduleVideoStreamManager = {
        streamShare: new StreamShare(DOM_ELEMENT)
    };

    addCleanupConceptType(CONCEPT_NAME);

    window.moduleVideoStreamManager.streamShare.addStreamAddedListener((client, stream) => {
        console.log('Got videoStream from ' + client);

        // Find or create their element
        let element = document.querySelector(QUERY_PREFIX + client);
        if (!element) {
            element = document.createElement('video');
            element.style.position = 'fixed';
            element.style.width = '0px';
            element.id = ID_PREFIX + client;
            element.muted = true;
            document.body.appendChild(element);
        }
        element.srcObject = stream;
        doIfClicked(() => { element.play(); });
    });

    // Convenience functions for managing Varv spawning and despawning
    window.stopSharingMyVideo = async () => {
        window.moduleVideoStreamManager.streamShare.stopSharing();
        const concept = VarvEngine.getConceptFromType(CONCEPT_NAME);
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        instances.forEach(instance => concept.delete(instance));
    };
    window.shareMyVideo = async () => {
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        if (instances.length > 0) {
            console.log('Already sharing video');
            return;
        }
        const stream = await window.moduleVideoStreamManager.streamShare.shareStream('userMedia', {
            video: true,
            audio: false
        });
        if (stream) {
            stream.getVideoTracks()[0].addEventListener('ended', () => {
                window.stopSharingMyVideo();
            });
            return VarvEngine.getConceptFromType(CONCEPT_NAME).create(null, { client: webstrate.clientId });
        }
    };
}

export const streamShare = window.moduleVideoStreamManager.streamShare;
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="AudioStreamManager" name="AudioStreamManager"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stream manager for audio streams",
    "dependencies": [
        "#StreamManager"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Audio Stream Manager" id class="default module">import { doIfClicked, StreamShare, addCleanupConceptType } from '#StreamManager .default';



const STREAM_ELEMENT = 'audio-signaling';
let DOM_ELEMENT = document.querySelector(STREAM_ELEMENT);
if (!DOM_ELEMENT) {
    DOM_ELEMENT = document.createElement(STREAM_ELEMENT);
    document.body.appendChild(DOM_ELEMENT);
    WPMv2.stripProtection(DOM_ELEMENT);
}
const CONCEPT_NAME = 'AudioStream';
const ID_PREFIX = CONCEPT_NAME + '-';
export const QUERY_PREFIX = '#' + ID_PREFIX;



// Hook up new streams with a video element
if (!window.moduleAudioStreamManager) {
    window.moduleAudioStreamManager = {
        streamShare: new StreamShare(DOM_ELEMENT)
    };

    addCleanupConceptType(CONCEPT_NAME);

    window.moduleAudioStreamManager.streamShare.addStreamAddedListener((client, stream) => {
        console.log('Got audioStream from ' + client);

        // Find or create their element
        let element = document.querySelector(QUERY_PREFIX + client);
        if (!element) {
            element = document.createElement('video');
            element.style.position = 'fixed';
            element.style.width = '0px';
            element.id = ID_PREFIX + client;
            element.muted = client == webstrate.clientId;
            document.body.appendChild(element);
        }
        element.srcObject = stream;
        doIfClicked(() => { element.play(); });
    });

    // Convenience functions for managing Varv spawning and despawning
    window.stopSharingMyAudio = async () => {
        window.moduleAudioStreamManager.streamShare.stopSharing();
        const concept = VarvEngine.getConceptFromType(CONCEPT_NAME);
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        instances.forEach(instance => concept.delete(instance));
    };
    window.shareMyAudio = async () => {
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        if (instances.length > 0) {
            console.log('Already sharing audio');
            return;
        }
        const stream = await window.moduleAudioStreamManager.streamShare.shareStream('userMedia', {
            video: false,
            audio: true
        });
        if (stream) {
            stream.getAudioTracks()[0].addEventListener('ended', () => {
                window.stopSharingMyAudio();
            });
            return VarvEngine.getConceptFromType(CONCEPT_NAME).create(null, { client: webstrate.clientId });
        }
    };
}



export const streamShare = window.moduleAudioStreamManager.streamShare;
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Components"><WPM-PACKAGE id="ScreenStream" name="ScreenStream"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stream component for screen streams",
    "dependencies": [
        "#Movable",
        "#StreamManager",
        "#ScreenStreamManager",
        "#Menu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Screen Stream Concepts" auto>{
    "concepts": {
        "ScreenStream": {
            "schema": {
                "client": "string"
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Screen Stream" class="default component dynamic-scene-component">import React from 'react';
const { useState, useEffect, useMemo } = React;
import { BoxGeometry, MeshStandardMaterial, PlaneGeometry, LinearMipmapLinearFilter } from 'three';
import * as THREE from 'three';
import { Plane } from '@react-three/drei';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { Varv, useProperty } from '#VarvReact';

import { Movable, SELECTED_COLOR_PRIMARY, HOVERED_SELECTED_COLOR_PRIMARY } from '#Movable .default';
import { doIfClicked } from '#StreamManager .default';
import { QUERY_PREFIX, streamShare } from '#ScreenStreamManager .default';


const MAX_SIZE = 0.75;

const frameGeometry = new RoundedBoxGeometry(1, 1, 0.005, 1);
const frameMaterial = new MeshStandardMaterial({ color: '#E0E0E0', metalness: 0.2, roughness: 0.5 });
const frameMaterialHovered = new MeshStandardMaterial({ color: '#FFFFFF', metalness: 0.2, roughness: 0.5 });
const frameMaterialSelected = new MeshStandardMaterial({ color: SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });
const frameMaterialHoveredSelected = new MeshStandardMaterial({ color: HOVERED_SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });



function ScreenStream() {
    const [client] = useProperty('client');

    const [screen, setScreen] = useState(document.querySelector(QUERY_PREFIX + client));
    const [width, setWidth] = useState(MAX_SIZE);
    const [height, setHeight] = useState(MAX_SIZE);

    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');

    const updateSize = (aspectRatio) => {
        if (aspectRatio > 1) {
            setWidth(MAX_SIZE);
            setHeight(MAX_SIZE / aspectRatio);
        } else {
            setWidth(MAX_SIZE * aspectRatio);
            setHeight(MAX_SIZE);
        }
    };

    useEffect(() => {
        if (screen) {
            // Playing immediately may fail, wait for interaction in that case
            doIfClicked(() => {
                updateSize(screen.videoWidth / screen.videoHeight || 1);
                screen.addEventListener('resize', () => {
                    updateSize(screen.videoWidth / screen.videoHeight || 1);
                })
            });
        }

        // Make sure to catch stream updates
        let listener = function (newStreamId) {
            if (newStreamId == client) setScreen(document.querySelector(QUERY_PREFIX + client));
        };
        streamShare.addStreamAddedListener(listener);

        return () => {
            streamShare.removeStreamAddedListener(listener);
        }
    }, [screen, client]);

    const texture = useMemo(() => screen ? &lt;videoTexture attach='map' args={[screen]} anisoptry={16} generateMipmaps={true} minFilter={THREE.LinearMipmapLinearFilter} colorSpace={THREE.SRGBColorSpace} /> : null, [screen]);

    const handle = useMemo(() => &lt;mesh
        geometry={frameGeometry}
        material={selected ? (hovered ? frameMaterialHoveredSelected : frameMaterialSelected) : (hovered ? frameMaterialHovered : frameMaterial)}
        scale={[width + 0.02, height + 0.02, 1]}
        position={[0, 0.125 - 0.0125, -0.0055]}
        autoUpdateMatrix={false}>
    &lt;/mesh>, [width, height, selected, hovered]);

    return &lt;Movable handle={handle} upright={false}>
        &lt;Plane args={[width, height]} position={[0, 0.125 - 0.0125, 0]}>
            &lt;meshBasicMaterial toneMapped={false} color={screen ? 'white' : 'darkgrey'}>
                {texture}
            &lt;/meshBasicMaterial>
        &lt;/Plane>
    &lt;/Movable>;
}

export function Main() {
    return &lt;Varv concept="ScreenStream">
        &lt;ScreenStream />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Screen Stream Menu" auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuSpacer, MenuButton } from '#Menu .default';



// Import in order to start the manager
import ScreenStreamManager from '#ScreenStreamManager .default';



addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'share-screen', &lt;MenuButton onClick={window.shareMyScreen}>Share Screenshare&lt;/MenuButton>, 100);
addItemToSubMenu('media-sharing', 'stop-screen', &lt;MenuButton onClick={window.stopSharingMyScreen}>Stop Screenshare&lt;/MenuButton>, 200);
addItemToSubMenu('media-sharing', 'spacer1', &lt;MenuSpacer />, 250);
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="VideoStream" name="VideoStream"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stream component for video streams",
    "dependencies": [
        "#StreamManager",
        "#VideoStreamManager",
        "#Menu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Video Stream Concepts" auto>{
    "concepts": {
        "VideoStream": {
            "schema": {
                "client": "string"
            }
        }
    }
}</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Video Stream" class="default component">import React from 'react';
const { useState, useEffect, useMemo } = React;
import { MeshStandardMaterial } from 'three';
import * as THREE from 'three';
import { Plane } from '@react-three/drei';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';

import { doIfClicked } from '#StreamManager .default';
import { QUERY_PREFIX, streamShare } from '#VideoStreamManager .default';



const frameGeometry = new RoundedBoxGeometry(1, 1, 0.005, 1);
const frameMaterial = new MeshStandardMaterial({ color: '#E0E0E0', metalness: 0.2, roughness: 0.5 });



export function VideoStream({ client }) {
    const [video, setVideo] = useState(document.querySelector(QUERY_PREFIX + client));
    const [aspectRatio, setAspectRatio] = useState(1);

    useEffect(() => {
        if (video) {
            // Playing immediately may fail, wait for interaction in that case
            doIfClicked(() => {
                setAspectRatio(video.videoWidth / video.videoHeight);
                video.addEventListener('resize', () => {
                    setAspectRatio(video.videoWidth / video.videoHeight);
                });
            });
        }

        // Make sure to catch stream updates
        let listener = function (newStreamId) {
            if (newStreamId == client) setVideo(document.querySelector(QUERY_PREFIX + client));
        };
        streamShare.addStreamAddedListener(listener);

        return () => {
            streamShare.removeStreamAddedListener(listener);
        }
    }, [video, client]);

    let texture = useMemo(() => video ? &lt;videoTexture attach='map' args={[video]} colorSpace={THREE.SRGBColorSpace} /> : null, [video]);

    return &lt;>
        &lt;mesh geometry={frameGeometry} material={frameMaterial}
            scale={[0.25 + 0.02, (0.25 / aspectRatio) + 0.02, 1]} position={[0, (0.125 / aspectRatio) + 0.2, 0.0055]} autoUpdateMatrix={false} />
        &lt;Plane args={[0.25, 0.25 / aspectRatio]} position={[0, (0.125 / aspectRatio) + 0.2, 0]} rotation={[0, Math.PI, 0]}>
            &lt;meshBasicMaterial toneMapped={false} color={video ? 'white' : 'darkgrey'}>
                {texture}
            &lt;/meshBasicMaterial>
        &lt;/Plane>
    &lt;/>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Video Stream Menu" auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuSpacer, MenuButton } from '#Menu .default';



// Import in order to start the manager
import VideoStreamManager from '#VideoStreamManager .default';



addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'share-video', &lt;MenuButton onClick={window.shareMyVideo}>Share Video&lt;/MenuButton>, 300);
addItemToSubMenu('media-sharing', 'stop-video', &lt;MenuButton onClick={window.stopSharingMyVideo}>Stop Video&lt;/MenuButton>, 400);
addItemToSubMenu('media-sharing', 'spacer2', &lt;MenuSpacer />, 450);
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="AudioStream" name="AudioStream"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stream component for audio streams",
    "dependencies": [
        "#AudioStreamManager",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Audio Stream Concepts" auto>{
    "concepts": {
        "AudioStream": {
            "schema": {
                "client": "string",
                "muted": "boolean"
            }
        }
    }
}</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Audio Stream" class="default component dynamic-scene-component">import React from 'react';
const { useState, useEffect } = React;
import { Varv, useProperty } from '#VarvReact';

import { QUERY_PREFIX, streamShare } from '#AudioStreamManager .default';



function AudioStream() {
    const [client] = useProperty('client');
    const [muted] = useProperty('muted');

    const [audio, setAudio] = useState(document.querySelector(QUERY_PREFIX + client));

    useEffect(() => {
        // Make sure to catch stream updates
        let listener = function (newStreamId) {
            if (newStreamId == client) setAudio(document.querySelector(QUERY_PREFIX + client));
        };
        streamShare.addStreamAddedListener(listener);

        return () => {
            streamShare.removeStreamAddedListener(listener);
        };
    }, [audio, client]);

    useEffect(() => {
        if (audio && (client != webstrate.clientId)) {
            audio.muted = muted;
        }
    }, [muted, client]);
}

export function Main() {
    return &lt;Varv concept="AudioStream">
        &lt;AudioStream />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Audio Stream Menu" auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuSpacer, MenuButton } from '#Menu .default';
import { addItem, ControllerMenuButton } from '#ControllerMenu .default';



// Import in order to start the manager
import AudioStreamManager from '#AudioStreamManager .default';



addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'share-audio', &lt;MenuButton onClick={window.shareMyAudio}>Share Audio&lt;/MenuButton>, 500);
addItemToSubMenu('media-sharing', 'stop-audio', &lt;MenuButton onClick={window.stopSharingMyAudio}>Stop Audio&lt;/MenuButton>, 600);
addItemToSubMenu('media-sharing', 'spacer3', &lt;MenuSpacer />, 700);

addItem('share-audio', &lt;ControllerMenuButton position={[0.12, 0.06, 0]} name={'Start Audio'} callback={window.shareMyAudio} />);
addItem('stop-audio', &lt;ControllerMenuButton position={[0.12, 0, 0]} name={'Stop Audio'} callback={window.stopSharingMyAudio} />);
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER></CODE-FOLDER><CODE-FOLDER name="Movables" id><CODE-FOLDER name="Base"><WPM-PACKAGE name="Movable" id="Movable"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Basic movable component and mechanism with helpers",
    "dependencies": [
        "#Spatialstrates",
        "#Icon",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Movable Concepts" auto>{
    "concepts": {
        "Movable": {
            "schema": {
                "position": { "array": {
                    "items": "number",
                    "default": [ 0, 1.5, 0 ]
                }},
                "rotation": { "array": {
                    "items": "number",
                    "default": [ 0, 0, 0 ]
                }},
                "selected": "boolean",
                "hovered": "boolean",
                "beingDragged": "boolean",
                "private": "boolean",
                "author": "User"
            },
            "mappings": {
                "selected": [ "memory", "cauldron" ],
                "hovered": [ "memory", "cauldron" ],
                "beingDragged": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Movable Actions" id auto>const DEBUG = false;
const MAX_DISTANCE = 0.5;



let positionProperty = null;
VarvEngine.registerEventCallback('engineReloaded', (evt) => {
    positionProperty = null;
});

async function getMovablePosition(movable) {
    if (!positionProperty) {
        let movableType = VarvEngine.getConceptFromType('Movable');
        if (DEBUG) console.log('Getting is');
        positionProperty = movableType.getProperty('position');
    }

    const [x, y, z] = await positionProperty.getValue(movable, true);

    return [x, y, z];
};

class ClosestMovableAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }
    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            const movable = options.movable || context.target;
            const otherMovables = options.otherMovables;

            const movablePosition = await getMovablePosition(movable);
            let closest = '';
            let closestDistance = false;

            for (let i = 0; i &lt; otherMovables.length; i++) {
                const currentPosition = await getMovablePosition(otherMovables[i]);
                const a = movablePosition[0] - currentPosition[0];
                const b = movablePosition[1] - currentPosition[1];
                const c = movablePosition[2] - currentPosition[2];
                const currentDistance = Math.sqrt(a * a + b * b + c * c);
                if (!closestDistance || (closestDistance > currentDistance)) {
                    if (currentDistance &lt; MAX_DISTANCE) {
                        closest = otherMovables[i];
                    }
                    closestDistance = currentDistance;
                }
            }

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, closest);

            return context;
        });
    }
}
Action.registerPrimitiveAction('closestMovable', ClosestMovableAction);
window.ClosestMovableAction = ClosestMovableAction;



class MovablesInRangeAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }
    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            const movable = options.movable || context.target;
            const otherMovables = options.otherMovables;

            const maxDistance = options.maxDistance || MAX_DISTANCE;

            const movablePosition = await getMovablePosition(movable);
            let inRange = [];

            for (let i = 0; i &lt; otherMovables.length; i++) {
                const currentPosition = await getMovablePosition(otherMovables[i]);
                const a = movablePosition[0] - currentPosition[0];
                const b = movablePosition[1] - currentPosition[1];
                const c = movablePosition[2] - currentPosition[2];
                const currentDistance = Math.sqrt(a * a + b * b + c * c);
                if (currentDistance &lt; maxDistance) {
                    inRange.push(otherMovables[i]);
                }
            }

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, inRange);

            return context;
        });
    }
}
Action.registerPrimitiveAction('movablesInRange', MovablesInRangeAction);
window.MovablesInRangeAction = MovablesInRangeAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Movable" class="default component">import React from 'react';
const { useRef, useState, useEffect, useCallback } = React;
import * as THREE from 'three';
import { useXRInputSourceEvent } from '@react-three/xr';
import { useFrame } from '@react-three/fiber';
import { useProperty } from '#VarvReact';

import { useGlobalEvents } from '#Spatialstrates .global-events';
import { getDeviceFromInputEvent } from '#Spatialstrates .transform-helpers';
import { Icon } from '#Icon .default';
import { deselectMovables } from '#Movable .helpers';



const FAST_WRITEBACK_TIMEOUT = 33;
const SLOW_WRITEBACK_TIMEOUT = 500;

export const SELECTED_COLOR_PRIMARY = 'hsl(14, 100%, 50%)';
export const SELECTED_COLOR_SECONDARY = 'hsl(26, 100%, 60%)';
export const HOVERED_SELECTED_COLOR_PRIMARY = 'hsl(14, 100%, 65%)';
export const HOVERED_SELECTED_COLOR_SECONDARY = 'hsl(26, 100%, 75%)';



// Generic wrapper for Movable concept properties into ThreeJS transform properties
export function useTransform() {
    const [uuid] = useProperty('concept::uuid');

    const positionRef = useRef([0, 0, 0]);
    const rotationRef = useRef([0, 0, 0]);

    useEffect(() => {
        if (!uuid) return;
        const concept = VarvEngine.getConceptFromUUID(uuid);
        if (!concept) return;

        const updatePosition = async (changeUUID) => {
            if (changeUUID !== uuid) return;
            positionRef.current = await concept.getPropertyValue(uuid, 'position');
        };

        const updateRotation = async (changeUUID) => {
            if (changeUUID !== uuid) return;
            rotationRef.current = await concept.getPropertyValue(uuid, 'rotation');
        };

        updatePosition(uuid);
        updateRotation(uuid);

        concept.getProperty('position').addUpdatedCallback(updatePosition);
        concept.getProperty('rotation').addUpdatedCallback(updateRotation);

        return () => {
            if (!concept) return;
            try {
                concept.getProperty('position').removeUpdatedCallback(updatePosition);
                concept.getProperty('rotation').removeUpdatedCallback(updateRotation);
            } catch (e) {
                // Do nothing, this can crash when the VarvEngine restarts
            }
        };
    }, [uuid]);

    const setPosition = useCallback((pos) => {
        const concept = VarvEngine.getConceptFromUUID(uuid);
        if (!concept) return;
        concept.setPropertyValue(uuid, 'position', [pos.x, pos.y, pos.z], true);
    }, [uuid]);

    const setRotation = useCallback((rot) => {
        const concept = VarvEngine.getConceptFromUUID(uuid);
        if (!concept) return;
        concept.setPropertyValue(uuid, 'rotation', [rot.x, rot.y, rot.z], true);
    }, [uuid]);

    const transform = {
        get position() { return positionRef.current },
        set position(pos) { setPosition(pos) },
        get rotation() { return rotationRef.current },
        set rotation(rot) { setRotation(rot) },
    };

    return transform;
}

/**
 * Sugar wrapper for icons used inside movables that are
 * selectable and hoverable
 */
export function HandleIcon({ model, theme = '', themesOverride = '' }) {
    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');
    return &lt;Icon theme={theme + (selected ? ':selected' : '') + (hovered ? ':hovered' : '')} model={model} themesOverride={themesOverride} />
}

/**
 * Make a group of children moveable with a handle that allows
 * selecting them and dragging them around
 */
export function Movable({ children, handle, upright = true, onDragStart, onDragEnd, onDragging }) {
    const transform = useTransform();
    const [selected, setSelected] = useProperty('selected');
    const [hovered, setHovered] = useProperty('hovered');
    const [beingDragged, setBeingDragged] = useProperty('beingDragged');

    // Setup refs for dragging
    const grabbingController = useRef();
    const dragRef = useRef();

    // Setup dragging devices
    const [currentXRInputSource, setCurrentXRInputSource] = useState(null);
    const [uuid] = useProperty('concept::uuid');

    const { triggerEvent, subscribeEvent } = useGlobalEvents();

    // Handle input events for dragging and hovering
    const selectAndStartDrag = useCallback((e) => {
        if (e) e.stopPropagation();
        if (grabbingController.current) return;
        setSelected(true);
        setBeingDragged(true);
        setCurrentXRInputSource(e?.nativeEvent?.inputSource);

        deselectMovables();

        if (dragRef && dragRef.current) {
            triggerEvent('drag-start', { target: uuid });
            if (typeof onDragStart === 'function') onDragStart();
            grabbingController.current = getDeviceFromInputEvent(e);
            if (grabbingController.current) {
                previousTransform.copy(grabbingController.current.matrixWorld).invert();
            }
        }
    }, [setSelected, setBeingDragged]);

    const remoteInitiateDrag = useCallback((payload) => {
        if (payload.target === uuid) selectAndStartDrag(payload.e);
    }, [uuid]);

    useEffect(() => {
        const unsubscribe = subscribeEvent('initiate-drag', remoteInitiateDrag);
        return () => unsubscribe();
    }, [remoteInitiateDrag, subscribeEvent, uuid]);

    const stopDrag = useCallback((e) => {
        if (e) e.stopPropagation();
        setBeingDragged(false);
        setCurrentXRInputSource(null);

        if (grabbingController.current) {
            grabbingController.current = undefined;
            transform.position = dragRef.current.position;
            transform.rotation = dragRef.current.rotation;
            triggerEvent('drag-end', { target: uuid });
            if (typeof onDragEnd === 'function') onDragEnd();
        }
    }, [setBeingDragged, currentXRInputSource, setCurrentXRInputSource]);

    const startHover = useCallback((e) => {
        if (e) e.stopPropagation();
        setHovered(true);
    }, [setHovered]);

    const stopHover = useCallback(() => {
        setHovered(false);
    }, [setHovered]);

    // Always stop dragging when anything lets go
    useXRInputSourceEvent(currentXRInputSource, 'selectend', stopDrag, [stopDrag, currentXRInputSource]);
    useEffect(() => {
        document.body.addEventListener('pointerup', stopDrag);
        return () => {
            document.body.removeEventListener('pointerup', stopDrag);
        };
    }, [stopDrag]);

    // Update the transformation of the movable
    const previousTransform = React.useMemo(() => new THREE.Matrix4(), []);
    const fastWritebackTimeout = useRef();
    const slowWritebackTimeout = useRef();

    useFrame(() => {
        if (!beingDragged && dragRef.current) {
            dragRef.current.position.fromArray(transform.position);
            dragRef.current.rotation.fromArray(transform.rotation);
            dragRef.current.updateMatrix();
            return;
        }
        const controller = grabbingController.current;
        if (!controller) return;

        dragRef.current.applyMatrix4(previousTransform);
        dragRef.current.applyMatrix4(controller.matrixWorld);
        dragRef.current.rotation.reorder('YXZ');
        if (upright) {
            dragRef.current.rotation.x = 0;
            dragRef.current.rotation.z = 0;
        }
        dragRef.current.updateMatrix();
        previousTransform.copy(controller.matrixWorld).invert();

        // Update the Varv state
        if (!fastWritebackTimeout.current) {
            transform.position = dragRef.current.position;
            fastWritebackTimeout.current = setTimeout(() => {
                fastWritebackTimeout.current = null;
            }, FAST_WRITEBACK_TIMEOUT);
        }
        if (!slowWritebackTimeout.current) {
            transform.rotation = dragRef.current.rotation;
            if (typeof onDragging === 'function') onDragging();
            slowWritebackTimeout.current = setTimeout(() => {
                slowWritebackTimeout.current = null;
            }, SLOW_WRITEBACK_TIMEOUT);
        }
    });

    return &lt;group ref={dragRef}
        matrixAutoUpdate={false}
        matrixWorldAutoUpdate={true}>
        &lt;group
            onPointerDown={selectAndStartDrag}
            onPointerUp={stopDrag}
            onPointerOver={startHover}
            onPointerOut={stopHover}>
            {handle}
        &lt;/group>
        {children}
    &lt;/group>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Movable Helpers" class="module helpers">import { devicePositionWithOffset, deviceRotation } from '#Spatialstrates .transform-helpers';



const selectedFilter = FilterAction.constructFilter({
    property: 'selected',
    equals: true
});

const selectedAndNotDraggedFilter = FilterAction.constructFilter({
    and: [
        {
            property: 'selected',
            equals: true
        },
        {
            property: 'beingDragged',
            equals: false
        }
    ]
});



export const deselectMovables = async () => {
    const ids = await VarvEngine.getAllUUIDsFromType('Movable', true);
    for (const id of ids) {
        if (await selectedAndNotDraggedFilter.filter({ target: id })) {
            await VarvEngine.getConceptFromUUID(id).setPropertyValue(id, 'selected', false);
        }
    }
};

export const createMovable = async (conceptName, properties = {}) => {
    const [x, y, z] = devicePositionWithOffset(window.moduleDeviceManager.camera, 0.5);
    const [rx, ry, rz] = deviceRotation(window.moduleDeviceManager.camera);

    await deselectMovables();
    const concept = await VarvEngine.getConceptFromType(conceptName);
    return await concept.create(null, {
        selected: true,
        position: [x, y, z],
        rotation: [rx, ry, rz],
        ...properties
    });
};

export const deleteMovable = async (uuid) => {
    await VarvEngine.getConceptFromUUID(uuid).delete(uuid);
};

export const deleteSelectedMovable = async () => {
    const uuids = await VarvEngine.getAllUUIDsFromType('Movable', true);
    for (const uuid of uuids) {
        if (await selectedFilter.filter({ target: uuid })) {
            await deleteMovable(uuid);
        }
    }
};

export const cloneSelectedMovable = async () => {
    const ids = await VarvEngine.getAllUUIDsFromType('Movable', true);
    for (const id of ids) {
        if (await selectedFilter.filter({ target: id })) {
            // Clone and move it up by 20cm
            console.warn('Cloning not implemented yet');
            // TODO: Re-implement this feature
        }
    }
};
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Movable Menu" auto>import React from 'react';
import {
    addSubMenu,
    addItemToSubMenu,
    MenuTitle,
    MenuSpacer,
    MenuButton
} from '#Menu .default';
import {
    addItem,
    ControllerMenuButton
} from '#ControllerMenu .default';
import { Varv, useProperty } from '#VarvReact';
import { deselectMovables, deleteSelectedMovable, cloneSelectedMovable } from '#Movable .helpers';



// function MultiSelectButton() {
//     const [multiSelect, setMultiSelect] = useProperty('multiSelect');
//     return &lt;MenuButton onClick={() => setMultiSelect(!multiSelect)} toggled={multiSelect ? 'true' : null}>Toggle Multi-Select&lt;/MenuButton>;
// }

addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'clone', &lt;MenuButton onClick={cloneSelectedMovable}>Clone&lt;/MenuButton>, 500);
addItemToSubMenu('movables', 'delete', &lt;MenuButton className="red" onClick={deleteSelectedMovable}>Delete&lt;/MenuButton>, 500);
addItemToSubMenu('movables', 'spacer1', &lt;MenuSpacer />, 550);
// addItemToSubMenu('movables', 'multi-select', &lt;Varv concept="MovableManager">
//     &lt;MultiSelectButton />
// &lt;/Varv>, 600);
addItemToSubMenu('movables', 'deselect', &lt;MenuButton onClick={deselectMovables}>Deselect Objects&lt;/MenuButton>, 700);

// function MultiSelectControllerButton() {
//     const [multiSelect, setMultiSelect] = useProperty('multiSelect');
//     return &lt;ControllerMenuButton position={[-0.12, 0.06, 0]} name={'Toggle Multi-Select'} theme={multiSelect ? 'button:toggled' : null} callback={() => setMultiSelect(!multiSelect)} />;
// }

addItem('clone', &lt;ControllerMenuButton position={[-0.04, 0.06, 0]} name={'Clone'} callback={cloneSelectedMovable} />);
addItem('delete', &lt;ControllerMenuButton position={[-0.04, 0, 0]} name={'Delete'} theme="deleteButton" callback={deleteSelectedMovable} />);
// addItem('multi-select', &lt;Varv concept="MovableManager">
//     &lt;MultiSelectControllerButton />
// &lt;/Varv>);
addItem('deselect', &lt;ControllerMenuButton position={[-0.12, 0, 0]} name={'Deselect All'} callback={deselectMovables} />);
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Components"><WPM-PACKAGE id="StickyNote" name="StickyNote" class><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple sticky note component",
    "dependencies": [
        "#Movable",
        "#Icon",
        "#AIHelpers",
        "#Menu",
        "#ControllerMenu",
        "#Text"
    ],
    "assets": [
        "microphone.glb"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Sticky Note Concepts" auto>{
    "concepts": {
        "StickyNote": {
            "schema": {
                "text": "string"
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Sticky Note Component" class="default component dynamic-scene-component">import React from 'react';
const { useState, useMemo, useRef } = React;
import { MeshStandardMaterial } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useFrame } from '@react-three/fiber';
import { Varv, useProperty } from '#VarvReact';
import { useGLTF } from '@react-three/drei';

import { Movable, SELECTED_COLOR_PRIMARY, HOVERED_SELECTED_COLOR_PRIMARY } from '#Movable .default';
import { Icon } from '#Icon .default';
import { transcribeAudio } from '#AIHelpers .default';
import { Text } from '#Text .default';



const frameGeometry = new RoundedBoxGeometry(0.15, 0.15, 0.005, 1);
const frameMaterial = new MeshStandardMaterial({ color: '#FDD835', metalness: 0.2, roughness: 0.5 });
const frameMaterialHovered = new MeshStandardMaterial({ color: '#FFF176', metalness: 0.2, roughness: 0.5 });
const frameMaterialSelected = new MeshStandardMaterial({ color: SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });
const frameMaterialHoveredSelected = new MeshStandardMaterial({ color: HOVERED_SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });
useGLTF.preload('microphone.glb');



function StickyNote() {
    const iconRef = useRef();
    const microphoneIcon = useGLTF('microphone.glb');
    const [listening, setListening] = useState(false);
    const [text, setText] = useProperty('text');
    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');

    async function updateText() {
        if (listening) return;

        setListening(true);
        const newText = await transcribeAudio(5000, false, () => { setListening(false); });
        if (newText) setText(newText);
    }

    const handle = useMemo(() => &lt;mesh
        geometry={frameGeometry}
        material={selected ? (hovered ? frameMaterialHoveredSelected : frameMaterialSelected) : (hovered ? frameMaterialHovered : frameMaterial)}
        position={[0, 0.025, 0]}
        autoUpdateMatrix={false}
    />, [hovered, selected]);

    useFrame((state) => {
        if (!iconRef.current) return;
        const minScale = 0.4;
        const maxScale = 0.6;
        const targetScale = listening ? minScale + (maxScale - minScale) * (Math.sin(state.clock.elapsedTime * 5) * 0.5 + 0.5) : 0.5;
        iconRef.current.scale.setScalar(targetScale);
    });

    return &lt;Movable handle={handle} upright={false}>
        &lt;Text
            position={[0, 0.025, 0.003]} autoUpdateMatrix={false}
            maxWidth={0.13}
            textAlign='left'
            anchorX='center'
            anchorY='middle'
            color='black'
            fontSize={0.01}>
            {text}
        &lt;/Text>
        {selected ? &lt;group ref={iconRef} rotation={[0, -Math.PI, 0]} position={[0.1, 0.025, 0]}>
            &lt;Icon model={microphoneIcon} onClick={updateText} />
        &lt;/group> : null}
    &lt;/Movable>;
}



export function Main() {
    return &lt;Varv concept="StickyNote">
        &lt;StickyNote />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Sticky Note Menu" auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { addItem, ControllerMenuButton } from '#ControllerMenu .default';
import { createMovable } from '#Movable .helpers';



addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'add-sticky-note', &lt;MenuButton onClick={() => createMovable('StickyNote')}>New Sticky Note&lt;/MenuButton>, 200);
addItemToSubMenu('movables', 'spacer-items', &lt;MenuSpacer />, 400);

addItem('add-sticky-note', &lt;ControllerMenuButton position={[0.04, 0, 0]} name={'New Sticky Note'} callback={(e) => createMovable('StickyNote')} />);
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Image" name="Image"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple image component",
    "dependencies": [
        "#Movable",
        "#Menu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Image Concepts" auto>{
    "concepts": {
        "Image": {
            "schema": {
                "url": "string"
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="Image Component" class="default component dynamic-scene-component">import React from 'react';
const { useRef, useState, useEffect, useMemo } = React;
import { MeshStandardMaterial } from 'three';
import { Image } from '@react-three/drei';
import { ErrorBoundary } from 'react-error-boundary';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { Varv, useProperty } from '#VarvReact';

import { Movable, SELECTED_COLOR_PRIMARY, HOVERED_SELECTED_COLOR_PRIMARY } from '#Movable .default';



const MAX_SIZE = 0.4;

// Reuseable geometry for the image frame
const frameGeometry = new RoundedBoxGeometry(1, 1, 0.005, 1);
const frameMaterial = new MeshStandardMaterial({ color: '#E0E0E0', metalness: 0.2, roughness: 0.5 });
const frameMaterialHovered = new MeshStandardMaterial({ color: '#FFFFFF', metalness: 0.2, roughness: 0.5 });
const frameMaterialSelected = new MeshStandardMaterial({ color: SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });
const frameMaterialHoveredSelected = new MeshStandardMaterial({ color: HOVERED_SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });

function CustomImage() {
    const boundaryRef = useRef();
    const imageRef = useRef();
    const [width, setWidth] = useState(1);
    const [height, setHeight] = useState(1);
    const [url] = useProperty('url');

    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');

    // Update the aspect ratio
    useEffect(() => {
        if (boundaryRef.current) boundaryRef.current.resetErrorBoundary();
        if (imageRef.current) {
            const aspectRatio = imageRef.current.material.__r3f.memoizedProps.imageBounds[0] / imageRef.current.material.__r3f.memoizedProps.imageBounds[1] || 1;
            if (aspectRatio > 1) {
                setWidth(MAX_SIZE);
                setHeight(MAX_SIZE / aspectRatio);
            } else {
                setWidth(MAX_SIZE * aspectRatio);
                setHeight(MAX_SIZE);
            }
        }
    }, [url, imageRef]);

    const handle = useMemo(() => &lt;mesh
        geometry={frameGeometry}
        material={selected ? (hovered ? frameMaterialHoveredSelected : frameMaterialSelected) : (hovered ? frameMaterialHovered : frameMaterial)}
        scale={[width + 0.02, height + 0.02, 1]}
        position={[0, 0.125 - 0.025, -0.0029]}
        autoUpdateMatrix={false}>
    &lt;/mesh>, [width, height, selected, hovered]);

    return &lt;Movable handle={handle} upright={false}>
        &lt;ErrorBoundary ref={boundaryRef} fallback={null}>
            {url ? &lt;Image ref={imageRef} url={url} position={[0, 0.125 - 0.025, 0]} scale={[width, height, 1]} autoUpdateMatrix={false}>
                &lt;planeGeometry args={[1, 1]} />
            &lt;/Image> : null}
        &lt;/ErrorBoundary>
    &lt;/Movable>;
}

export function Main() {
    return &lt;Varv concept="Image">
        &lt;CustomImage />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Image Uploader" id class auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuTitle } from '#Menu .default';
import { devicePositionWithOffset, deviceRotation } from '#Spatialstrates .transform-helpers';



if (!window.moduleImageUploader) {
    window.moduleImageUploader = {
        active: true
    };

    // Setup menu item
    addSubMenu('file-upload', 500, false);
    addItemToSubMenu('file-upload', 'title', &lt;MenuTitle title="Upload Files" />, 0);
    addItemToSubMenu('file-upload', 'upload-image', &lt;div className="upload-drop-zone" id="image-upload-drop-zone">Upload Image&lt;/div>, 1000);

    // Setup drop zone for image uploads
    const handleUploadImage = (file) => {
        const formData = new FormData();
        formData.append('file', file, file.name);

        const request = new XMLHttpRequest();
        request.open('POST', window.location.pathname);
        request.send(formData);

        return new Promise((resolve, reject) => {
            request.addEventListener('load', async (e) => {
                const asset = JSON.parse(request.responseText);
                const [x, y, z] = devicePositionWithOffset(window.moduleDeviceManager.camera, 0.5);
                const [rx, ry, rz] = deviceRotation(window.moduleDeviceManager.camera);

                const imageConcept = await VarvEngine.getConceptFromType('Image');
                imageConcept.create(null, {
                    url: asset.fileName,
                    position: [x, y, z],
                    rotation: [rx, ry, rz]
                });
                resolve(asset);
            });
            request.addEventListener('error', (e) => {
                reject(new Error('Failed to upload image'));
            });
        });
    };

    const handleUploadFile = (file) => {
        if (file.type === 'image/jpeg' || file.type === 'image/png') {
            handleUploadImage(file);
        } else {
            alert('File type not supported.');
        }
    };

    const activateDropZone = (element, type) => {
        element.addEventListener('dragover', (e) => {
            e.preventDefault();
            element.classList.add('upload-drop-zone--over');
        });

        element.addEventListener('dragleave', () => {
            element.classList.remove('upload-drop-zone--over');
        });

        element.addEventListener('drop', (e) => {
            e.preventDefault();
            element.classList.remove('upload-drop-zone--over');
            const files = e.dataTransfer.files;
            for (let i = 0; i &lt; files.length; i++) {
                const file = files[i];
                handleUploadFile(file, type);
            }
        });

        element.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = 'multiple';
            input.accept = type === 'image' ? 'image/jpeg, image/png' : '';
            input.onchange = (e) => {
                for (let i = 0; i &lt; e.target.files.length; i++) {
                    handleUploadFile(e.target.files[i], type);
                }
            };
            input.click();
        });
    };

    cQuery(document.body).liveQuery('.upload-drop-zone', {
        'added': (element) => {
            if (element.id === 'image-upload-drop-zone') {
                activateDropZone(element, 'image');
            }
        }
    });
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Trashcan" name="Trashcan"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A trashcan component that can be used to delete movables",
    "dependencies": [
        "#Movable",
        "#Icon",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [
        "trash.glb"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Trashcan Concepts" auto>{
    "concepts": {
        "Trashcan": {
            "schema": {
                "placeholder": "string"
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Trashcan Component" class="default component dynamic-scene-component">import React from 'react';
const { useEffect, useCallback } = React;
import * as THREE from 'three';
import { Varv, useProperty } from '#VarvReact';
import { useGLTF } from '@react-three/drei';

import { useGlobalEvents } from '#Spatialstrates .global-events';
import { Movable, HandleIcon } from '#Movable .default';
import {
    SELECTED_COLOR_PRIMARY,
    SELECTED_COLOR_SECONDARY,
    HOVERED_SELECTED_COLOR_PRIMARY,
    HOVERED_SELECTED_COLOR_SECONDARY
} from '#Icon .default';
import { deleteMovable } from '#Movable .helpers';



const MAX_DISTANCE = 0.2;

const themes = {
    'trash': { primary: 'hsl(0, 0%, 20%)', secondary: 'hsl(0, 0%, 60%)' },
    'trash:hovered': { primary: 'hsl(0, 0%, 50%)', secondary: 'hsl(0, 0%, 70%)' },
    'trash:selected': { primary: SELECTED_COLOR_PRIMARY, secondary: SELECTED_COLOR_SECONDARY },
    'trash:selected:hovered': { primary: HOVERED_SELECTED_COLOR_PRIMARY, secondary: HOVERED_SELECTED_COLOR_SECONDARY },
};
useGLTF.preload('trash.glb');

function Trashcan() {
    const trashcanIcon = useGLTF('trash.glb');
    const handle = &lt;HandleIcon theme="trash" model={trashcanIcon} themesOverride={themes} />
    const [position] = useProperty('position');
    const [uuid] = useProperty('concept::uuid');

    const { subscribeEvent } = useGlobalEvents();

    const onDragEnd = useCallback(async (data) => {
        if (data.target === uuid) return;

        const movablePositionArray = await VarvEngine.getConceptFromUUID(data.target).getPropertyValue(data.target, 'position');

        const trashcanPosition = new THREE.Vector3(...position);
        const movablePosition = new THREE.Vector3(...movablePositionArray);

        if (trashcanPosition.distanceTo(movablePosition) &lt; MAX_DISTANCE) {
            await deleteMovable(data.target);
        }
    }, [position]);

    useEffect(() => {
        const unsubscribe = subscribeEvent('drag-end', onDragEnd);
        return () => unsubscribe();
    }, [subscribeEvent, position]);

    return &lt;Movable handle={handle} />;
}



export function Main() {
    return &lt;Varv concept="Trashcan">
        &lt;Trashcan />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Trashcan Menu" auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { addItem, ControllerMenuButton } from '#ControllerMenu .default';
import { createMovable } from '#Movable .helpers';



addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'add-trashcan', &lt;MenuButton onClick={() => createMovable('Trashcan')}>New Trashcan&lt;/MenuButton>, 100);
addItemToSubMenu('movables', 'spacer-items', &lt;MenuSpacer />, 400);

addItem('add-trashcan', &lt;ControllerMenuButton position={[0.04, 0.06, 0]} name={'New Trashcan'} callback={(e) => createMovable('Trashcan')} />);
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Add-ons"><WPM-PACKAGE id="Screenshots" name="Screenshots"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A screenshot function that creates images in Spatialstrates",
    "dependencies": [
        "#Image",
        "#Menu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Screenshots" id class="default module" auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { devicePositionWithOffset, deviceRotation } from '#Spatialstrates .transform-helpers';



const createFileName = () => {
    const date = new Date();
    return `screenshot_${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}_${date.getHours()}-${date.getMinutes()}-${date.getSeconds()}`;
};

const dataURLToBlob = (dataURL) => {
    const byteString = atob(dataURL.split(',')[1]);
    const mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i &lt; byteString.length; i += 1) {
        ia[i] = byteString.charCodeAt(i);
    }
    return new Blob([ab], { type: mimeString });
};

const uploadAsset = async (dataURL, fileName) => {
    const formData = new FormData();
    const blob = dataURLToBlob(dataURL);
    formData.append('file', blob, fileName);

    const request = new XMLHttpRequest();
    request.open('POST', window.location.pathname);
    request.send(formData);

    return new Promise((resolve, reject) => {
        request.addEventListener('load', (e) => {
            const asset = JSON.parse(request.responseText);
            resolve(asset);
        });
        request.addEventListener('error', (e) => {
            reject(new Error('Failed to upload screenshot'));
        });
    });
};

const captureScreenshot = async () => {
    const canvas = document.querySelector('body transient canvas[data-engine]');
    if (!canvas) {
        console.warn('Screenshot failed: No canvas found');
        return;
    }

    const dataURL = canvas.toDataURL('image/png');
    const asset = await uploadAsset(dataURL, createFileName() + '.png');

    const [x, y, z] = devicePositionWithOffset(window.moduleDeviceManager.camera, 0.5);
    const [rx, ry, rz] = deviceRotation(window.moduleDeviceManager.camera);

    const imageConcept = await VarvEngine.getConceptFromType('Image');
    imageConcept.create(null, {
        url: asset.fileName,
        position: [x, y, z],
        rotation: [rx, ry, rz]
    });
};


addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'spacer2', &lt;MenuSpacer />, 750);
addItemToSubMenu('movables', 'screenshot', &lt;MenuButton onClick={captureScreenshot}>Capture Screenshot&lt;/MenuButton>, 800);
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER></CODE-FOLDER></body></html>
