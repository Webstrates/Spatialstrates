<!doctype html>
<html data-protected="all"><head><script id="WPMv2-script" type="text/javascript">/**
 * WPMv2 - Webstrate Package Manager
 *
 * Copyright 2019 Rolf Bagge, Janus Bager Kristensen,
 * CAVI - Center for Advanced Visualisation and Interaction,
 * Aarhus University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

/* global Promise, webstrate, eval */

//Encapsulate WPMv2, so we can decide which methods are public
((window) => {

    const WPM_ALIASES = "WPM.repoAliases";

    let runningRequiresPromiseMap = [];

    let allInstalledCallbacksStack = [];

    const requireQueue = [];

    /**
     * WebstratePackageManager version 2
     *
     * It is used to install WPM packages into webstrates.
     *
     * <pre><code>WPMv2.require([
     *      {package: "somePackageName", repository: "/somewebstraterepo"},
     *      {package: "someOtherPackageName", repository: "/somewebstraterepo"}
     * ]).then(()=>{
     *     //Packages are now installed
     * });
     * </code></pre>
     * @hideconstructor
     */
    class WPMv2 {
        static async bootstrap(packageDom, options, requireToken, triggerOnPackageInstalled = false) {
            let wpmPackage = WPMv2.getWPMPackageFromDOM(packageDom);
            let promises = [];

            /**
             * @class WPMInterface
             * @classdesc
             * Internal WPM interface that is provided for every package that is installed via WPMv2. Is accessed as just wpm, when inside package code.
             * @hideconstructor
             * @memberof WPMv2
             */
            let wpmInterface = {};

            /**
             * Reads metadata from the given package. If no packagename is given, metadata from the current package is read.
             *
             * @example
             * let metadata = wpm.readMetadata();
             *
             * @param {string} [packageName] - The package to read metadata from
             * @returns {json}
             * @memberof WPMv2.WPMInterface
             * @name readMetadata
             * @method
             */
            wpmInterface.readMetadata = (packageName = null) => {
                if (packageName == null) {
                    packageName = packageDom.getAttribute("id");
                }

                return WPMv2.readMetadata(packageName);
            };

            /**
             * Registers a callback to be called when this package is installed.
             *
             * @example
             * wpm.onInstalled(()=>{
             *     //Package is now installed
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onInstalled
             * @method
             */
            wpmInterface.onInstalled = (callback) => {
                packageDom.addEventListener("wpm.packageInstalled", callback, {"once": true});
            };

            /**
             * Registers a callback to be called when all packages are installed. (When installing multiple packages at the same time.)
             *
             * @example
             * wpm.onAllInstalled(()=>{
             *     //All packages are installed
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onAllInstalled
             * @method
             */
            wpmInterface.onAllInstalled = (callback) => {
                //Retrieve from stack
                let allInstalledCallbacks = allInstalledCallbacksStack[allInstalledCallbacksStack.length-1];
                if (allInstalledCallbacks){
                    allInstalledCallbacks.push(callback);
                } else {
                    // STUB: Remove FIXME if ok
                    console.log("FIXME: WPMv2 - No allInstalledCallbacks in allInstalledCallbacksStack, assuming no more packages? Is this ok?");
                    // Immediately call the callback since no more packages are left
                    callback();
                }

            };

            /**
             * Registers a callback to be called when this package is removed.
             *
             * @example
             * wpm.onRemoved(({detail: packageName})=>{
             *     //Package is removed, packageName is provided for ease of access, will be same as the package this callback was registered from.
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onRemoved
             * @method
             */
            wpmInterface.onRemoved = (callback) => {
                packageDom.addEventListener("wpm.packageRemoved", callback, {"once": true});
            };

            /**
             * Registers a callback to be called when any package is removed.
             *
             * @example
             * wpm.onRemovedAny(({detail: packageName})=>{
             *      //Package with name "packageName" has been removed
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onRemovedAny
             * @method
             */
            wpmInterface.onRemovedAny = (callback) => {
                document.addEventListener("wpm.packageRemovedAny", callback);
            };

            wpmInterface.require = async (packageRequests, extraOptions) => {
                let convertedPackages = [];

                if (packageRequests != null) {
                    if (!Array.isArray(packageRequests)) {
                        packageRequests = [packageRequests];
                    }

                    for (let packageRequest of packageRequests) {
                        if (typeof packageRequest === "string") {
                            //Shorthand for requiring dependency, lookup in our descriptor
                            let packageName = packageRequest;
                            let repo = wpmPackage.optionalDependencyMap.get(packageName);

                            convertedPackages.push({
                                package: packageName,
                                repository: repo
                            });
                        } else {
                            convertedPackages.push(packageRequest);
                        }
                    }
                } else {
                    //packages == null, means require all dependencies!
                    wpmPackage.optionalDependencyMap.forEach((repo, packageName) => {
                        convertedPackages.push({
                            package: packageName,
                            repository: repo
                        });
                    });
                }

                const combinedOptions = Object.assign({}, options, extraOptions);

                promises.push(WPMv2.require(convertedPackages, combinedOptions, requireToken));

                return Promise.all(promises);
            };

            async function loadExternalCSS(response) {
                let styleContent = await response.text();

                //Attempt linking stylesheets instead of inlining them
                let style = document.createElement("style");

                let transient = document.createElement("transient");
                transient.appendChild(style);

                //Disable sourcemap

                styleContent = styleContent.replace(/\/\*#\s*sourceMappingURL=\S+\s*\*\//, "");
                //styleContent = styleContent.replace(/\/\/#\s*sourceMappingURL=\S+/, "");

                style.innerHTML = styleContent;

                document.head.append(transient);
            }

            async function loadExternalJS(response) {
                let scriptContent = await response.text();

                //Hack to make requirejs work, and be able to hide it
                const origDefine = window.define;
                if (window.define != null) {
                    window.define = undefined;
                }

                //Disable sourcemap
                //scriptContent = scriptContent.replace(/\/\*#\s*sourceMappingURL=\S+\s*\*\//, "");
                scriptContent = scriptContent.replace(/\/\/# sourceMappingURL=\S+/, "");

                eval.call(null, scriptContent);

                //Restore previous define, if this script did not set define
                if (window.define == null && origDefine != null) {
                    window.define = origDefine;
                }
            }

            /**
             * Fetches and evaluates external javascript, or loads css.
             *
             * The server response header Content-Type will be used to determine if its a JS or CSS.
             *
             * @example
             * await wpm.requireExternal("https://some.site.com/someScript.js");
             * //someScript.js has now been parsed and evaluated
             *
             * @param {string|string[]} urls - The URLs to the wanted JS, CSS
             * @returns {Promise<void>} - Resolves when all scripts/styles are fetched and evaluated/loaded
             * @memberof WPMv2.WPMInterface
             * @name requireExternal
             * @method
             */
            wpmInterface.requireExternal = async (urls) => {
                if(!(urls instanceof Array)) {
                    urls = [urls];
                }

                for(let url of urls) {

                    let promise = new Promise(async (resolve, reject)=>{
                        try {
                            let response = await fetch(url, {credentials: 'same-origin'});

                            let contentType = response.headers.get("Content-Type").trim();
                            let indexOfSemicolon = contentType.indexOf(";");
                            if (indexOfSemicolon !== -1) {
                                contentType = contentType.substring(0, indexOfSemicolon).trim();
                            }

                            switch (contentType) {
                                case "text/css": {
                                    await loadExternalCSS(response);
                                    break;
                                }
                                case "text/javascript":
                                case "application/javascript":
                                case "application/x-javascript": {
                                    await loadExternalJS(response);
                                    break;
                                }
                                default:
                                    console.warn("Unhandled contentType:", contentType, url);
                                    console.warn("Loading unknown as JS for know. please report...")
                                    await loadExternalJS(response);
                            }
                            resolve();
                        } catch(e) {
                            reject("Unable to fetch: "+url);
                        }
                    });

                    //promises.push(promise);

                    await promise;
                }
            };

            let scripts = packageDom.querySelectorAll("script[type='disabled']");

            for (let i = 0; i < scripts.length; i++) {
                let script = scripts[i];

                let scriptContent = "";

                if (script.src != null && script.src.length > 0) {
                    let response = await fetch(script.src, {credentials: 'same-origin'});
                    scriptContent = await response.text();
                } else {
                    scriptContent = script.innerText;
                }

                scriptContent = 'try{'+scriptContent+'} catch (ex){console.error("Bootstrap runtime error in '+packageDom.getAttribute("id").replaceAll("'","")+':", ex);}';

                const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;

                try {
                    let functionArgs = [];
                    functionArgs.push("wpm");

                    let functionArgValues = [];
                    functionArgValues.push(wpmInterface);

                    if(options.context != null) {
                        const contextKeys = Object.keys(options.context);
                        functionArgs.push(...contextKeys);

                        const contextValues = Object.values(options.context);
                        functionArgValues.push(...contextValues);
                    }

                    let wpmEval = new AsyncFunction(...functionArgs, scriptContent);
                    await wpmEval(...functionArgValues);
                } catch (e) {
                    console.error("Bootstrap parse error in " + packageDom.getAttribute("id"), e);
                }
            }

            await Promise.all(promises);

            if (triggerOnPackageInstalled) {
                packageDom.dispatchEvent(new CustomEvent("wpm.packageInstalled"));
            }
        }

        /**
         * Installs all packages at the given repository into the current page
         *
         * @example
         * WPMv2.requireAll("https://some.site.com/myRepo");
         *
         * @param {string} repository - The repository to lookup packages from
         * @param {WPMv2~PackageOptions} options - options to use for overriding packages options, also applies for dependencies
         * @returns {Promise<void>} - Resolved when packages are installed
         */
        static async requireAll(repository, options = {}) {
            let packages = [];

            let wpmPackages = await WPMv2.getPackagesFromRepository(repository);

            wpmPackages.forEach((pkg) => {
                if(options.blacklist != null && options.blacklist instanceof Array && options.blacklist.includes(pkg.name)) {
                    //Skip this package
                    return;
                }

                let pkgOptions = {
                    repository: pkg.repository,
                    package: pkg.name
                };
                packages.push(pkgOptions);
            });

            return WPMv2.require(packages, options);
        }

        /**
         * @typedef {Object} WPMv2~PackageOptions
         * @property {string} [repository] - The repository to lookup the package inside. If left unset, the current page is used.
         * @property {HTMLElement|string} [appendTarget] - The dom node to append to. If a string, will be looked up by document.querySelector(appendTarget). Defaults to a transient div inside document.head
         * @property {('append'|'before'|'after'|'prepend')} [appendMethod] - How to append to the appendTarget. Defaults to 'append'.
         */

        /**
         * @typedef {Object} WPMv2~PackageJson
         * @property {string} package - The name of the package
         * @property {string} [repository] - The repository to lookup the package inside. If left unset, the current page is used.
         * @property {HTMLElement|string} [appendTarget] - The dom node to append to. If a string, will be looked up by document.querySelector(appendTarget). Defaults to a transient div inside document.head
         * @property {('append'|'before'|'after'|'prepend')} [appendMethod] - How to append to the appendTarget. Defaults to 'append'.
         */

        /**
         *
         * @param {WPMv2.WPMPackage[]}packages
         * @returns {Promise<void>}
         */
        static async findCompletePackageTreeSorted(packages = [], defaultOptions, overrideOptions = {}) {
            const numPackages = packages.length;

            if (!Array.isArray(packages)) {
                packages = [packages];
            }

            let alreadySorting = [];
            let convertedPackages = [];

            async function addRepo(repoUrl, options) {
                if(overrideOptions.repository != null) {
                    console.warn("Adding a full repository, does not atm support overriding options for repository...");
                }

                try {
                    let packages = await WPMv2.getPackagesFromRepository(repoUrl);
                    for(let pkg of packages) {
                        if(options != null) {
                            pkg.updateFromOptions(options);
                        }
                        await addPackage(pkg);
                    }
                } catch (ex){
                    console.error("WPMv2 very important error: Could not resolve repository. This will probably cause the site to fail horribly! ", repoUrl, ex);
                }
            }

            async function addPackage(wpmPackage) {
                //Check if package is in local dom
                let localPackageDom = document.querySelector(".packages .package#" + wpmPackage.name + ", wpm-package#" + wpmPackage.name);
                let repoOverride = wpmPackage.repository;
                if(localPackageDom != null) {
                    //Local package exists, override repository with local ? This breaks dependencies that are "same repository", since they now lookup on the local repository.
                    //Not setting local repository, makes the update from dom, happen on the non embedded version, which is also wrong?
                    //wpmPackage.repository = WPMv2.getLocalRepositoryURL();
                    repoOverride = WPMv2.getLocalRepositoryURL();
                }

                let name = WPMv2.getName(wpmPackage);
                if(!alreadySorting.includes(name)){
                    alreadySorting.push(name);
                    try {
                        wpmPackage = await WPMv2.getLatestPackageFromPackage(wpmPackage, repoOverride);
                        let dependencies = await WPMv2.findAllDependencies(wpmPackage, Object.assign({}, overrideOptions));

                        for(let dependency of dependencies) {
                            await addPackage(dependency);
                        }
                        convertedPackages.push(wpmPackage);
                    } catch (ex){
                        console.error("WPMv2 very important error: Could not resolve package. This will probably cause the site to fail horribly! ", wpmPackage, ex);
                    }
                }
            }

            // Resolve all the packages
            await Promise.all(packages.map(async (pkg)=>{
                let wpmPackage = null;
                if (pkg instanceof WPMPackage) {
                    //Already a WPMPackage
                    wpmPackage = pkg;
                    wpmPackage.updateFromOptions(overrideOptions);
                } else if(typeof pkg === "string") {
                    if(pkg.startsWith("http") || (pkg.startsWith("/") && pkg.indexOf(" ") === 0)) {
                        //Full repository, http(s)://myrepourl or /my-relative-url
                        await addRepo(pkg);
                        return;
                    } else {
                        //Single package, name or including repository
                        let split = pkg.split(" ");

                        if(split.length === 1) {
                            //Single local package
                            let options = Object.assign({}, defaultOptions, {
                                "package": split[0]
                            }, overrideOptions);
                            wpmPackage = new WPMPackage(options.package, options.repository);
                            wpmPackage.updateFromOptions(options);
                        } else if(split.length === 2) {
                            //Single package from given repository
                            let options = Object.assign({}, defaultOptions, {
                                "package": split[1].replace("#", ""),
                                "repository": split[0]
                            }, overrideOptions);
                            wpmPackage = new WPMPackage(options.package, options.repository);
                            wpmPackage.updateFromOptions(options);
                        } else {
                            console.warn("Unable to parse package from string:", pkg);
                        }
                    }
                } else {
                    if(pkg.repository != null && pkg.package != null) {
                        //Full package, add
                        let options = Object.assign({}, defaultOptions, pkg, overrideOptions);
                        wpmPackage = new WPMPackage(options.package, options.repository);
                        wpmPackage.updateFromOptions(options);
                    } else if(pkg.repository != null) {
                        //Full repo, add all
                        await addRepo(pkg.repository, pkg);
                        return;
                    }
                }

                if(wpmPackage != null) {
                    await addPackage(wpmPackage);
                } else {
                    console.log("Was null:", pkg);
                }
            }));

            const sortedPackages = [];
            let lastLength = convertedPackages.length;
            while(convertedPackages.length > 0) {
                let packagesWithDependenciesInstalled = convertedPackages.filter((pkg)=>{
                    let ready = true;

                    for(let dep of pkg.dependencyMap) {
                        //If any dependency is not sorted to be installed yet, this is not ready
                        if(!WPMv2.hasPackage(sortedPackages, {"package": dep[0]})) {
                            ready = false;
                            break;
                        }
                    }
                    for(let dep of pkg.optionalDependencyMap) {
                        //If not already sorted to be installed, and among packages to install, this is not ready yet
                        if(!WPMv2.hasPackage(sortedPackages, {"package": dep[0]}) && WPMv2.hasPackage(convertedPackages, {"package": dep[0]})) {
                            ready = false;
                            break;
                        }
                    }

                    return ready;
                });

                packagesWithDependenciesInstalled.forEach((pkg)=>{
                    sortedPackages.push(pkg);
                    convertedPackages.splice(convertedPackages.indexOf(pkg), 1);
                });

                if(convertedPackages.length === lastLength) {
                    console.warn("Not able to add any more packages:", convertedPackages);
                    break;
                }
                lastLength = convertedPackages.length;
            }

            return sortedPackages;
        }

        /**
         * Finds all dependencies of a package
         * @param pkg
         * @returns {Promise<WPMv2.WPMPackage[]>}
         * @private
         */
        static async findAllDependencies(pkg, overrideOptions = {}) {
            let dependencies = [];

            for(let dependencyEntry of pkg.dependencyMap) {
                let dependency = new WPMPackage(dependencyEntry[0], dependencyEntry[1]);
                dependency.updateFromOptions(overrideOptions);
                dependencies.push(dependency);
            }

            return dependencies;
        }

        /**
         * Checks if the given array, contains the given package
         * @private
         */
        static hasPackage(packages, searchPackage) {
            return packages.find((pkg)=>{
                let pkgName = WPMv2.getName(pkg);
                let searchPackageName = WPMv2.getName(searchPackage);

                if(pkgName == null || searchPackageName == null) {
                    console.warn("Unable to compare as one was null");
                    return false;
                }

                return pkgName === searchPackageName;
            }) != null;
        }

        static getName(searchPackage){
            if(searchPackage instanceof WPMPackage) {
                return searchPackage.name;
            } else if(searchPackage.package != null) {
                return searchPackage.package;
            } else {
                console.warn("Unable to infer package name from:", searchPackage);
                return null;
            }
        }

        /**
         * Installs the given packages into the current document
         *
         * Override options set in overrideOptions, override the options given in packages.
         *
         * @example
         * WPMv2.require([{package: "myPackage", repository: "myRepositoryUrl"}]);
         *
         * @param {WPMv2.WPMPackage[]|WPMv2.WPMPackage|WPMv2~PackageJson[]|WPMv2~PackageJson} packages - the packages to install
         * @param {WPMv2~PackageOptions} overrideOptions - options to use for overriding packages options, also applies for dependencies
         * @returns {Promise<void>} - Resolves when the packages are done installing
         */
        static async require(packages = [], overrideOptions = {}, givenRequireToken = null) {
            const defaultOptions = {
                repository: WPMv2.getLocalRepositoryURL(),
                appendMethod: "append",
                appendTarget: null,
                bootstrap: true
            };

            //Make sure we dont override package
            if(overrideOptions.hasOwnProperty("package")) {
                console.warn("Overriding package...", overrideOptions);
                delete overrideOptions.package;
            }

            const completePackageTreeSorted = await WPMv2.findCompletePackageTreeSorted(packages, defaultOptions, overrideOptions);

            if (packages.length === 0) {
                return;
            }

            let requireToken = givenRequireToken;

            let timerId = [...Array(10)].map(_ => (Math.random() * 36 | 0).toString(36)).join``;
            let requireTimerId = "Require time [" +timerId +"]";

            if (givenRequireToken == null) {
                allInstalledCallbacksStack.push([]);
                requireToken = {};
                console.time(requireTimerId);
            }

            // Schedule all the package promises in parallel, but keep track of package inter-dependencies too
            let packagePromiseMap = new Map();

            //Save the currently running require
            runningRequiresPromiseMap.push(packagePromiseMap);

            for (let pkg of completePackageTreeSorted) {
                // At this point, since the tree is sorted, a dependency is either hard and supposed to be in the tree or soft and maybe in the tree (if not, then not installed)
                // If the depedency is hard and not in the tree then a missing package error has already happened and we are going by best-effort anyways, so ignore this case.

                //Check for another require already promising to install this package
                let foundPromise = null;
                for(let promiseMap of runningRequiresPromiseMap) {
                    if(promiseMap.has(pkg.name)) {
                        //Use other require promise, to tell us when package is installed
                        foundPromise = promiseMap.get(pkg.name);
                        break;
                    }
                }

                if(foundPromise != null) {
                    packagePromiseMap.set(pkg.name, foundPromise);
                } else {

                    packagePromiseMap.set(pkg.name, async function multithreadedFetchPackage() {
                        // Lookup all hard and optional dependencies and wait for them before starting ours
                        await Promise.all([...pkg.dependencyMap.keys(), ...pkg.optionalDependencyMap.keys()].map((dependency) => {
                            return packagePromiseMap.get(dependency);
                        }));

                        // Install this package
                        let options = Object.assign({}, defaultOptions, pkg.getPackageOptions(), overrideOptions);

                        //Check if package is in dom
                        let packageDom = document.querySelector(".packages .package#" + pkg.name + ", wpm-package#" + pkg.name);

                        let alreadyInstalled = false;

                        let wpmPackage = null;

                        let needsAppending = false;

                        if (packageDom == null) {
                            //We need to fetch and install package to dom
                            let fetchedPackageDom = await WPMv2.getPackageDOM(pkg.repository, pkg.name);

                            //Rewrite packageDom to a wpm-package
                            packageDom = document.createElement("wpm-package");

                            for (let index = fetchedPackageDom.attributes.length - 1; index > -1; --index) {
                                let attribute = fetchedPackageDom.attributes[index];
                                packageDom.setAttribute(attribute.name, attribute.value);
                            }

                            // Instead of display:none, hide it otherwise due to Chrome bug for SVGs
                            packageDom.style.width = 0;
                            packageDom.style.height = 0;
                            packageDom.style.position = "absolute";
                            packageDom.style.visibility = "hidden";

                            Array.from(fetchedPackageDom.children).forEach((child) => {
                                packageDom.appendChild(child);
                            });

                            WPMv2.stripProtection(packageDom);

                            wpmPackage = WPMv2.getWPMPackageFromDOM(packageDom);

                            needsAppending = true;
                        } else {
                            wpmPackage = WPMv2.getWPMPackageFromDOM(packageDom);
                            alreadyInstalled = true;
                        }

                        //Install into page
                        if (needsAppending) {
                            let appendTarget = options.appendTarget;

                            if (typeof appendTarget === "string") {
                                appendTarget = document.querySelector(appendTarget);
                            }

                            if (appendTarget == null) {
                                appendTarget = document.createElement("div");
                                appendTarget.setAttribute("transient-element", "");
                                appendTarget.setAttribute("transient-wpmid", packageDom.id);
                                document.head.appendChild(appendTarget);
                            }

                            switch (options.appendMethod.toLowerCase()) {
                                case "before":
                                    appendTarget.parentNode.insertBefore(packageDom, appendTarget);
                                    break;

                                case "after":
                                    appendTarget.parentNode.insertBefore(packageDom, appendTarget.nextSibling);
                                    break;
                                case "prepend":
                                    appendTarget.prepend(packageDom);
                                    break;

                                case "append":
                                default:
                                    appendTarget.append(packageDom);
                            }

                            // POST all assets to the target
                            if (wpmPackage.assets.length > 0) {
                                let repoAssetsUrl = WPMv2.lookupRepoAlias(wpmPackage.repository);
                                let repoAssets = await WPMv2.fetchAssets(repoAssetsUrl);

                                let localAssetsUrl = location.pathname + "?assets&latest";
                                let localAssets = await WPMv2.fetchAssets(localAssetsUrl);

                                let formData = new FormData();
                                let assetPromises = [];
                                wpmPackage.assets.forEach(function (asset) {
                                    //If we already have same filehash of this asset, skip
                                    let localAsset = localAssets.get(asset);
                                    let repoAsset = repoAssets.get(asset);

                                    if (localAsset != null && repoAsset != null && localAsset.fileHash === repoAsset.fileHash) {
                                        return;
                                    }

                                    assetPromises.push(new Promise(async function (resolve, reject) {
                                        let blob = await WPMv2.fetchAsset(repoAssetsUrl, asset);

                                        // Fetch it and append to POST
                                        formData.append("file", blob, asset);
                                        resolve();
                                    }));
                                });

                                if (assetPromises.length > 0) {
                                    await Promise.all(assetPromises);

                                    await fetch(location.pathname, {
                                        body: formData,
                                        credentials: 'same-origin',
                                        method: "post"
                                    });
                                }
                            }
                        }

                        //Check if package is live
                        if (packageDom.getAttribute("transient-wpm-live") == null) {
                            if(pkg.bootstrap) {
                                //Make package live
                                await WPMv2.bootstrap(packageDom, overrideOptions, requireToken, !alreadyInstalled);

                                packageDom.setAttribute("transient-wpm-live", "");
                            } else {
                                //Ignore
                            }
                        } else {
                            //Already live
                        }
                    }());
                }
            }

            // Wait for all packages to finish installation
            await Promise.all(Array.from(packagePromiseMap.values()));

            //Splice the finished require away
            runningRequiresPromiseMap.splice(runningRequiresPromiseMap.indexOf(packagePromiseMap), 1);

            //Only the first outer call to require, has givenAllInstalledCallbacks set to null
            if (givenRequireToken === null) {
                let allInstalledCallbacks = allInstalledCallbacksStack.pop();
                console.timeEnd(requireTimerId);

                let allInstalledTimerId = "All Installed [" + timerId + "]";

                console.time(allInstalledTimerId);
                for(let allInstalledCallback of allInstalledCallbacks) {
                    await allInstalledCallback();
                }
                console.timeEnd(allInstalledTimerId);
            }
        }

        /**
         * Get the package data based on the package DOM node
         *
         * @param {Node} packageDOM the package dom node
         * @returns {WPMPackage} the package
         * @ignore
         */
        static getWPMPackageFromDOM(packageDOM) {
            try {
                let name = packageDOM.getAttribute("id");

                let descriptorDom = packageDOM.querySelector("script[type='descriptor'], wpm-descriptor");

                if (descriptorDom !== null) {
                    try {
                        let packageJson = JSON.parse(descriptorDom.textContent);
                        let repository = packageDOM.getAttribute("data-repository");

                        if(repository == null) {
                            repository = WPMv2.getLocalRepositoryURL();
                        }

                        return new WPMPackage(name, repository, packageJson);
                    } catch (e){
                        console.error("Erroneous package descriptor", e, descriptorDom.textContent, packageDOM);
                    }
                } else {
                    console.error("Missing package descriptor: ", packageDOM);
                }
            } catch (e) {
                console.error(e);
            }
        }

        static getLocalRepositoryURL() {
            return location.origin + location.pathname + "?raw";
        }

        /**
         * Retrieve the package dom from a repository
         *
         * @param {String} repository the repository to retrieve from
         * @param {String} packageName the package to retrieve
         * @returns {Node} the package dom node
         * @ignore
         */
        static async getPackageDOM(repository, packageName) {
            let dom = null;

            if(repository == this.getLocalRepositoryURL()) {
                dom = document.querySelector("html");
            } else {
                dom = await WPMv2.fetchDom(repository);
            }

            let packageDOMSource = dom.querySelector(".packages .package#" + packageName + ", wpm-package#" + packageName);
            if (packageDOMSource === null) {
                throw new Error("Invalid package '" + packageName + "' specified, no such package in repository '" + repository + "'");
            }

            let packageDOM = packageDOMSource.cloneNode(true);
            if(!packageDOM.hasAttribute("data-repository")) {
                packageDOM.setAttribute("data-repository", repository);
            }

            return packageDOM;
        }

        /**
         * Get an array of all packages that is currently installed in the dom
         *
         * @example
         * let installedPackages = WPMv2.getCurrentlyInstalledPackages();
         *
         * @returns {WPMv2.WPMPackage[]}
         */
        static getCurrentlyInstalledPackages() {
            let packages = [];

            document.querySelectorAll(".packages .package, wpm-package").forEach(function (v) {
                packages.push(WPMv2.getWPMPackageFromDOM(v));
            });

            return packages;
        }

        /**
         * Retrieve the latest package data from the original repository this package is from
         *
         * @example
         * WPMv2.getCurrentlyInstalledPackages().forEach((pkg)=>{
         *     let package = WPMv2.getLatestPackageFromPackage(pkg);
         *     //package now holds the latest data retrieved from the original repo it was installed from: like version, dependencies, changelog etc.
         * });
         *
         * @param {WPMv2.WPMPackage} p - The package to update package data for
         * @returns {Promise<WPMv2.WPMPackage>}
         */
        static async getLatestPackageFromPackage(p, repoOverride=null) {
            let fetchRepository = p.repository;
            if(repoOverride != null) {
                fetchRepository = repoOverride;
            }
            let packageDOM = await WPMv2.getPackageDOM(fetchRepository, p.name);

            let updatedPackage = WPMv2.getWPMPackageFromDOM(packageDOM);

            updatedPackage.updateFromOptions(p.getPackageOptions());

            return updatedPackage;
        }

        /**
         * Find all packages at a repository
         *
         * @example
         * WPMv2.getPackagesFromRepository("some.site.com/myRepo").then((packages)=>{
         *     console.log("Packages at repo:");
         *     packages.forEach((pkg)=>{
         *         console.log(pkg);
         *     }):
         * });
         *
         * @param {String} repositoryUrl the repository to search
         * @returns {Promise<WPMv2.WPMPackage[]>} the packages found
         */
        static async getPackagesFromRepository(repositoryUrl) {
            let packages = [];

            let dom = await WPMv2.fetchDom(repositoryUrl);

            dom.querySelectorAll(".packages .package, wpm-package").forEach(function (v) {
                if(!v.hasAttribute("data-repository")) {
                    v.setAttribute("data-repository", repositoryUrl);
                }
                packages.push(WPMv2.getWPMPackageFromDOM(v));
            });

            return packages;
        }

        static readMetadata(packageName) {
            let packageDom = document.querySelector(".packages .package#" + packageName + ", wpm-package#" + packageName);

            if(packageDom != null) {
                let metadataDom = packageDom.querySelector("script[type='descriptor'], wpm-descriptor");

                if (metadataDom != null) {
                    return JSON.parse(metadataDom.textContent);
                }
            }
            return null;
        }

        static async fetchAsset(url, asset) {
            if(Array.isArray(url)) {
                for(let u of url) {
                    try {
                        let fetchedAsset = await WPMv2.fetchAsset(u, asset);
                        if(fetchedAsset != null) {
                            return fetchedAsset;
                        }
                    } catch(e) {
                        //Ignore
                    }
                }
            }

            let assetUrl = url.substring(0, url.indexOf("?"));
            if (!assetUrl.endsWith("/")) {
                assetUrl += "/";
            }

            assetUrl += asset;

            let response = await fetch(assetUrl, {credentials: 'same-origin'});
            let blob = await response.blob();

            return blob;
        }

        static async fetchAssets(url) {
            if(Array.isArray(url)) {
                for(let u of url) {
                    try {
                        let assets = await WPMv2.fetchAssets(u);
                        if (assets != null) {
                            return assets;
                        }
                    } catch(e) {
                        //Ignore ?
                    }
                }
            }

            if(!url.endsWith("?assets&latest")) {
                url = url.substring(0, url.indexOf("?")) + "?assets&latest";
            }

            if (WPMv2.assetsCache[url] != null) {
                if (Date.now() - WPMv2.assetsCache[url].timestamp < WPMv2.cacheTimeout) {
                    return WPMv2.assetsCache[url].assets;
                }
            }

            let response = await fetch(url, {credentials: 'same-origin'});

            let assetsJson = await response.json();

            let assetResult = new Map();

            assetsJson.forEach((asset)=>{
                let current = assetResult.get(asset.fileName);

                if(current == null || current.v < asset.v) {
                    assetResult.set(asset.fileName, asset);
                }
            });

            WPMv2.assetsCache[url] = {
                assets: assetResult,
                timestamp: Date.now()
            };

            return assetResult;
        }

        static lookupRepoAlias(alias) {
            let localStorageAliases = {};
            let sessionStorageAliases = {};
            try {
                localStorageAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
            } catch (ex){
                console.warn("Unparseable localStorage.repositoryAliases", ex);
            }
            try {
                sessionStorageAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
            } catch (ex){
                console.warn("Unparseable sessionStorage.repositoryAliases", ex);
            }

            if(localStorageAliases?.hasOwnProperty(alias)) {
                let result = localStorageAliases[alias];
                return result;
            } else if(sessionStorageAliases?.hasOwnProperty(alias)) {
                let result = sessionStorageAliases[alias];
                return result;
            } else {
                //Check if alias might be an url already?
                if(alias.startsWith("http") || alias.startsWith("/")) {
                    //Probabely an url
                    return alias;
                }
            }

            return ["/"+alias+"/?raw", "/"+alias+"/index.html"];
        }

        static async fetchDom(url) {
            //Lookup repos aliases
            url = WPMv2.lookupRepoAlias(url);

            if(Array.isArray(url)) {
                //Call again for each url in array
                for(let u of url) {
                    try {
                        let fetchedDom = await this.fetchDom(u);
                        if(fetchedDom != null) {
                            return fetchedDom;
                        }
                    } catch(e) {
                        //Ignore?
                        console.warn(e);
                    }
                }
            } else {
                if(url.endsWith("?raw") && !url.endsWith("/?raw")) {
                    url = url.substring(0, url.lastIndexOf("?raw")) + "/?raw";
                }

                // Check the cache for ongoing fetches for this URL
                let cachedDom = WPMv2.domCache.get(url);
                if (cachedDom != null) {
                    cachedDom = await cachedDom;
                    if (Date.now() - cachedDom.timestamp < WPMv2.cacheTimeout) {
                        return cachedDom.dom;
                    }
                }

                // No ongoing fetches, start one
                let fetcherPromise = (async function fetchDOMPromise(){
                    let response = await fetch(url, {credentials: 'same-origin'});
                    if(response != null) {
                        let documentText = await response.text();

                        let parsedDom = WPMv2.parser.parseFromString(documentText, "text/html");
                        if (parsedDom.readyState === "loading") {
                            await new Promise((resolve, reject) => {
                                parsedDom.addEventListener("DOMContentLoaded", () => {
                                    resolve();
                                });
                            });
                        }

                        return {
                            dom: parsedDom,
                            timestamp: Date.now()
                        };
                    }
                })();
                WPMv2.domCache.set(url, fetcherPromise);

                return (await fetcherPromise).dom;
            }

            console.error("Unable to fetchDOM from: ", url);
            return null;
        }

        /**
         * Strips all Webstrate protection from the given dom element and its children.
         *
         * @example
         * WPMv2.stripProtection(document.querySelector("#myElement"));
         *
         * @param {HTMLElement} html - The element to strip protection from
         */
        static stripProtection(html) {
            function stripAttributeProtection(elm) {
                if (!elm.__approvedAttributes) {
                    try {
                        elm.__approvedAttributes = new Set();
                    } catch (e) {
                    }
                }

                if (elm.attributes != null) {
                    for (let i = 0, atts = elm.attributes, n = atts.length; i < n; i++) {
                        elm.__approvedAttributes.add(atts[i].nodeName);
                    }
                }
            }

            if (html instanceof Array) {
                html.forEach((entry) => {
                    if (entry != null) {
                        WPMv2.stripProtection(entry);
                    }
                });
                return;
            }

            if (!html.__approved) {
                try {
                    html.__approved = true;
                } catch (e) {
                }
            }

            if (html.removeAttribute != null) {
                html.removeAttribute("unapproved");
            }

            stripAttributeProtection(html);

            if (html.childNodes != null) {
                Array.from(html.childNodes).forEach((child) => {
                    WPMv2.stripProtection(child);
                });
            } else if (html.children != null) {
                Array.from(html.children).forEach((child) => {
                    WPMv2.stripProtection(child);
                });
            }

            if (html.content != null) {
                WPMv2.stripProtection(html.content);
            }
        }

        /**
         * Updates the version of WPMv2 in the current page, with the version in the given url
         *
         * @example
         * await WPMv2.updateWPM("https://some.site.com/containsLatestWPMv2");
         * //WPMv2 is now updated
         *
         * @param {string} url - URL to the webstrate to update WPMv2 from
         * @returns {Promise<void>} - Resolves when WPMv2 is updated
         */
        static async updateWPM(url) {
            console.group("Updating WPM...");
            if(url == null) {
                console.log("No repository given for update, defaulting to \"/wpm/?raw\"");
                url = "/wpm/?raw";
            }

            console.log("Version before update:", window.WPMv2.version);

            let dom = await WPMv2.fetchDom(url);

            let newWpm = dom.querySelector("#WPMv2-script");

            let ourWpm = document.querySelector("#WPMv2-script");

            ourWpm.textContent = newWpm.textContent;

            if(ourWpm.hasAttribute("src")) {
                ourWpm.removeAttribute("src");
                console.warn("Removed src attribute on WPMScript, now inlined instead!");
            }
            eval.call(null, ourWpm.textContent);
            console.log("Version after update:", window.WPMv2.version);
            console.groupEnd();
        }

        /**
         * Installs WPMv2 into the given webstrate. Can be given as an iframe that already points to a transcluded webstrate, or the url to a webstrate.
         *
         * @example
         * await WPMv2.installWPMInto("https://some.site.com/myWebstrate");
         * //WPMv2 is now installed
         *
         * @param {HTMLIFrameElement|string} iframeOrUrl - The iframe or url that WPMv2 should be installed into
         * @returns {Promise<void>} - Resolves when WPMv2 is done installing.
         */
        static async installWPMInto(iframeOrUrl) {
            let iframe = null;
            let transient = null;

            if (typeof iframeOrUrl === "string") {
                iframe = document.createElement("iframe");
                iframe.src = iframeOrUrl;
                let promise = new Promise((resolve, reject) => {
                    iframe.webstrate.on("transcluded", function once() {
                        iframe.webstrate.off("transcluded", once);
                        resolve();
                    });
                });

                transient = document.createElement("transient");
                transient.append(iframe);
                document.body.append(transient);

                await promise;
            } else {
                //Attempt to unpack cQuery/jQuery objects
                if (iframeOrUrl[0] != null) {
                    iframeOrUrl = iframeOrUrl[0];
                }

                if (iframeOrUrl instanceof HTMLIFrameElement) {
                    iframe = iframeOrUrl;
                } else {
                    console.log("Unknown iframe/url: ", iframeOrUrl);
                    return;
                }
            }

            let targetHead = iframe.contentDocument.head;

            //Remove old WPMv2 if present
            let oldWpm = iframe.contentDocument.querySelector("#WPMv2-script");
            if (oldWpm != null) {
                oldWpm.parentNode.removeChild(oldWpm);
            }

            let clonedScript = document.querySelector("#WPMv2-script").cloneNode(true);

            if (clonedScript.src != null && clonedScript.src.length > 0) {
                let response = await fetch(clonedScript.src, {credentials: 'same-origin'});
                let scriptContent = await response.text();

                clonedScript.removeAttribute("src");
                clonedScript.textContent = scriptContent;
            }

            WPMv2.stripProtection(clonedScript);
            targetHead.insertBefore(clonedScript, targetHead.firstChild);

            iframe.contentWindow.eval.call(null, clonedScript.textContent);

            await iframe.contentWindow.webstrate.dataSaved();

            if (transient != null) {
                document.body.removeChild(transient);
            }
        }

        static notifyRemove(packageName, packageDom) {
            let event = new CustomEvent("wpm.packageRemoved", {detail: packageName});
            packageDom.dispatchEvent(event);

            let eventAny = new CustomEvent("wpm.packageRemovedAny", {detail: packageName});
            document.dispatchEvent(eventAny);
        }

        static getRegisteredRepositories(useLocalStorage) {
            let currentAliases = null;

            try {
                if(useLocalStorage) {
                    currentAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
                } else {
                    currentAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
                }
            } catch (ex){}
            if (currentAliases == null || typeof currentAliases !== "object"){
                currentAliases = {};
            }

            return currentAliases;
        }

        /**
         * Registers a repository alias
         * @param alias The alias to register
         * @param repository The repository to register the alias to
         * @param useLocalStorage If true, the registered alias is registered in localStorage, if not, in sessionStorage
         */
        static registerRepository(alias, repository, useLocalStorage = false) {
            let currentAliases = null;

            try {
                if(useLocalStorage) {
                    currentAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
                } else {
                    currentAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
                }
            } catch (ex){}
            if (currentAliases == null || typeof currentAliases !== "object"){
                currentAliases = {};
            }

            currentAliases[alias] = repository;

            if(useLocalStorage) {
                localStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            } else {
                sessionStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            }
        }

        /**
         * Unregisters a repository alias
         * @param alias The alias to unregister
         * @param useLocalStorage If true, the alias is removed from localStorage, if not, from sessionStorage
         */
        static unregisterRepository(alias, useLocalStorage = false) {
            let currentAliases = null;

            try {
                if(useLocalStorage) {
                    currentAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
                } else {
                    currentAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
                }
            } catch (ex){
                console.error(ex);
            }
            if (currentAliases == null || typeof currentAliases !== "object"){
                console.log(currentAliases);
                currentAliases = {};
            }

            delete currentAliases[alias];

            if(useLocalStorage) {
                localStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            } else {
                sessionStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            }
        }

        /**
         * Clears all registered aliases from storage
         * @param useLocalStorage If true, clears from localStorage, if not, from sessionStorage
         */
        static clearRegisteredRepositories(useLocalStorage = false) {
            if(useLocalStorage) {
                localStorage.setItem(WPM_ALIASES, "{}");
            } else {
                sessionStorage.setItem(WPM_ALIASES, "{}");
            }
        }
    }

    WPMv2.domCache = new Map();
    WPMv2.assetsCache = {};
    WPMv2.parser = new DOMParser();
    WPMv2.cacheTimeout = 5000;

    /**
     * A WPM package
     * @memberof WPMv2
     */
    class WPMPackage {
        /**
         * Create a new WPMPackage
         * @param {string} name - The package name
         * @param {string} repository - The repository that the package should be fetched from
         * @param {json} [descriptorJson] - Package Descriptor
         */
        constructor(name, repository, descriptorJson = {}) {
            /**
             * The name of the package
             * @type {string}
             */
            this.name = name;
            /**
             * The repository the package is fetched from
             * @type {string}
             */
            this.repository = repository;

            /**
             * The version of the package
             * @type {number}
             */
            this.version = -1;
            /**
             * Package dependencies that will be installed when the package is installed
             * @type {string[]}
             */
            this.dependencies = [];
            /**
             * Optional Package dependencies
             * @type {string[]}
             */
            this.optionalDependencies = [];
            /**
             * Assets that the package uses, will be copied over to the webstrate where the package is installed
             * @type {Array.<string>}
             */
            this.assets = [];
            /**
             * A description of the package
             * @type {string}
             */
            this.description = "";
            /**
             * A human friendly name for the package
             * @type {string}
             */
            this.friendlyName = "";
            /**
             * Changelog, holding any changelog information for the package
             * @type {object}
             */
            this.changelog = {};
            /**
             * Link to documentation of the package if any exists
             * @type {string}
             */
            this.documentationLink = "";

            this.dependencyMap = new Map();
            this.optionalDependencyMap = new Map();

            this.appendMethod = "append";
            this.appendTarget = null;

            this.bootstrap = true;

            this.updateFromJson(descriptorJson);
        }

        updateFromOptions(options) {
            ["appendMethod", "appendTarget", "repository", "bootstrap"].forEach((optionProperty)=>{
                if(options.hasOwnProperty(optionProperty)) {
                    this[optionProperty] = options[optionProperty];
                }
            })
        }

        getPackageOptions() {
            let options = {};

            ["appendMethod", "appendTarget", "repository", "bootstrap"].forEach((optionProperty)=>{
                options[optionProperty] = this[optionProperty];
            });

            return options;
        }

        updateFromJson(packageJson) {
            let self = this;

            this.descriptor = packageJson;

            ["version", "friendlyName", "dependencies", "optionalDependencies", "description", "changelog", "documentationLink", "license"].forEach((packageProperty)=>{
                if (packageJson.hasOwnProperty(packageProperty)){
                    this[packageProperty] = packageJson[packageProperty];
                }
            });

            if (packageJson.hasOwnProperty("assets")) {
                packageJson.assets.forEach((asset) => {
                    if (asset.src != null) {
                        self.assets.push(asset.src);
                    } else {
                        self.assets.push(asset);
                    }
                });
            }

            this.dependencies.forEach((dep) => {
                let split = dep.split(" ");

                let repo = null;
                let packageName = null;

                if (split.length === 1) {
                    packageName = split[0].replace("#", "");
                    repo = this.repository;
                } else {
                    packageName = split[1].replace("#", "");
                    repo = split[0];
                }

                self.dependencyMap.set(packageName, repo);
            });

            this.optionalDependencies.forEach((dep) => {
                let split = dep.split(" ");

                let repo = null;
                let packageName = null;

                if (split.length === 1) {
                    packageName = split[0].replace("#", "");
                    repo = this.repository;
                } else {
                    packageName = split[1].replace("#", "");
                    repo = split[0];
                }

                self.optionalDependencyMap.set(packageName, repo);
            });
        }

        toString() {
            return this.name + "[" + this.version + "]";
        }
    }

    let removedObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            mutation.removedNodes.forEach((node) => {
                if (node.matches != null && node.matches(".packages .package, wpm-package")) {
                    WPMv2.notifyRemove(node.id, node);
                } else if (node.querySelectorAll != null) {
                    node.querySelectorAll(".packages .package, wpm-package").forEach((child) => {
                        WPMv2.notifyRemove(child.id, child);
                    });
                }
            });
        });
    });

    removedObserver.observe(document, {
        childList: true,
        attributes: false,
        subtree: true
    });

    //Setup attribute "transient-element" that marks a DOM element as transient
    if(typeof webstrate !== "undefined") {
        let oldIsTransientElement = webstrate.config.isTransientElement;
        webstrate.config.isTransientElement = (node) => {
            if (node.hasAttribute("transient-element")) {
                return true;
            }

            return oldIsTransientElement(node);
        };
    }

    //WPMv2 Interface to the world!
    window.WPMv2 = {
        require: WPMv2.require,
        requireAll: WPMv2.requireAll,
        installWPMInto: WPMv2.installWPMInto,
        stripProtection: WPMv2.stripProtection,
        updateWPM: WPMv2.updateWPM,
        getPackagesFromRepository: WPMv2.getPackagesFromRepository,
        getCurrentlyInstalledPackages: WPMv2.getCurrentlyInstalledPackages,
        getLatestPackageFromPackage: WPMv2.getLatestPackageFromPackage,
        registerRepository: WPMv2.registerRepository,
        unregisterRepository: WPMv2.unregisterRepository,
        clearRegisteredRepositories: WPMv2.clearRegisteredRepositories,
        getRegisteredRepositories: WPMv2.getRegisteredRepositories,
        getLocalRepositoryURL: WPMv2.getLocalRepositoryURL,
        version: 2.42,
        revision: "$Id: WPMv2.js 1023 2023-03-14 10:02:57Z au182811@uni.au.dk $",
        test: WPMv2
    };

    window.WPM = window.WPMv2;
    window.WPMPackage = WPMPackage;
})(window);

// Provide bootloader functionality
class WPMBoot {
    static loadedCallbacks = [];
    static isLoaded = false;

    static async wpmv2_bootloader(){
        document.querySelector("html").setAttribute("transient-wpm2-bootloader", "loading");

        let bootConfigElement = document.querySelector("head script[type='text/json+bootconfig']");
        if (!bootConfigElement){
            return;
        }

        let bootConfig = null;
        try {
            bootConfig = JSON.parse(bootConfigElement.textContent);
        } catch (ex){
            console.error("WPM bootloader cannot parse boot config", bootConfigElement.textContent, ex);
            return;
        }

        if (!bootConfig.require){
            console.warn("WPM bootloader did not find required 'require' section in boot config, ignoring");
            return;
        }

        if (!Array.isArray(bootConfig.require)){
            console.warn("WPM bootloader 'require' section in boot config is not an array, ignoring");
            return;
        }

        // Load all required packages with WPM
        for (let requireStep of bootConfig.require){
            if (!(requireStep.dependencies && Array.isArray(requireStep.dependencies))){
                console.warn("WPM bootloader skipping incorrect requirestep, dependency list is missing", requireStep);
                continue;
            }
            if (requireStep.repositories){
                if (typeof requireStep.repositories !== "object"){
                    console.warn("WPM bootloader skipping registration of repositories because requireStep.repositories isn't an object map of name->url", requireStep);
                } else {
                    for (const [key, value] of Object.entries(requireStep.repositories)) {
                        WPMv2.registerRepository(key, value);
                    }
                }
            }

            if (requireStep.options){
                await WPMv2.require(requireStep.dependencies, requireStep.options);
            } else {
                await WPMv2.require(requireStep.dependencies);
            }
        }

        // Fire loaded events
        document.querySelector("html").setAttribute("transient-wpm2-bootloader", "initializing");
        while (WPMBoot.loadedCallbacks.length>0){
            let callback = WPMBoot.loadedCallbacks.pop();
            try {
                await callback();
            } catch (ex){
                console.error("WPMv2 Bootloader exception in WPMBoot.onLoaded(...) callback", ex, callback);
            }
        }
        document.querySelector("html").setAttribute("transient-wpm2-bootloader", "loaded");
    }

    static async onLoaded(callback){
        if (WPMBoot.isLoaded){
            await callback();
        } else {
            WPMBoot.loadedCallbacks.push(callback);
        }
    }
}
window.WPMBoot = WPMBoot;

document.querySelector("html").setAttribute("transient-wpm2-bootloader", "waiting");
if(typeof webstrate  !== "undefined") {
    // Webstrate mode
    webstrate.on("loaded", async function wpmv2_bootloader_loader() {
        await WPMBoot.wpmv2_bootloader();
    });
} else {
    // Standalone mode
    document.addEventListener("DOMContentLoaded", async function(event) {
        await WPMBoot.wpmv2_bootloader();
    });
}
</script><title>Spatialstrates</title><meta name="viewport" content="width=device-width, initial-scale=1"/><script type="text/json+bootconfig">{
    "creator": "WPMPackageManager",
    "created": 1650368097912,
    "require": [
        {
            "repositories": {
                "codestrates-repos": "https://raw.githubusercontent.com/Webstrates/Codestrates-v2/master/codestrates.html",
                "webstrate-components-repos": "https://raw.githubusercontent.com/Webstrates/WebstrateComponents/master/components.html",
                "cauldron-repos": "https://raw.githubusercontent.com/Webstrates/Cauldron/master/cauldron.html",
                "wpm_js_libs": "https://raw.githubusercontent.com/Webstrates/WebstrateLibraryRepository/master/libraries.html",
                "varv-repos": "https://raw.githubusercontent.com/Webstrates/Varv/master/varv.html",
                "wpm-repos": "https://raw.githubusercontent.com/Webstrates/WPM/master/build.html",
                "spatialstrates-repos": "https://raw.githubusercontent.com/Webstrates/Spatialstrates/canvas/repository/spatialstrates.html"
            },
            "dependencies": [
                {
                    "package": "CauldronURLLauncher",
                    "repository": "cauldron-repos"
                },
                {
                    "package": "CauldronButtonLauncher",
                    "repository": "cauldron-repos"
                },
                {
                    "package": "fragment_js",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_html",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_json",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_wpm-descriptor",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_css",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_scss",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_js_babel",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "FragmentFilesystemSync",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_markdown",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "varv",
                    "repository": "varv-repos"
                },
                {
                    "package": "WPM-loading-skin-simple",
                    "repository": "wpm-repos"
                },
                {
                    "repository": "spatialstrates-repos"
                }
            ],
            "options": {}
        }
    ],
    "updated": 1748944437782,
    "knownRepositories": [
        "spatialstrates-repos"
    ]
}</script><LINK rel="manifest" href="manifest.json"/><LINK rel="icon" href="favicon.ico"/>



        <META name="description" content="Cross-Reality Hypermedia in the Web"/></head><body style="cursor: default;"><wpm-package data-repository="wpm-repos" id="WPM-loading-skin-simple" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><script id="descriptor-script" type="descriptor">
{
    "description": "A simple loading skin for the bootloader to avoid seeing improperly rendered HTML while loading",
    "dependencies": [
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "0.4",
    "forceEmbedding": true
}

</script><style id="loading-style">
html:not([transient-wpm2-bootloader="loaded"]) > * {
  opacity: 0 !important; }

@keyframes wpm-bootloader-spin {
  from {
    transform: translate(-50%, -50%) rotate(0); }
  to {
    transform: translate(-50%, -50%) rotate(360deg); } }

@keyframes wpm-bootloader-done {
  0% {
    transform: translate(-50%, -50%);
    filter: blur(0.01em); }
  99% {
    transform: translate(-50%, -50%) scale(1.5);
    opacity: 0;
    filter: blur(2em); }
  100% {
    visibility: hidden;
    transform: translate(-50%, -50%) scale(1.5);
    opacity: 0;
    filter: blur(2em); } }

html[transient-wpm2-bootloader="waiting"]:before, html[transient-wpm2-bootloader="loading"]:before, html[transient-wpm2-bootloader="initializing"]:before, html[transient-wpm2-bootloader="loaded"]:before {
  animation: wpm-bootloader-spin 1s infinite linear both;
  content: "";
  position: fixed;
  left: 50%;
  top: 50%;
  width: 3em;
  height: 3em;
  background: #f6fbff;
  border-radius: 2em;
  border: 4px solid white;
  border-top-color: rgba(0, 102, 255, 0.589);
  border-bottom-color: rgba(11, 90, 21, 0.466);
  box-shadow: 0 0 2em rgba(49, 60, 162, 0.446);
  pointer-events: none;
  z-index: 9999; }

html[transient-wpm2-bootloader="waiting"][transient-wpm2-bootloader="loaded"]:before, html[transient-wpm2-bootloader="loading"][transient-wpm2-bootloader="loaded"]:before, html[transient-wpm2-bootloader="initializing"][transient-wpm2-bootloader="loaded"]:before, html[transient-wpm2-bootloader="loaded"][transient-wpm2-bootloader="loaded"]:before {
  animation: wpm-bootloader-done 1s ease-out both; }
</style></wpm-package><wpm-package id="WPM-dev" data-repository="wpm-repos"><script id="descriptor-script" type="descriptor">
                    {
                        "dependencies": [
                        ],
                        "forceEmbedding": true
                    }

                    </script>


                </wpm-package><varv-data></varv-data><varv-signaling></varv-signaling><screen-signaling></screen-signaling><video-signaling></video-signaling><audio-signaling></audio-signaling><code-folder name="Core"><wpm-package id="ImportMapping" name="ImportMapping"><code-fragment data-type="wpm/descriptor"><wpm-descriptor>{
    "description": "Import map for Spatialstrates.",
    "dependencies": [],
    "assets": [
        "use-gesture-fix.zip"
    ],
    "version": "0.2.0"
}
</wpm-descriptor></code-fragment><script name="Import Mapping" type="importmap" class="import-map" id>{
    "imports": {
        "three": "https://esm.sh/v135/three@0.173.0?dev=&target=es2024&external=*",
        "three/": "https://esm.sh/v135/three@0.173.0&dev&target=es2024&external=*/",
        "three-stdlib": "https://esm.sh/v135/three-stdlib@2.30.4?dev=&target=es2024&external=*",
        "three-mesh-bvh": "https://esm.sh/v135/three-mesh-bvh@0.7.6?dev=&target=es2024&external=*",
        "react": "https://esm.sh/v135/react@18.3.1?dev=&target=es2024&external=*",
        "react/": "https://esm.sh/v135/react@18.3.1&dev&target=es2024&external=*/",
        "react-dom": "https://esm.sh/v135/react-dom@18.3.1?dev=&target=es2024&external=*",
        "react-dom/": "https://esm.sh/v135/react-dom@18.3.1&dev&target=es2024&external=*/",
        "react-is": "https://esm.sh/v135/react-is@18.3.1?dev=&target=es2024&external=*",
        "react-composer": "https://esm.sh/v135/react-composer@5.0.3?dev=&target=es2024&external=*",
        "react-use-measure": "https://esm.sh/v135/react-use-measure@2.1.1?dev=&target=es2024&external=*",
        "react-merge-refs": "https://esm.sh/v135/react-merge-refs@1.1.0?dev=&target=es2024&external=*",
        "react-reconciler": "https://esm.sh/v135/react-reconciler@0.29.2?dev=&target=es2024&external=*",
        "react-reconciler/": "https://esm.sh/v135/react-reconciler@0.29.2&dev&target=es2024&external=*/",
        "react-error-boundary": "https://esm.sh/v135/react-error-boundary@4.0.13?dev=&target=es2024&external=*",
        "@react-three/fiber": "https://esm.sh/v135/@react-three/fiber@8.17.14?dev=&target=es2024&external=*",
        "@react-three/drei": "https://esm.sh/v135/@react-three/drei@9.121.4?dev=&target=es2024&external=*",
        "hls.js": "https://esm.sh/v135/hls.js@1.5.19/es2022/hls.development.mjs",
        "@react-three/xr": "https://esm.sh/v135/@react-three/xr@6.6.8?dev=&target=es2024&external=*",
        "@pmndrs/xr": "https://esm.sh/v135/@pmndrs/xr@6.6.8?dev=&target=es2024&external=*",
        "@pmndrs/xr/": "https://esm.sh/v135/@pmndrs/xr@6.6.8&dev&target=es2024&external=*/",
        "@pmndrs/pointer-events": "https://esm.sh/v135/@pmndrs/pointer-events@6.6.8?dev=&target=es2024&external=*",
        "@iwer/devui": "https://esm.sh/v135/@iwer/devui@0.1.1?dev=&target=es2024&external=*",
        "@react-three/uikit": "https://esm.sh/v135/@react-three/uikit@0.8.7?dev=&target=es2024&external=*",
        "@react-three/uikit-apfel": "https://esm.sh/v135/@react-three/uikit-apfel@0.8.7?dev=&target=es2024&external=*",
        "@react-three/uikit-lucide": "https://esm.sh/v135/@react-three/uikit-lucide@0.8.7?dev=&target=es2024&external=*",
        "@pmndrs/uikit": "https://esm.sh/v135/@pmndrs/uikit@0.8.7?dev=&target=es2024&external=*",
        "@pmndrs/uikit/": "https://esm.sh/v135/@pmndrs/uikit@0.8.7&dev&target=es2024&external=*/",
        "@pmndrs/msdfonts": "https://esm.sh/v135/@pmndrs/msdfonts@0.8.7?dev=&target=es2024&external=*",
        "@react-spring/three": "https://esm.sh/v135/@react-spring/three@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/core": "https://esm.sh/v135/@react-spring/core@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/shared": "https://esm.sh/v135/@react-spring/shared@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/animated": "https://esm.sh/v135/@react-spring/animated@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/types": "https://esm.sh/v135/@react-spring/types@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/rafz": "https://esm.sh/v135/@react-spring/rafz@9.7.3?dev=&target=es2024&external=*",
        "zustand": "https://esm.sh/v135/zustand@4.5.5?dev=&target=es2024&external=*",
        "zustand/": "https://esm.sh/v135/zustand@4.5.5&dev&target=es2024&external=*/",
        "lodash": "https://esm.sh/v135/lodash@4.17.21?dev=&target=es2024&external=*",
        "lodash.pick": "https://esm.sh/v135/lodash.pick@4.4.0?dev=&target=es2024&external=*",
        "lodash.omit": "https://esm.sh/v135/lodash.omit@4.5.0?dev=&target=es2024&external=*",
        "lodash.clamp": "https://esm.sh/v135/lodash.clamp@4.0.3?dev=&target=es2024&external=*",
        "lodash.merge": "https://esm.sh/v135/lodash.merge@4.6.2?dev=&target=es2024&external=*",
        "lodash.mergewith": "https://esm.sh/v135/lodash.mergewith@4.6.2?dev=&target=es2024&external=*",
        "@babel/runtime/helpers/esm/extends": "https://esm.sh/v135/@babel/runtime@7.24.8/helpers/extends?dev=&target=es2024&external=*",
        "@monogrid/gainmap-js": "https://esm.sh/v135/@monogrid/gainmap-js@3.0.5?dev=&target=es2024&external=*",
        "@preact/signals-core": "https://esm.sh/v135/@preact/signals-core@1.6.1?dev=&target=es2024&external=*",
        "bidi-js": "https://esm.sh/v135/bidi-js@1.0.3?dev=&target=es2024&external=*",
        "camera-controls": "https://esm.sh/v135/camera-controls@2.8.5?dev=&target=es2024&external=*",
        "debounce": "https://esm.sh/v135/debounce@2.1.0?dev=&target=es2024&external=*",
        "detect-gpu": "https://esm.sh/v135/detect-gpu@5.0.40?dev=&target=es2024&external=*",
        "fast-json-patch": "https://esm.sh/v135/fast-json-patch@3.1.1?dev=&target=es2024&external=*",
        "fflate": "https://esm.sh/v135/fflate@0.8.2?dev=&target=es2024&external=*",
        "inline-style-parser": "https://esm.sh/v135/inline-style-parser@0.2.3?dev=&target=es2024&external=*",
        "its-fine": "https://esm.sh/v135/its-fine@1.2.5?dev=&target=es2024&external=*",
        "json-stringify-pretty-compact": "https://esm.sh/v135/json-stringify-pretty-compact@4.0.0?dev=&target=es2024&external=*",
        "maath": "https://esm.sh/v135/maath@0.10.8?dev=&target=es2024&external=*",
        "meshline": "https://esm.sh/v135/meshline@3.1.6?dev=&target=es2024&external=*",
        "node-html-parser": "https://esm.sh/v135/node-html-parser@6.1.13?dev=&target=es2024",
        "object-assign": "https://esm.sh/v135/object-assign@4.1.1?dev=&target=es2024&external=*",
        "potpack": "https://esm.sh/v135/potpack@2.0.0?dev=&target=es2024&external=*",
        "prettier/": "https://esm.sh/v135/prettier@3.3.2&dev&target=es2024&external=*/",
        "prop-types": "https://esm.sh/v135/prop-types@15.8.1?dev=&target=es2024&external=*",
        "scheduler": "https://esm.sh/v135/scheduler@0.23.2?dev=&target=es2024&external=*",
        "stats.js": "https://esm.sh/v135/stats.js@0.17.0?dev=&target=es2024&external=*",
        "stats-gl": "https://esm.sh/v135/stats-gl@2.2.8?dev=&target=es2024&external=*",
        "suspend-react": "https://esm.sh/v135/suspend-react@0.1.3?dev=&target=es2024&external=*",
        "tunnel-rat": "https://esm.sh/v135/tunnel-rat@0.1.2?dev=&target=es2024&external=*",
        "tw-to-css": "https://esm.sh/v135/tw-to-css@0.0.12?dev=&target=es2024&external=*",
        "troika-three-text": "https://esm.sh/v135/troika-three-text@0.49.0?dev=&target=es2024&external=*",
        "troika-three-utils": "https://esm.sh/v135/troika-three-utils@0.49.0?dev=&target=es2024&external=*",
        "troika-worker-utils": "https://esm.sh/v135/troika-worker-utils@0.49.0?dev=&target=es2024&external=*",
        "use-sync-external-store": "https://esm.sh/v135/use-sync-external-store@1.2.2?dev=&target=es2024&external=*",
        "use-sync-external-store/": "https://esm.sh/v135/use-sync-external-store@1.2.2&dev&target=es2024&external=*/",
        "uuid": "https://esm.sh/v135/uuid@10.0.0?dev=&target=es2024&external=*",
        "webgl-sdf-generator": "https://esm.sh/v135/webgl-sdf-generator@1.1.1?dev=&target=es2024&external=*",
        "yoga-layout/": "https://esm.sh/v135/yoga-layout@3.0.4&dev&target=es2024&external=*/",
        "vega": "https://esm.sh/v135/vega@5.30.0?dev=&target=es2024",
        "vega-embed": "https://esm.sh/v135/vega-embed@6.29.0?dev=&target=es2024",
        "react-vega": "https://esm.sh/v135/react-vega@7.6.0?dev=&target=es2024&external=react,vega,vega-embed",
        "d3": "https://esm.sh/v135/d3@7.9.0?dev=&target=es2024",
        "@use-gesture/core": "./use-gesture-fix.zip/use-gesture-core.esm.js",
        "@use-gesture/core/actions": "./use-gesture-fix.zip/use-gesture-core-actions.esm.js",
        "@use-gesture/react": "https://esm.sh/v135/@use-gesture/react@10.3.1?dev=&external=*&target=es2024",
        "@use-gesture/core/types": "https://esm.sh/v135/@use-gesture/core@10.3.1/types?dev=&external=*&target=es2024",
        "@use-gesture/core/utils": "https://esm.sh/v135/@use-gesture/core@10.3.1/utils?dev=&external=*&target=es2024",
        "tldraw": "https://esm.sh/v135/tldraw@3.7.0?dev=&external=react,react-dom,@use-gesture/react,@use-gesture/core,@use-gesture/core/actions&target=es2024",
        "ml-pca": "https://esm.sh/v135/ml-pca@4.1.1?dev=&target=es2024",
        "rdkit": "https://esm.sh/v135/@rdkit/rdkit@2024.3.5-1.0.0?dev=&target=es2024&external=*"
    }
}
</script><code-fragment data-type="application/json" name="Import Mapping JSON Copy">{
    "imports": {
        "three": "https://esm.sh/v135/three@0.173.0?dev=&target=es2024&external=*",
        "three/": "https://esm.sh/v135/three@0.173.0&dev&target=es2024&external=*/",
        "three-stdlib": "https://esm.sh/v135/three-stdlib@2.30.4?dev=&target=es2024&external=*",
        "three-mesh-bvh": "https://esm.sh/v135/three-mesh-bvh@0.7.6?dev=&target=es2024&external=*",
        "react": "https://esm.sh/v135/react@18.3.1?dev=&target=es2024&external=*",
        "react/": "https://esm.sh/v135/react@18.3.1&dev&target=es2024&external=*/",
        "react-dom": "https://esm.sh/v135/react-dom@18.3.1?dev=&target=es2024&external=*",
        "react-dom/": "https://esm.sh/v135/react-dom@18.3.1&dev&target=es2024&external=*/",
        "react-is": "https://esm.sh/v135/react-is@18.3.1?dev=&target=es2024&external=*",
        "react-composer": "https://esm.sh/v135/react-composer@5.0.3?dev=&target=es2024&external=*",
        "react-use-measure": "https://esm.sh/v135/react-use-measure@2.1.1?dev=&target=es2024&external=*",
        "react-merge-refs": "https://esm.sh/v135/react-merge-refs@1.1.0?dev=&target=es2024&external=*",
        "react-reconciler": "https://esm.sh/v135/react-reconciler@0.29.2?dev=&target=es2024&external=*",
        "react-reconciler/": "https://esm.sh/v135/react-reconciler@0.29.2&dev&target=es2024&external=*/",
        "react-error-boundary": "https://esm.sh/v135/react-error-boundary@4.0.13?dev=&target=es2024&external=*",
        "@react-three/fiber": "https://esm.sh/v135/@react-three/fiber@8.17.14?dev=&target=es2024&external=*",
        "@react-three/drei": "https://esm.sh/v135/@react-three/drei@9.121.4?dev=&target=es2024&external=*",
        "hls.js": "https://esm.sh/v135/hls.js@1.5.19/es2022/hls.development.mjs",
        "@react-three/xr": "https://esm.sh/v135/@react-three/xr@6.6.8?dev=&target=es2024&external=*",
        "@pmndrs/xr": "https://esm.sh/v135/@pmndrs/xr@6.6.8?dev=&target=es2024&external=*",
        "@pmndrs/xr/": "https://esm.sh/v135/@pmndrs/xr@6.6.8&dev&target=es2024&external=*/",
        "@pmndrs/pointer-events": "https://esm.sh/v135/@pmndrs/pointer-events@6.6.8?dev=&target=es2024&external=*",
        "@iwer/devui": "https://esm.sh/v135/@iwer/devui@0.1.1?dev=&target=es2024&external=*",
        "@react-three/uikit": "https://esm.sh/v135/@react-three/uikit@0.8.7?dev=&target=es2024&external=*",
        "@react-three/uikit-apfel": "https://esm.sh/v135/@react-three/uikit-apfel@0.8.7?dev=&target=es2024&external=*",
        "@react-three/uikit-lucide": "https://esm.sh/v135/@react-three/uikit-lucide@0.8.7?dev=&target=es2024&external=*",
        "@pmndrs/uikit": "https://esm.sh/v135/@pmndrs/uikit@0.8.7?dev=&target=es2024&external=*",
        "@pmndrs/uikit/": "https://esm.sh/v135/@pmndrs/uikit@0.8.7&dev&target=es2024&external=*/",
        "@pmndrs/msdfonts": "https://esm.sh/v135/@pmndrs/msdfonts@0.8.7?dev=&target=es2024&external=*",
        "@react-spring/three": "https://esm.sh/v135/@react-spring/three@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/core": "https://esm.sh/v135/@react-spring/core@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/shared": "https://esm.sh/v135/@react-spring/shared@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/animated": "https://esm.sh/v135/@react-spring/animated@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/types": "https://esm.sh/v135/@react-spring/types@9.7.3?dev=&target=es2024&external=*",
        "@react-spring/rafz": "https://esm.sh/v135/@react-spring/rafz@9.7.3?dev=&target=es2024&external=*",
        "zustand": "https://esm.sh/v135/zustand@4.5.5?dev=&target=es2024&external=*",
        "zustand/": "https://esm.sh/v135/zustand@4.5.5&dev&target=es2024&external=*/",
        "lodash": "https://esm.sh/v135/lodash@4.17.21?dev=&target=es2024&external=*",
        "lodash.pick": "https://esm.sh/v135/lodash.pick@4.4.0?dev=&target=es2024&external=*",
        "lodash.omit": "https://esm.sh/v135/lodash.omit@4.5.0?dev=&target=es2024&external=*",
        "lodash.clamp": "https://esm.sh/v135/lodash.clamp@4.0.3?dev=&target=es2024&external=*",
        "lodash.merge": "https://esm.sh/v135/lodash.merge@4.6.2?dev=&target=es2024&external=*",
        "lodash.mergewith": "https://esm.sh/v135/lodash.mergewith@4.6.2?dev=&target=es2024&external=*",
        "@babel/runtime/helpers/esm/extends": "https://esm.sh/v135/@babel/runtime@7.24.8/helpers/extends?dev=&target=es2024&external=*",
        "@monogrid/gainmap-js": "https://esm.sh/v135/@monogrid/gainmap-js@3.0.5?dev=&target=es2024&external=*",
        "@preact/signals-core": "https://esm.sh/v135/@preact/signals-core@1.6.1?dev=&target=es2024&external=*",
        "bidi-js": "https://esm.sh/v135/bidi-js@1.0.3?dev=&target=es2024&external=*",
        "camera-controls": "https://esm.sh/v135/camera-controls@2.8.5?dev=&target=es2024&external=*",
        "debounce": "https://esm.sh/v135/debounce@2.1.0?dev=&target=es2024&external=*",
        "detect-gpu": "https://esm.sh/v135/detect-gpu@5.0.40?dev=&target=es2024&external=*",
        "fast-json-patch": "https://esm.sh/v135/fast-json-patch@3.1.1?dev=&target=es2024&external=*",
        "fflate": "https://esm.sh/v135/fflate@0.8.2?dev=&target=es2024&external=*",
        "inline-style-parser": "https://esm.sh/v135/inline-style-parser@0.2.3?dev=&target=es2024&external=*",
        "its-fine": "https://esm.sh/v135/its-fine@1.2.5?dev=&target=es2024&external=*",
        "json-stringify-pretty-compact": "https://esm.sh/v135/json-stringify-pretty-compact@4.0.0?dev=&target=es2024&external=*",
        "maath": "https://esm.sh/v135/maath@0.10.8?dev=&target=es2024&external=*",
        "meshline": "https://esm.sh/v135/meshline@3.1.6?dev=&target=es2024&external=*",
        "node-html-parser": "https://esm.sh/v135/node-html-parser@6.1.13?dev=&target=es2024",
        "object-assign": "https://esm.sh/v135/object-assign@4.1.1?dev=&target=es2024&external=*",
        "potpack": "https://esm.sh/v135/potpack@2.0.0?dev=&target=es2024&external=*",
        "prettier/": "https://esm.sh/v135/prettier@3.3.2&dev&target=es2024&external=*/",
        "prop-types": "https://esm.sh/v135/prop-types@15.8.1?dev=&target=es2024&external=*",
        "scheduler": "https://esm.sh/v135/scheduler@0.23.2?dev=&target=es2024&external=*",
        "stats.js": "https://esm.sh/v135/stats.js@0.17.0?dev=&target=es2024&external=*",
        "stats-gl": "https://esm.sh/v135/stats-gl@2.2.8?dev=&target=es2024&external=*",
        "suspend-react": "https://esm.sh/v135/suspend-react@0.1.3?dev=&target=es2024&external=*",
        "tunnel-rat": "https://esm.sh/v135/tunnel-rat@0.1.2?dev=&target=es2024&external=*",
        "tw-to-css": "https://esm.sh/v135/tw-to-css@0.0.12?dev=&target=es2024&external=*",
        "troika-three-text": "https://esm.sh/v135/troika-three-text@0.49.0?dev=&target=es2024&external=*",
        "troika-three-utils": "https://esm.sh/v135/troika-three-utils@0.49.0?dev=&target=es2024&external=*",
        "troika-worker-utils": "https://esm.sh/v135/troika-worker-utils@0.49.0?dev=&target=es2024&external=*",
        "use-sync-external-store": "https://esm.sh/v135/use-sync-external-store@1.2.2?dev=&target=es2024&external=*",
        "use-sync-external-store/": "https://esm.sh/v135/use-sync-external-store@1.2.2&dev&target=es2024&external=*/",
        "uuid": "https://esm.sh/v135/uuid@10.0.0?dev=&target=es2024&external=*",
        "webgl-sdf-generator": "https://esm.sh/v135/webgl-sdf-generator@1.1.1?dev=&target=es2024&external=*",
        "yoga-layout/": "https://esm.sh/v135/yoga-layout@3.0.4&dev&target=es2024&external=*/",
        "vega": "https://esm.sh/v135/vega@5.30.0?dev=&target=es2024",
        "vega-embed": "https://esm.sh/v135/vega-embed@6.29.0?dev=&target=es2024",
        "react-vega": "https://esm.sh/v135/react-vega@7.6.0?dev=&target=es2024&external=react,vega,vega-embed",
        "d3": "https://esm.sh/v135/d3@7.9.0?dev=&target=es2024",
        "@use-gesture/core": "./use-gesture-fix.zip/use-gesture-core.esm.js",
        "@use-gesture/core/actions": "./use-gesture-fix.zip/use-gesture-core-actions.esm.js",
        "@use-gesture/react": "https://esm.sh/v135/@use-gesture/react@10.3.1?dev=&external=*&target=es2024",
        "@use-gesture/core/types": "https://esm.sh/v135/@use-gesture/core@10.3.1/types?dev=&external=*&target=es2024",
        "@use-gesture/core/utils": "https://esm.sh/v135/@use-gesture/core@10.3.1/utils?dev=&external=*&target=es2024",
        "tldraw": "https://esm.sh/v135/tldraw@3.7.0?dev=&external=react,react-dom,@use-gesture/react,@use-gesture/core,@use-gesture/core/actions&target=es2024",
        "ml-pca": "https://esm.sh/v135/ml-pca@4.1.1?dev=&target=es2024",
        "rdkit": "https://esm.sh/v135/@rdkit/rdkit@2024.3.5-1.0.0?dev=&target=es2024&external=*"
    }
}
</code-fragment><code-fragment data-type="text/javascript" name="MyWebstrates Import Mapping" auto>if (webstrate.importMap) {
    const scriptElement = document.querySelector('#ImportMapping .import-map');
    webstrate.importMap.create();
    webstrate.importMap.content = JSON.parse(scriptElement.innerHTML)
}
</code-fragment></wpm-package><WPM-PACKAGE id="InterFont" name="InterFont"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Adds the Inter font.",
    "dependencies": [],
    "assets": [
        "inter-variable.zip"
    ],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/css" auto name="Inter Font">@font-face {
    font-family: "Inter";
    font-weight: 100 900;
    font-display: swap;
    font-style: normal;
    src: url("inter-variable.zip/inter-variable.woff2") format("woff2-variations"),
         url("inter-variable.zip/inter-variable.woff2") format("woff2");
    src: url("inter-variable.zip/inter-variable.woff2") format("woff2") tech("variations");
}

@font-face {
    font-family: "Inter";
    font-weight: 100 900;
    font-display: swap;
    font-style: italic;
    src: url("inter-variable.zip/inter-variable-Italic.woff2") format("woff2-variations"),
         url("inter-variable.zip/inter-variable-Italic.woff2") format("woff2");
    src: url("inter-variable.zip/inter-variable-Italic.woff2") format("woff2") tech("variations");
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Spatialstrates" name="Spatialstrates"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The Spatialstrates core package and implementation.",
    "dependencies": [
        "varv-repos varv-react",
        "varv-repos varv-location",
        "#InterFont"
    ],
    "assets": [
        "inter-medium.woff"
    ],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Spatialstrates Concepts" auto>{
    "concepts": {
        "SpaceManager": {
            "schema": {
                "placeholder": "string",
                "locationHash": "Space",
                "currentView": { "string": {
                    "enum": [ "3D", "2D" ],
                    "default": "3D"
                }},
                "showBoundary": "boolean",
                "showProjectionPlane": "boolean",
                "depthSensing": "boolean"
            },
            "mappings": {
                "locationHash": [ "memory", "location", "cauldron"],
                "currentView": [ "memory", "cauldron" ],
                "showBoundary": [ "memory", "cauldron" ],
                "showProjectionPlane": [ "memory", "cauldron" ],
                "depthSensing": [ "memory", "cauldron" ]
            }
        },
        "Space": {
            "schema": {
                "name": "string",
                "color": "string",
                "movables": { "array": "Movable" },
                "boundaryOrigin": { "array": {
                    "items": "number",
                    "default": [ 0, 1.5, 0 ]
                }},
                "boundarySize": { "array": {
                    "items": "number",
                    "default": [ 0.5, 0.5, 0.5 ]
                }},
                "projectionPlane": { "array": {
                    "items": "number",
                    "default": [ 0, 1.5, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1 ]
                }}
            }
        },
        "Movable": {
            "schema": {
                "position": { "array": {
                    "items": "number",
                    "default": [ 0, 1.5, 0 ]
                }},
                "rotation": { "array": {
                    "items": "number",
                    "default": [ 0, 0, 0 ]
                }},
                "space": "Space",
                "selected": "boolean",
                "hovered": "boolean",
                "beingDragged": "boolean"
            },
            "mappings": {
                "selected": [ "memory", "cauldron" ],
                "hovered": [ "memory", "cauldron" ],
                "beingDragged": [ "memory", "cauldron" ]
            }
        }
    },
    "dataStores": {
         "location": {
            "type":"location"
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT auto data-type="text/javascript+babel" name="React Reloader">import React from 'react';
import { createRoot } from 'react-dom/client';



// Automatically reload this view if certain other fragments change
const changeFragments = [
    '#Spatialstrates [data-type="text/javascript+babel"]'
];

// Start the app
async function render() {
    if (!window.cachedAppRoot) {
        let element = document.createElement('transient');
        element.id = 'app-root';
        document.body.appendChild(element);
        window.cachedAppRoot = createRoot(element);
    }

    let content = await Fragment.one("#Spatialstrates .spatialstrates").require();
    window.cachedAppRoot.render(React.createElement(content.App));
};

let reloadTimer = null;
const reload = () => {
    clearTimeout(reloadTimer);
    reloadTimer = setTimeout(async function reloadReact() {
        try {
            render();
        } catch (ex) {
            console.log(ex);
        }
    }, 1000);
};

changeFragments.forEach(frag => {
    let lookedUpFragments = Fragment.find(frag);
    lookedUpFragments.forEach((lookedUpFragment) => {
        lookedUpFragment.registerOnFragmentChangedHandler(() => {
            if (fragmentSelfReference.auto) {
                reload();
            }
        });
    });
});

if (VarvEngine) {
    VarvEngine.registerEventCallback('engineReloaded', () => {
        reload();
    });
}

window.reloadApp = () => {
    reload();
};

reload();
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="Spatialstrates" class="spatialstrates">import React from 'react';
const { useMemo, useEffect, useRef } = React;
import { Varv, useProperty } from '#VarvReact';

import { DynamicComponents, useDynamicModules } from '#Spatialstrates .dynamic-components';
import { GlobalEventProvider } from '#Spatialstrates .global-events';
import { SceneView } from '#Spatialstrates .scene-view';
import { CanvasView } from '#Spatialstrates .canvas-view';



function SpaceView() {
    const [currentView] = useProperty('currentView');
    const [currentSpace, setCurrentSpace] = useProperty('locationHash');

    // Initialize the current space if it is not set
    const timeout = useRef(null);
    useEffect(() => {
        if (timeout.current) {
            clearTimeout(timeout.current);
            timeout.current = null;
        }
        if (!currentSpace) {
            timeout.current = setTimeout(async () => {
                const spaceUUIDs = await VarvEngine.getAllUUIDsFromType('Space');

                if (spaceUUIDs.length > 0) {
                    setCurrentSpace(spaceUUIDs[0]);
                } else {
                    setCurrentSpace(await VarvEngine.getConceptFromType('Space').create(null, { name: 'New Space' }));
                }
                timeout.current = null;
            }, 1000);
        }
    }, [currentSpace, setCurrentSpace]);

    // Load shape utils here to cache them between switching views
    const shapeUtils = useDynamicModules('.dynamic-shape-component');

    const view = useMemo(() => {
        switch (currentView) {
            case '3D':
                return &lt;SceneView />;
            case '2D':
                return &lt;CanvasView shapeUtils={shapeUtils} />;
            default:
                return null;
        }
    }, [currentView, shapeUtils]);

    return currentSpace ? view : null;
}

export function App() {
    return &lt;GlobalEventProvider>
        &lt;DynamicComponents selector=".dynamic-gui-component" />
        &lt;Varv concept="SpaceManager">
            &lt;SpaceView />
        &lt;/Varv>
    &lt;/GlobalEventProvider>;
}
</CODE-FRAGMENT><CODE-FRAGMENT auto data-type="text/x-scss" name="Core Style">body {
    height: 100vh;
    margin: 0;
    font-family: 'Inter', sans-serif;
    background: hsl(204, 16%, 94%);

    button,
    input,
    textarea,
    select {
        font-family: 'Inter', sans-serif;
    }
}

#cauldron-edit-button {
    z-index: 100001;
    user-select: none;
    cursor: pointer;

    border-radius: 4px;
    height: 24px;
    box-sizing: unset;
    line-height: 24px;
    font-family: 'Inter', sans-serif;
    padding: 0 8px;
    top: 12px !important;
    right: 12px !important;
    font-weight: 500;
    font-size: 13px;

    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60) !important;
    border: 1px solid #cccccc70;

    &:hover {
        background: rgba(255, 255, 255, .80) !important;
    }
}

.crosshair {
    display: none;
    position: absolute;
    left: 50%;
    top: 50%;
    background: #FF3D00;
    outline: 2px solid #E4E3DF;
    border: 2px solid #231F20;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
}

.spatialstrates-stats {
    top: 48px !important;
    right: 12px !important;
    left: auto !important;

    canvas {
        border-radius: 3px;
    }
}
</CODE-FRAGMENT><CODE-FOLDER id name="Core Components"><CODE-FRAGMENT data-type="text/javascript+babel" class="global-events" name="Global Events">import React from 'react';
const { useRef, useContext, createContext, useCallback, useMemo } = React;



// Send messages between components
if (!window.GlobalEventContext) window.GlobalEventContext = createContext();

export const GlobalEventProvider = ({ children }) => {
    const eventsRef = useRef({});

    const triggerEvent = useCallback((eventName, data) => {
        if (eventsRef.current[eventName]) {
            eventsRef.current[eventName].forEach(callback => callback(data));
        }
    }, []);

    const subscribeEvent = useCallback((eventName, callback) => {
        if (!eventsRef.current[eventName]) {
            eventsRef.current[eventName] = [];
        }
        eventsRef.current[eventName].push(callback);

        // Return unsubscribe function
        return () => {
            eventsRef.current[eventName] = eventsRef.current[eventName].filter(cb => cb !== callback);
        };
    }, []);

    // Memoize context value to avoid unnecessary rerenders
    const value = useMemo(() => ({
        triggerEvent,
        subscribeEvent,
    }), [triggerEvent, subscribeEvent]);

    return (
        &lt;GlobalEventContext.Provider value={value}>
            {children}
        &lt;/GlobalEventContext.Provider>
    );
};


export const useGlobalEvents = () => useContext(GlobalEventContext);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="dynamic-components" name="Dynamic Components">import React from 'react';
const { useEffect, useState, useRef } = React;
import { ErrorBoundary } from 'react-error-boundary';



export function useDynamicModules(selector) {
    const [modules, setModules] = useState([]);
    const fragmentsMap = useRef(new Map());
    const modulesMap = useRef(new Map());
    const handlersMap = useRef(new Map());

    useEffect(() => {
        if (!selector) return;
        const query = cQuery(document).liveQuery(selector, {
            added: async (fragmentElement) => {
                const fragment = Fragment.one(fragmentElement);
                if (!fragment) return;

                fragmentsMap.current.set(fragment.uuid, fragment);

                // Add change handler for this fragment
                const updateHandler = async () => {
                    try {
                        const module = await fragment.require();
                        modulesMap.current.set(fragment.uuid, module['Main']);
                        // Update modules state with all current modules
                        setModules(Array.from(modulesMap.current.values()).filter(Boolean));
                    } catch (error) {
                        console.error(`Error updating module for fragment ${fragment.uuid}:`, error);
                    }
                };

                // Store the handler to be able to remove it later
                handlersMap.current.set(fragment.uuid, updateHandler);

                // Register the handler with the fragment
                fragment.registerOnFragmentChangedHandler(updateHandler);

                // Initial load of the module
                updateHandler();
            },
            removed: (fragmentElement) => {
                const fragment = Fragment.one(fragmentElement);
                if (!fragment) return;

                // Clean up handler
                const handler = handlersMap.current.get(fragment.uuid);
                if (handler) {
                    fragment.unRegisterOnFragmentChangedHandler(handler);
                    handlersMap.current.delete(fragment.uuid);
                }

                // Remove from maps
                fragmentsMap.current.delete(fragment.uuid);
                modulesMap.current.delete(fragment.uuid);

                // Update state
                setModules(Array.from(modulesMap.current.values()).filter(Boolean));
            }
        });

        return () => {
            // Clean up all handlers when unmounting
            for (const [id, fragment] of fragmentsMap.current.entries()) {
                const handler = handlersMap.current.get(id);
                if (handler) {
                    fragment.unRegisterOnFragmentChangedHandler(handler);
                }
            }
            handlersMap.current.clear();
            modulesMap.current.clear();
            fragmentsMap.current.clear();
            query.stop();
        };
    }, []);

    return modules;
}



function DynamicComponent({ fragment }) {
    const [component, setComponent] = useState(null);
    const boundaryRef = useRef(null);

    const updateComponent = async () => {
        if (!fragment) return;
        const module = await fragment.require();
        const Main = module['Main'];
        setComponent(&lt;Main />);
        boundaryRef.current?.resetErrorBoundary();
    };

    useEffect(() => {
        fragment?.registerOnFragmentChangedHandler(updateComponent);
        updateComponent();

        return () => {
            fragment?.unRegisterOnFragmentChangedHandler(updateComponent);
        };
    }, [fragment]);

    return &lt;ErrorBoundary ref={boundaryRef} fallback={null}>
        {component}
    &lt;/ErrorBoundary>;
}

// This is a component that dynamically loads components from fragments
export function DynamicComponents({ selector }) {
    const [output, setOutput] = useState([]);
    const fragmentsMap = useRef(new Map());

    useEffect(() => {
        if (!selector) return;
        const query = cQuery(document).liveQuery(selector, {
            added: async (fragmentElement) => {
                const fragment = Fragment.one(fragmentElement);
                if (!fragment) return;

                fragmentsMap.current.set(fragment.uuid, fragment);
                setOutput(Array.from(fragmentsMap.current.entries()));
            },
            removed: (fragmentElement) => {
                const fragment = Fragment.one(fragmentElement);
                if (!fragment) return;

                fragmentsMap.current.delete(fragment.uuid);
                setOutput(Array.from(fragmentsMap.current.entries()));
            }
        });
        return () => {
            query.stop();
        };
    }, []);

    return output.map((entry) => {
        const [id, fragment] = entry;
        return &lt;DynamicComponent fragment={fragment} key={fragment.uuid} />;
    });
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Text Component" class="text">import React from 'react';
import { Text as TextDrei } from '@react-three/drei';



// https://www.cdnfonts.com/
// Inter: https://fonts.cdnfonts.com/s/19795/Inter-Medium.woff
// Poppins: https://fonts.cdnfonts.com/s/16009/Poppins-Medium.woff



// Set Global Properties for the Text Component
export function Text(props) {
    const { children, ...rest } = props;

    return (
        &lt;TextDrei
            font="inter-medium.woff"
            {...rest}>
            {children}
        &lt;/TextDrei>
    );
}
</CODE-FRAGMENT></CODE-FOLDER><CODE-FOLDER name="Scene View" class="scene-view"><CODE-FOLDER name="Components"><CODE-FRAGMENT data-type="text/javascript+babel" class="camera" name="Camera" id>import React from 'react';
const { useRef, useEffect } = React;
import { Vector3 } from 'three';
import { useFrame } from '@react-three/fiber';
import { PointerLockControls } from '@react-three/drei';



const SPEED = 1.4;

export function CustomCamera() {
    const controls = useRef();
    const crosshair = useRef(document.querySelector('.crosshair'));
    const moveDirection = useRef(new Vector3());

    useEffect(() => {
        window.moduleCameraControls = { controlsRef: controls };

        return () => {
            window.moduleCameraControls = {};
        };
    }, []);

    useEffect(() => {
        const handleKeyDown = (event) => {
            if (!controls.current.isLocked) return;
            switch (event.code) {
                case 'KeyW':
                    moveDirection.current.z = -1;
                    break;
                case 'KeyS':
                    moveDirection.current.z = 1;
                    break;
                case 'KeyA':
                    moveDirection.current.x = -1;
                    break;
                case 'KeyD':
                    moveDirection.current.x = 1;
                    break;
                case 'Space':
                    moveDirection.current.y = 1;
                    break;
                case 'ShiftLeft':
                    moveDirection.current.y = -1;
                    break;
                default:
                    break;
            }
        };

        const handleKeyUp = (event) => {
            switch (event.code) {
                case 'KeyW':
                case 'KeyS':
                    moveDirection.current.z = 0;
                    break;
                case 'KeyA':
                case 'KeyD':
                    moveDirection.current.x = 0;
                    break;
                case 'Space':
                case 'ShiftLeft':
                    moveDirection.current.y = 0;
                    break;
                default:
                    break;
            }
        };

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        controls.current.camera.position.set(0, 1.5, 1);

        return () => {
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
        };
    }, []);

    useFrame((state, delta) => {
        if (moveDirection.current.x != 0 || moveDirection.current.y != 0 || moveDirection.current.z != 0) {
            const timeBasedSpeed = SPEED * delta;
            controls.current.getObject().translateX(moveDirection.current.x * timeBasedSpeed);
            controls.current.getObject().translateY(moveDirection.current.y * timeBasedSpeed * 0.5);
            controls.current.getObject().translateZ(moveDirection.current.z * timeBasedSpeed);
        }
        controls.current.getObject().updateMatrix();
        controls.current.getObject().updateMatrixWorld();
    });

    const handleOnLock = (e) => { crosshair.current.style.display = 'block'; };
    const handleOnUnlock = (e) => { crosshair.current.style.display = 'none'; };

    return &lt;PointerLockControls ref={controls} selector={'.do-not-use'} onLock={handleOnLock} onUnlock={handleOnUnlock} />;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Basic Environment" class="basic-environment">import React from 'react';
import { BackSide } from 'three';
import { Varv, useProperty } from '#VarvReact';

import { Text } from '#Spatialstrates .text';



// Basic scene background with a title and color
function BasicSceneBackground() {
    const [name] = useProperty('name');
    const [color] = useProperty('color');

    return &lt;>
        &lt;Text text={name}
            fontSize={0.14}
            position={[0, 0.001, -0.01]}
            rotation={[-Math.PI * 0.5, 0, 0]}
            color="#444" />
        &lt;mesh scale={200}>
            &lt;sphereGeometry />
            &lt;meshStandardMaterial color={color || '#E5E4E2'} side={BackSide} transparent={true} opacity={0.1} />
        &lt;/mesh>
    &lt;/>;
}

export function BasicSceneEnvironment() {
    return &lt;>
        &lt;gridHelper />
        &lt;color attach="background" args={[0xE5E4E2]} />
        &lt;Varv property="locationHash">
            &lt;BasicSceneBackground />
        &lt;/Varv>
    &lt;/>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Boundary Preview" class="boundary-preview">import React from 'react';
const { useEffect, useState, useMemo, useRef, useCallback } = React;
import { BackSide, MeshStandardMaterial, BoxGeometry, Vector3, Matrix4, Euler, PlaneGeometry } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useFrame } from '@react-three/fiber';
import { useXRInputSourceEvent } from '@react-three/xr';
import { Varv, useProperty } from '#VarvReact';

import { BoundaryResizer, BoundingBox, DragUpdater } from '#Spatialstrates .scene-helpers';



const dragGeometry = new RoundedBoxGeometry(1, 1, 1, 1);
const dragMaterial = new MeshStandardMaterial({ color: '#888' });
const dragScale = 0.05;

export function BoundaryPreview() {
    const [showBoundary] = useProperty('showBoundary');
    const [boundarySize] = useProperty('boundarySize');
    const [boundaryOrigin, setBoundaryOrigin] = useProperty('boundaryOrigin');

    const updatePositionRef = useCallback((currentRef) => {
        currentRef.position.fromArray(boundaryOrigin);
    }, [boundaryOrigin]);

    const updatePositionValue = useCallback(({ position, rotation }) => {
        setBoundaryOrigin(position);
    }, [setBoundaryOrigin]);

    const boundingBox = useMemo(() => {
        return Array.isArray(boundarySize) ? &lt;BoundingBox scale={boundarySize} /> : null;
    }, [boundarySize]);

    return showBoundary ? &lt;>
        &lt;group position={boundaryOrigin}>
            {boundingBox}
            &lt;BoundaryResizer />
        &lt;/group>
        &lt;DragUpdater updateRef={updatePositionRef} updateValue={updatePositionValue} disableRotation={true}>
            &lt;mesh geometry={dragGeometry} material={dragMaterial} scale={dragScale} />
        &lt;/DragUpdater>
    &lt;/> : null;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Projection Plane Preview" class="projection-plane-preview">import React from 'react';
const { useMemo, useCallback } = React;
import { BackSide, MeshStandardMaterial, Vector3, Matrix4, Euler, PlaneGeometry } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useProperty } from '#VarvReact';

import { DragUpdater } from '#Spatialstrates .scene-helpers';



const projectionPlanePreviewGeometry = new PlaneGeometry(2, 1);
const projectionPlanePreviewFrontMaterial = new MeshStandardMaterial({ color: '#0000FF', opacity: 0.5, transparent: true });
const projectionPlanePreviewBackMaterial = new MeshStandardMaterial({ color: '#00FF00', opacity: 0.5, transparent: true, side: BackSide });

const dragGeometry = new RoundedBoxGeometry(1, 1, 1, 1);
const dragMaterial = new MeshStandardMaterial({ color: '#444' });
const dragScale = 0.05;

export function ProjectionPlanePreview({ positionOverride, scaleOverride }) {
    const [showProjectionPlane] = useProperty('showProjectionPlane');
    const [projectionPlane, setProjectionPlane] = useProperty('projectionPlane');

    const plane = useMemo(() => {
        if (!Array.isArray(projectionPlane)) return null;

        const position = positionOverride || projectionPlane.slice(0, 3);
        const xAxis = new Vector3().fromArray(projectionPlane.slice(3, 6));
        const yAxis = new Vector3().fromArray(projectionPlane.slice(6, 9));
        const zAxis = new Vector3().fromArray(projectionPlane.slice(9, 12));

        // Create rotation matrix from orthonormal basis
        const rotationMatrix = new Matrix4().makeBasis(xAxis, yAxis, zAxis);
        const rotation = new Euler().setFromRotationMatrix(rotationMatrix);

        return &lt;group position={position} rotation={rotation} scale={scaleOverride}>
            &lt;mesh geometry={projectionPlanePreviewGeometry} material={projectionPlanePreviewFrontMaterial} />
            &lt;mesh geometry={projectionPlanePreviewGeometry} material={projectionPlanePreviewBackMaterial} />
        &lt;/group>;
    }, [projectionPlane]);

    const updatePositionRef = useCallback((currentRef) => {
        const position = positionOverride || projectionPlane.slice(0, 3);
        const xAxis = new Vector3().fromArray(projectionPlane.slice(3, 6));
        const yAxis = new Vector3().fromArray(projectionPlane.slice(6, 9));
        const zAxis = new Vector3().fromArray(projectionPlane.slice(9, 12));

        const rotationMatrix = new Matrix4().makeBasis(xAxis, yAxis, zAxis);
        const rotation = new Euler().setFromRotationMatrix(rotationMatrix);

        currentRef.position.fromArray(position);
        currentRef.rotation.fromArray(rotation.toArray());
    }, [projectionPlane]);

    const updatePositionValue = useCallback(({ position, rotation }) => {
        const xAxis = new Vector3(1, 0, 0).applyEuler(new Euler(rotation[0], rotation[1], rotation[2]));
        const yAxis = new Vector3(0, 1, 0).applyEuler(new Euler(rotation[0], rotation[1], rotation[2]));
        const zAxis = new Vector3(0, 0, 1).applyEuler(new Euler(rotation[0], rotation[1], rotation[2]));

        setProjectionPlane([...position, ...xAxis.toArray(), ...yAxis.toArray(), ...zAxis.toArray()]);
    }, [projectionPlane, setProjectionPlane]);

    return showProjectionPlane ? &lt;>
        {plane}
        {!scaleOverride ? &lt;DragUpdater updateRef={updatePositionRef} updateValue={updatePositionValue}>
            &lt;mesh geometry={dragGeometry} material={dragMaterial} scale={dragScale} />
        &lt;/DragUpdater> : null}
    &lt;/> : null;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="scene-movables" name="Scene Movables">import React from 'react';
const { useState, useContext, createContext, useMemo, useEffect } = React;
import { useProperty } from '#VarvReact';

import { Main as StickyNote } from '#StickyNote .default';
import { Main as Image } from '#Image .default';
import { Main as Trashcan } from '#Trashcan .default';
import { Main as Flashlight } from '#Flashlight .default';
import { Main as Model } from '#Model .default';
import { Main as Molecule } from '#Molecule .default';

import { Main as ScreenStream } from '#ScreenStream .default';

import { Main as VisPiece } from '#VisPiece .vis-piece';
import { Main as VisGroup } from '#VisPiece .vis-group';
import { Main as VisShelf } from '#VisShelf .default';



if (!window.SceneMovablesContext) window.SceneMovablesContext = createContext();

// One central location to import all custom space components with exception of containers
export const SceneMovablesProvider = ({ children }) => {
    const value = useMemo(() => &lt;>
        &lt;StickyNote />
        &lt;Image />
        &lt;Trashcan />
        &lt;Flashlight />
        &lt;Model />
        &lt;Molecule />

        &lt;ScreenStream />

        &lt;VisPiece />
        &lt;VisGroup />
        &lt;VisShelf />
    &lt;/>, []);

    return (
        &lt;SceneMovablesContext.Provider value={value}>
            {children}
        &lt;/SceneMovablesContext.Provider>
    );
};

export const useSceneMovables = () => useContext(SceneMovablesContext);

// TODO: This clears the existing scope but instead should extend it
function MovableVarvScope({ uuid, children }) {
    const [scope, setScope] = useState([]);
    // const parentScope = useContext(window.VarvScope);

    useEffect(() => {
        if (!uuid) return;
        const asyncLookup = async () => {
            const concept = await VarvEngine.getConceptFromUUID(uuid);
            setScope([new ConceptInstanceBinding(concept, uuid)]);
        };
        asyncLookup();
    }, [uuid]);

    // Adding the parent scope causes flickering again, no idea why
    // return &lt;VarvScope.Provider value={[...parentScope, ...scope]}>
    return &lt;VarvScope.Provider value={scope}>
        {scope.length > 0 ? children : null}
    &lt;/VarvScope.Provider>;
}

// Use this over &lt;Varv property="movables"> to set the correct key for each movable
// Otherwise, it will re-render all movables every time the list changes
export function SpaceMovables({ children }) {
    const [movables] = useProperty('movables');

    return Array.isArray(movables) ? movables.map((movable) => &lt;group key={movable}>
        &lt;MovableVarvScope uuid={movable}>
            {children}
        &lt;/MovableVarvScope>
    &lt;/group>) : null;
}
</CODE-FRAGMENT></CODE-FOLDER><CODE-FRAGMENT data-type="text/javascript+babel" class="scene-view" name="Scene View">import React from 'react';
const { useEffect, useMemo } = React;
import { Canvas, useThree } from '@react-three/fiber';
import { XR, createXRStore, IfInSessionMode, useXRInputSourceState } from '@react-three/xr';
import { Stats, Environment } from '@react-three/drei';
import { Varv, useProperty } from '#VarvReact';

import { DynamicComponents } from '#Spatialstrates .dynamic-components';
import { CustomCamera } from '#Spatialstrates .scene-view .camera';
import { BasicSceneEnvironment } from '#Spatialstrates .scene-view .basic-environment';
import { BoundaryPreview } from '#Spatialstrates .scene-view .boundary-preview';
import { ProjectionPlanePreview } from '#Spatialstrates .scene-view .projection-plane-preview';

import { SceneMovablesProvider, useSceneMovables, SpaceMovables } from '#Spatialstrates .scene-movables';



if (!window.moduleDeviceManager) {
    window.moduleDeviceManager = {};
}

function Scene() {
    // The Quest renders in lower resolution by default, this increases the resolution
    // https://discourse.threejs.org/t/webxr-quality-problems/24603/2
    const { gl } = useThree();
    useEffect(() => {
        gl?.xr?.setFramebufferScaleFactor(2.0);
    }, [gl]);

    // Used for access to the camera in non-React components
    const { camera } = useThree();
    const controllerRight = useXRInputSourceState('controller', 'right');
    const controllerLeft = useXRInputSourceState('controller', 'left');
    const handRight = useXRInputSourceState('hand', 'right');
    const handLeft = useXRInputSourceState('hand', 'left');
    useEffect(() => {
        window.moduleDeviceManager.camera = camera;
    }, [camera]);
    useEffect(() => {
        window.moduleDeviceManager.controllerRight = controllerRight;
    }, [controllerRight]);
    useEffect(() => {
        window.moduleDeviceManager.controllerLeft = controllerLeft;
    }, [controllerLeft]);
    useEffect(() => {
        window.moduleDeviceManager.handRight = handRight;
    }, [handRight]);
    useEffect(() => {
        window.moduleDeviceManager.handLeft = handLeft;
    }, [handLeft]);

    const sceneComponents = useSceneMovables();

    return &lt;>
        {/* Basic Lighting */}
        &lt;Environment preset="city" />

        {/* Grid, Color Background, and Space Title */}
        &lt;IfInSessionMode deny={['immersive-ar']}>
            &lt;BasicSceneEnvironment />
        &lt;/IfInSessionMode>

        {/* Desktop Camera and Stats */}
        &lt;IfInSessionMode deny={['immersive-ar', 'immersive-vr']}>
            &lt;CustomCamera />
            &lt;Stats className="spatialstrates-stats" />
        &lt;/IfInSessionMode>

        {/* Global Dynamic Componants */}
        &lt;DynamicComponents selector=".dynamic-scene-component" />

        {/* Context of Current Space */}
        &lt;Varv property="locationHash">
            &lt;BoundaryPreview />
            &lt;ProjectionPlanePreview />
            &lt;SpaceMovables>
                {sceneComponents}
            &lt;/SpaceMovables>
        &lt;/Varv>
    &lt;/>;
}

export function SceneView() {
    const [depthSensing] = useProperty('depthSensing');

    // https://github.com/pmndrs/xr/blob/1793fe3a4ecf07a30ea98ff2585811d3100d6b51/packages/xr/src/init.ts#L54
    const store = useMemo(() => {
        return createXRStore({
            frameRate: 'low',
            handTracking: true,
            hitTest: true,
            depthSensing: depthSensing,
            domOverlay: document.querySelector('#app-root')
        });
    }, [depthSensing]);

    useEffect(() => {
        window.xrStore = store;
    }, [store]);

    return &lt;>
        &lt;div className="crosshair">&lt;/div>
        &lt;Canvas dpr={2}
            gl={{ preserveDrawingBuffer: true, localClippingEnabled: true }}
            mode="concurrent"
            shadows
            style={{ touchAction: 'none' }}>
            &lt;XR store={store}>
                &lt;SceneMovablesProvider>
                    &lt;Scene />
                &lt;/SceneMovablesProvider>
            &lt;/XR>
        &lt;/Canvas>
    &lt;/>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="Scene Helpers" class="scene-helpers">import React from 'react';
const { useEffect, useState, useMemo, useRef, useCallback } = React;
import { MeshStandardMaterial, BoxGeometry, Matrix4 } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useFrame } from '@react-three/fiber';
import { useXRInputSourceEvent } from '@react-three/xr';
import { useProperty } from '#VarvReact';

import { getDeviceFromInputEvent } from '#Spatialstrates .device-helpers';



const DRAG_UPDATER_WRITEBACK_TIMEOUT = 33;

export function DragUpdater({ children, updateRef, updateValue, disableRotation = false, upright = false }) {
    const dragRef = useRef();
    const [currentXRInputSource, setCurrentXRInputSource] = useState(null);
    const [beingDragged, setBeingDragged] = useState(false);
    const fastWritebackTimeout = useRef();
    const grabbingController = useRef();
    const previousTransform = useMemo(() => new Matrix4(), []);
    const parentTransform = useMemo(() => new Matrix4(), []);
    const finalTransform = useMemo(() => new Matrix4(), []);

    const updatePreviousTransform = useCallback(() => {
        parentTransform.copy(dragRef.current.parent.matrixWorld).invert();
        previousTransform
            .copy(parentTransform) // Convert to parent space
            .multiply(grabbingController.current.matrixWorld) // Get controller in parent space
            .invert(); // Invert for future use
    }, []);

    const selectAndStartDrag = useCallback((e) => {
        if (e) e.stopPropagation();
        if (grabbingController.current) return;
        setBeingDragged(true);
        setCurrentXRInputSource(e?.nativeEvent?.inputSource);

        if (dragRef && dragRef.current) {
            grabbingController.current = getDeviceFromInputEvent(e);
            if (grabbingController.current) {
                updatePreviousTransform();
            }
        }
    }, []);

    const stopDrag = useCallback((e) => {
        if (e) e.stopPropagation();
        setBeingDragged(false);
        setCurrentXRInputSource(null);

        if (grabbingController.current) {
            grabbingController.current = undefined;
            updateValue({
                position: dragRef.current.position.toArray(),
                rotation: dragRef.current.rotation.toArray()
            });
        }
    }, [currentXRInputSource]);

    useXRInputSourceEvent(currentXRInputSource, 'selectend', stopDrag, [stopDrag, currentXRInputSource]);
    useEffect(() => {
        document.body.addEventListener('pointerup', stopDrag);
        return () => {
            document.body.removeEventListener('pointerup', stopDrag);
        };
    }, [stopDrag]);

    useFrame(() => {
        if (!beingDragged && dragRef.current) {
            updateRef(dragRef.current);
            dragRef.current.updateMatrix();
            return;
        }
        if (!grabbingController.current) return;

        finalTransform
            .copy(parentTransform) // Convert to parent space
            .multiply(grabbingController.current.matrixWorld); // Get controller in parent space

        dragRef.current.applyMatrix4(previousTransform); // Apply inverse of original position
        dragRef.current.applyMatrix4(finalTransform); // Apply new position

        if (disableRotation) {
            dragRef.current.rotation.fromArray([0, 0, 0]);
        } else if (upright) {
            dragRef.current.rotation.fromArray([0, dragRef.current.rotation.y, 0]);
        }

        dragRef.current.updateMatrix();
        updatePreviousTransform();

        // Update the Varv state
        if (!fastWritebackTimeout.current) {
            updateValue({
                position: dragRef.current.position.toArray(),
                rotation: dragRef.current.rotation.toArray()
            });
            fastWritebackTimeout.current = setTimeout(() => {
                fastWritebackTimeout.current = null;
            }, DRAG_UPDATER_WRITEBACK_TIMEOUT);
        }
    });

    return &lt;group ref={dragRef} onPointerDown={selectAndStartDrag} onPointerUp={stopDrag}>
        {children}
    &lt;/group>
};



const resizerGeometry = new RoundedBoxGeometry(1, 1, 1, 1);
const resizerMaterial = new MeshStandardMaterial({ color: '#444' });
const resizerScale = 0.05;

export function BoundaryResizer() {
    const [boundarySize, setBoundarySize] = useProperty('boundarySize');

    const updateSizeRef = useCallback((currentRef) => {
        if (!Array.isArray(boundarySize)) return;
        currentRef.position.fromArray([boundarySize[0] / 2, boundarySize[1] / 2, boundarySize[2] / 2]);
    }, [boundarySize]);

    const updateSizeValue = useCallback(({ position, rotation }) => {
        setBoundarySize(position.map((v) => Math.abs(v * 2)));
    }, [setBoundarySize]);

    return &lt;DragUpdater updateRef={updateSizeRef} updateValue={updateSizeValue} disableRotation={true}>
        &lt;mesh geometry={resizerGeometry} material={resizerMaterial} scale={resizerScale} />
    &lt;/DragUpdater>
}



const boundingBoxGeometry = new BoxGeometry(1, 1, 1, 1);
const dummyBoundingBoxMaterial = new MeshStandardMaterial({ color: '#888', opacity: 0.3, transparent: true });

export function BoundingBox({ position, scale, dummy = false }) {
    return &lt;group position={position} scale={scale}>
        {dummy ? &lt;mesh geometry={boundingBoxGeometry} material={dummyBoundingBoxMaterial} /> : null}
        &lt;lineSegments>
            &lt;edgesGeometry args={[boundingBoxGeometry]} />
            &lt;lineBasicMaterial color="#333" />
        &lt;/lineSegments>
    &lt;/group>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="device-helpers" name="Device Helpers">import { Vector3 } from 'three';



export const devicePositionWithOffset = (device, offset = 0) => {
    let x = 0;
    let y = 0;
    let z = 0;

    if (device) {
        let position = device.position;

        // If the distance option is given we move the position in the direction the device is looking
        if (offset != 0) {
            const direction = new Vector3(0, 0, -1);
            direction.normalize();
            direction.applyQuaternion(device.quaternion);

            position = new Vector3();
            position.copy(device.position).add(direction.multiplyScalar(offset));
        }

        x = position.x;
        y = position.y;
        z = position.z;
    }

    return [x, y, z];
};

export const deviceRotation = (device) => {
    let x = 0;
    let y = 0;
    let z = 0;

    if (device) {
        x = device.rotation._x;
        y = device.rotation._y;
        z = device.rotation._z;
    }

    return [x, y, z];
};

export const getDeviceFromInputEvent = (e) => {
    let device;

    if (e.nativeEvent?.inputSource?.handedness) {
        if (e.nativeEvent?.inputSource?.hand === null) {
            device = e.nativeEvent.inputSource.handedness === 'right' ? window.moduleDeviceManager.controllerRight?.object : window.moduleDeviceManager.controllerLeft?.object;
        } else {
            device = e.nativeEvent.inputSource.handedness === 'right' ? window.moduleDeviceManager.handRight?.object : window.moduleDeviceManager.handLeft?.object;
        }
    } else {
        device = window.moduleDeviceManager.camera;
    }

    if (!device) {
        console.warn('No device found.');
        return;
    } else {
        return device;
    }
};
</CODE-FRAGMENT></CODE-FOLDER><CODE-FOLDER name="Canvas View" class="canvas-view"><CODE-FOLDER name="Components"><CODE-FRAGMENT data-type="text/javascript+babel" name="Movable Canvas Controller" class="movable-canvas-controller">import React from 'react';
const { useState, useEffect, useRef, useCallback } = React;
import { useEditor } from 'tldraw';
import { useProperty } from '#VarvReact';

import { useTransform } from '#Spatialstrates .movable';
import { projectToCanvas, updatePointFromCanvas, CANVAS_SCALE } from '#Spatialstrates .projection-helpers';



const FAST_WRITEBACK_TIMEOUT = 33;

export function MovableCanvasController({ parent }) {
    const [conceptUUID] = useProperty('concept::uuid');
    const [conceptType] = useProperty('concept::name');
    const [shapeID, setShapeID] = useState();
    const transform = useTransform();
    const [projectionPlane] = useProperty('projectionPlane');
    const [boundaryOrigin] = useProperty('boundaryOrigin');

    const editor = useEditor();
    const isBeingUpdated = useRef(false);

    // Dragging: Varv -> tldraw
    // Create or update the shape when the position of the concept changes
    const updateTldrawFromVarv = useCallback(() => {
        if (!editor) return;
        if (shapeID == undefined) return;
        if (!transform.initialized) return;
        if (!editor.shapeUtils.hasOwnProperty('Movable')) return;
        if (isBeingUpdated.current) return;

        const typeWithFallback = editor.shapeUtils.hasOwnProperty(conceptType) ? conceptType : 'Movable';

        let x;
        let y;

        if (parent) {
            // Center the projection plane around the origin of the boundary when in a container
            [x, y] = projectToCanvas(transform.position, [
                boundaryOrigin[0],
                boundaryOrigin[1],
                boundaryOrigin[2],
                projectionPlane[3],
                projectionPlane[4],
                projectionPlane[5],
                projectionPlane[6],
                projectionPlane[7],
                projectionPlane[8],
                projectionPlane[9],
                projectionPlane[10],
                projectionPlane[11]
            ]);
        } else {
            [x, y] = projectToCanvas(transform.position, projectionPlane);
        }

        if (!editor.getShape(shapeID)) {
            editor.createShape({
                id: shapeID,
                type: typeWithFallback,
                x: x * CANVAS_SCALE,
                y: -y * CANVAS_SCALE,
                props: {
                    conceptUUID: conceptUUID,
                    conceptType: conceptType,
                    zIndex: transform.position[2]
                },
                parentId: parent || 'page:page'
            });
        } else {
            isBeingUpdated.current = true;
            editor.updateShape({
                id: shapeID,
                type: typeWithFallback,
                x: x * CANVAS_SCALE,
                y: -y * CANVAS_SCALE,
                props: {
                    zIndex: transform.position[2]
                },
                parentId: parent || 'page:page'
            });
            isBeingUpdated.current = false;
        }
    }, [editor, shapeID, conceptUUID, transform.initialized, projectionPlane, boundaryOrigin]);

    // Set the shape ID based on the concept UUID
    useEffect(() => {
        if (!conceptUUID) return;
        setShapeID('shape:' + conceptUUID);

        const concept = VarvEngine.getConceptFromUUID(conceptUUID);
        if (!concept) return;

        const updatePosition = async (changeUUID) => {
            if (changeUUID !== conceptUUID) return;
            updateTldrawFromVarv();
        };

        updatePosition(conceptUUID);
        concept.getProperty('position').addUpdatedCallback(updatePosition);

        return () => {
            if (!concept) return;
            try {
                concept.getProperty('position').removeUpdatedCallback(updatePosition);
            } catch (e) {
                // Do nothing, this can crash when the VarvEngine restarts
            }
        };
    }, [conceptUUID, updateTldrawFromVarv]);

    // Removing: Varv -> tldraw
    // Delete the shape when the component unmounts/the concept is deleted
    useEffect(() => {
        return () => {
            if (!editor) return;
            if (shapeID == undefined) return;

            editor.deleteShape(shapeID);
        };
    }, [editor, shapeID]);

    // Dragging + Removing: tldraw -> Varv
    // Listen for changes to the shape and update the concept properties
    const fastWritebackTimeout = useRef();
    useEffect(() => {
        if (!editor) return;
        if (shapeID == undefined) return;
        if (!boundaryOrigin) return;
        if (!projectionPlane) return;

        const removeChangeHandler = editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {
            if (isBeingUpdated.current) return;
            if (next.id !== shapeID) return;

            // Update the Varv state
            if (!fastWritebackTimeout.current) {
                isBeingUpdated.current = true;

                let newX, newY, newZ;
                if (parent) {
                    [newX, newY, newZ] = updatePointFromCanvas(transform.position, [next.x / CANVAS_SCALE, -next.y / CANVAS_SCALE], [
                        boundaryOrigin[0],
                        boundaryOrigin[1],
                        boundaryOrigin[2],
                        projectionPlane[3],
                        projectionPlane[4],
                        projectionPlane[5],
                        projectionPlane[6],
                        projectionPlane[7],
                        projectionPlane[8],
                        projectionPlane[9],
                        projectionPlane[10],
                        projectionPlane[11]
                    ]);
                } else {
                    [newX, newY, newZ] = updatePointFromCanvas(transform.position, [next.x / CANVAS_SCALE, -next.y / CANVAS_SCALE], projectionPlane);
                }

                if (newX !== transform.position[0] || newY !== transform.position[1] || newZ !== transform.position[2]) {
                    transform.position = [newX, newY, newZ];
                }
                isBeingUpdated.current = false;
                fastWritebackTimeout.current = setTimeout(() => {
                    fastWritebackTimeout.current = null;
                }, FAST_WRITEBACK_TIMEOUT);
            }
        });

        const removeDeleteHandler = editor.sideEffects.registerAfterDeleteHandler('shape', async (shape) => {
            if (shape.id !== shapeID) return;
            // FIXME: This sometimes triggers and deletes all elements
            // console.log('FIXME: deleting concept: ' + shape.props.conceptUUID);
            // const concept = await VarvEngine.getConceptFromUUID(shape.props.conceptUUID);
            // await concept?.delete(shape.props.conceptUUID);
        });

        return () => {
            removeChangeHandler();
            removeDeleteHandler();
        };
    }, [editor, shapeID, projectionPlane, boundaryOrigin]);
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="title-text" name="Title Text">import React from 'react';
const { useEffect } = React;
import { useEditor } from 'tldraw';
import { useProperty } from '#VarvReact';



const TITLE_TEXT_ID = 'shape:space-title';

export function TitleText() {
    const editor = useEditor();
    const [name] = useProperty('name');

    useEffect(() => {
        if (!editor) return;

        editor.createShape({
            id: TITLE_TEXT_ID,
            type: 'text',
            opacity: 0.25,
            props: {
                text: name || '',
                textAlign: 'middle',
                font: 'sans',
                color: 'black'
            }
        });

        editor.sendToBack([TITLE_TEXT_ID]);

        editor.updateShape({
            id: TITLE_TEXT_ID,
            isLocked: true
        });

        return () => {
            editor.updateShape({
                id: TITLE_TEXT_ID,
                isLocked: false
            });
            editor.deleteShape('space-title');
        };
    }, [editor, name]);
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="boundary-preview" name="Boundary Preview">import React from 'react';
const { useEffect, useRef } = React;
import { useEditor } from 'tldraw';
import { useProperty } from '#VarvReact';

import { projectToCanvas, updatePointFromCanvas, CANVAS_SCALE } from '#Spatialstrates .projection-helpers';



const BOUNDARY_PREVIEW_ID = 'shape:space-boundary-preview';
const BOUNDARY_PREVIEW_WRITEBACK_TIMEOUT = 33;

export function BoundaryPreview() {
    const [showBoundary] = useProperty('showBoundary');
    const [boundarySize, setBoundarySize] = useProperty('boundarySize');
    const [boundaryOrigin, setBoundaryOrigin] = useProperty('boundaryOrigin');
    const [projectionPlane] = useProperty('projectionPlane');
    const editor = useEditor();
    const isBeingUpdated = useRef(false);

    // Varv -> tldraw
    useEffect(() => {
        if (!editor) return;
        if (!showBoundary) {
            editor.deleteShape(BOUNDARY_PREVIEW_ID);
            return;
        }
        if (!boundarySize || !boundaryOrigin) return;
        if (!projectionPlane) return;
        if (isBeingUpdated.current) return;

        let [x, y] = projectToCanvas(boundaryOrigin, projectionPlane);
        x = x - boundarySize[0] / 2;
        y = y + boundarySize[1] / 2;

        isBeingUpdated.current = true;
        if (!editor.getShape(BOUNDARY_PREVIEW_ID)) {
            editor.createShape({
                id: BOUNDARY_PREVIEW_ID,
                type: 'geo',
                opacity: 0.5,
                x: x * CANVAS_SCALE,
                y: -y * CANVAS_SCALE,
                props: {
                    w: boundarySize[0] * CANVAS_SCALE,
                    h: boundarySize[1] * CANVAS_SCALE,
                    color: 'black',
                    geo: 'rectangle'
                }
            });
            editor.sendToBack([BOUNDARY_PREVIEW_ID]);
        } else {
            editor.updateShape({
                id: BOUNDARY_PREVIEW_ID,
                x: x * CANVAS_SCALE,
                y: -y * CANVAS_SCALE,
                props: {
                    w: boundarySize[0] * CANVAS_SCALE,
                    h: boundarySize[1] * CANVAS_SCALE
                }
            });
        }
        isBeingUpdated.current = false;

        return () => {
            editor.deleteShape(BOUNDARY_PREVIEW_ID);
        };
    }, [showBoundary, boundarySize, boundaryOrigin, projectionPlane, editor]);

    // tldraw -> Varv
    const fastWritebackTimeout = useRef();
    useEffect(() => {
        if (!editor) return;
        if (!boundarySize || !boundaryOrigin) return;
        if (!projectionPlane) return;

        const updateChangeHandler = editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {
            if (isBeingUpdated.current) return;
            if (prev.id !== BOUNDARY_PREVIEW_ID) return;
            if (next.id !== BOUNDARY_PREVIEW_ID) return;
            if (prev.props.w === next.props.w
                && prev.props.h === next.props.h
                && prev.x === next.x
                && prev.y === next.y) return;

            // Update the Varv state
            if (!fastWritebackTimeout.current) {
                isBeingUpdated.current = true;

                setBoundarySize([
                    next.props.w / CANVAS_SCALE,
                    next.props.h / CANVAS_SCALE,
                    boundarySize[2]
                ]);

                const [x, y, z] = updatePointFromCanvas(boundaryOrigin, [
                    next.x / CANVAS_SCALE + next.props.w / CANVAS_SCALE / 2,
                    -next.y / CANVAS_SCALE - next.props.h / CANVAS_SCALE / 2
                ], projectionPlane);
                setBoundaryOrigin([x, y, z]);

                isBeingUpdated.current = false;
                fastWritebackTimeout.current = setTimeout(() => {
                    fastWritebackTimeout.current = null;
                }, BOUNDARY_PREVIEW_WRITEBACK_TIMEOUT);
            }
        });

        return () => {
            updateChangeHandler();
        };
    }, [editor, boundarySize, boundaryOrigin, setBoundarySize, setBoundaryOrigin, projectionPlane]);
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Drag Detector" class="drag-detector">import React from 'react';
const { useEffect, useRef } = React;
import { useEditor } from 'tldraw';

import { useGlobalEvents } from '#Spatialstrates .global-events';
import { shapeToConceptId } from '#Spatialstrates .projection-helpers';



// FIXME: This is not perfect, as it also detects creating selections as dragging
export function DragDetector() {
    const editor = useEditor();
    const { triggerEvent, subscribeEvent } = useGlobalEvents();
    const wasDragging = useRef(false);

    useEffect(() => {
        const detectDragging = editor.store.listen((change) => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            const isDragging = editor.inputs.isDragging;

            if (isDragging && !wasDragging.current && selectedShapeIds.length > 0) {
                selectedShapeIds.forEach(async (shapeId) => {
                    const uuid = shapeToConceptId(shapeId);
                    if (!await VarvEngine.getConceptFromUUID(uuid)) return;
                    await VarvEngine.getConceptFromUUID(uuid).setPropertyValue(uuid, 'beingDragged', true);
                    triggerEvent('drag-start', { target: uuid });
                });
                wasDragging.current = true;
            } else if (!isDragging && wasDragging.current && selectedShapeIds.length > 0) {
                selectedShapeIds.forEach(async (shapeId) => {
                    const uuid = shapeToConceptId(shapeId);
                    if (!await VarvEngine.getConceptFromUUID(uuid)) return;
                    VarvEngine.getConceptFromUUID(uuid).setPropertyValue(uuid, 'beingDragged', false);
                    triggerEvent('drag-end', { target: uuid });
                });
                wasDragging.current = false;
            }
        });

        return () => {
            detectDragging();
        };
    }, [editor]);
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Selected Hovered Detector" class="selected-hovered-detector">import React from 'react';
const { useEffect } = React;
import { useEditor } from 'tldraw';



export function SelectedHoveredDetector() {
    const editor = useEditor();

    useEffect(() => {
        if (!editor) return;
        const movableConcepts = VarvEngine.getAllImplementingConceptNames('Movable');

        const detectSelectionChange = async (e) => {
            // FIXME: If not filtered this might be bad for performance
            // if (e.type != 'pointer') return;

            const selectedShapes = editor.getSelectedShapeIds();
            const hoveredShape = editor.getHoveredShapeId();

            const allMovableInstances = await VarvEngine.lookupInstances(movableConcepts);

            allMovableInstances.forEach(async (instance) => {
                await VarvEngine.getConceptFromUUID(instance).setPropertyValue(instance, 'selected', selectedShapes.includes('shape:' + instance));
                await VarvEngine.getConceptFromUUID(instance).setPropertyValue(instance, 'hovered', hoveredShape == 'shape:' + instance);
            });
        };

        editor.on('event', detectSelectionChange);
        return () => { editor.off('event', detectSelectionChange); };
    }, [editor]);
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Color Forwarder" class="color-forwarder">import React from 'react';
const { useEffect } = React;
import { useProperty } from '#VarvReact';



export function ColorForwarder({ setColor }) {
    const [color] = useProperty('color');

    useEffect(() => {
        setColor(color);
    }, [color]);
}
</CODE-FRAGMENT></CODE-FOLDER><CODE-FRAGMENT data-type="text/javascript+babel" name="Canvas View" class="canvas-view">import React from 'react';
const { useState, useMemo } = React;
import { Tldraw } from 'tldraw';
import { Varv } from '#VarvReact';

import { DynamicComponents } from '#Spatialstrates .dynamic-components';
import { SelectedHoveredDetector } from '#Spatialstrates .canvas-view .selected-hovered-detector';
import { DragDetector } from '#Spatialstrates .canvas-view .drag-detector';
import { ColorForwarder } from '#Spatialstrates .canvas-view .color-forwarder';
import { TitleText } from '#Spatialstrates .canvas-view .title-text';
import { BoundaryPreview } from '#Spatialstrates .canvas-view .boundary-preview';
import { MovableCanvasController } from '#Spatialstrates .movable-canvas-controller';



export function CanvasView({ shapeUtils }) {
    const [color, setColor] = useState('');

    const tldraw = useMemo(() => (
        &lt;Tldraw key={Math.random()} // Prevent dynamic components to use an old editor
            shapeUtils={shapeUtils}
            components={{
                ContextMenu: null,
                ActionsMenu: null,
                HelpMenu: null,
                // ZoomMenu: null,
                MainMenu: null,
                // Minimap: null,
                StylePanel: null,
                PageMenu: null,
                // NavigationPanel: null,
                // Toolbar: null,
                KeyboardShortcutsDialog: null,
                QuickActions: null,
                // HelperButtons: null,
                DebugPanel: null,
                DebugMenu: null,
                SharePanel: null,
                // MenuPanel: null,
                // TopPanel: null,
                // CursorChatBubble: null,
                // RichTextToolbar: null,
                // Dialogs: null,
                // Toasts: null
            }}
            overrides={{
                // Disable the default keyboard shortcuts
                tools(_app, tools) {
                    const newTools = {};
                    for (const key in tools) {
                        newTools[key] = { ...tools[key], kbd: 'ctrl+shift+alt+meta+0' };
                    }
                    return newTools;
                },
                actions(_app, actions) {
                    const newActions = {};
                    for (const key in actions) {
                        newActions[key] = { ...actions[key], kbd: 'ctrl+shift+alt+meta+0' };
                    }
                    return newActions;
                },
            }}
            options={{ maxPages: 1 }}
            onMount={(editor) => {
                window.tldrawEditor = editor;
                setTimeout(() => {
                    editor.zoomToFit();
                    editor.resetZoom();
                }, 100);
            }}>

            &lt;SelectedHoveredDetector />
            &lt;DragDetector />
            &lt;DynamicComponents selector=".dynamic-canvas-component" />

            &lt;Varv property="locationHash">
                &lt;TitleText />
                &lt;BoundaryPreview />
                &lt;ColorForwarder setColor={setColor} />
                &lt;Varv property="movables">
                    &lt;MovableCanvasController />
                &lt;/Varv>
            &lt;/Varv>
        &lt;/Tldraw>
    ), [shapeUtils]);

    return &lt;div className={`tldraw-canvas color-${color || 'default'}`}>
        {tldraw}
    &lt;/div>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="projection-helpers" name="Projection Helpers">import { Vector3 } from 'three';
import { PCA } from 'ml-pca';



export const CANVAS_SCALE = 500;

export const shapeToConceptId = shapeId => shapeId.replace('shape:', '');

export const projectToCanvas = (point3D, projectionPlane) => {
    const point = new Vector3().fromArray(point3D);
    const origin = new Vector3().fromArray(projectionPlane.slice(0, 3));
    const xAxis = new Vector3().fromArray(projectionPlane.slice(3, 6));
    const yAxis = new Vector3().fromArray(projectionPlane.slice(6, 9));

    const pointToOrigin = point.clone().sub(origin);

    const x = pointToOrigin.dot(xAxis);
    const y = pointToOrigin.dot(yAxis);

    return [x, y];
};

export const projectToScene = (point2D, projectionPlane) => {
    const origin = new Vector3().fromArray(projectionPlane.slice(0, 3));
    const xAxis = new Vector3().fromArray(projectionPlane.slice(3, 6));
    const yAxis = new Vector3().fromArray(projectionPlane.slice(6, 9));

    const point = origin.clone()
        .add(xAxis.clone().multiplyScalar(point2D[0]))
        .add(yAxis.clone().multiplyScalar(point2D[1]));

    return point.toArray();
};

export const projectToCanvasIn3D = (point3D, projectionPlane) => {
    const point = new Vector3().fromArray(point3D);
    const origin = new Vector3().fromArray(projectionPlane.slice(0, 3));
    const xAxis = new Vector3().fromArray(projectionPlane.slice(3, 6));
    const yAxis = new Vector3().fromArray(projectionPlane.slice(6, 9));
    const zAxis = new Vector3().fromArray(projectionPlane.slice(9, 12));

    const pointToOrigin = point.clone().sub(origin);

    const x = pointToOrigin.dot(xAxis);
    const y = pointToOrigin.dot(yAxis);
    const z = pointToOrigin.dot(zAxis);

    return [x, y, z];
};

export const updatePointFromCanvas = (oldPoint3D, newPoint2D, projectionPlane) => {
    const oldPoint = new Vector3().fromArray(oldPoint3D);
    const origin = new Vector3().fromArray(projectionPlane.slice(0, 3));
    const xAxis = new Vector3().fromArray(projectionPlane.slice(3, 6));
    const yAxis = new Vector3().fromArray(projectionPlane.slice(6, 9));
    const zAxis = new Vector3().fromArray(projectionPlane.slice(9, 12));

    // move the point in 3D space along the projection plane keeping the distance to it
    const pointToOrigin = oldPoint.clone().sub(origin);

    const newPoint = origin.clone()
        .add(xAxis.clone().multiplyScalar(newPoint2D[0]))
        .add(yAxis.clone().multiplyScalar(newPoint2D[1]))
        .add(zAxis.clone().multiplyScalar(pointToOrigin.dot(zAxis)));

    return newPoint.toArray();
};


export const getSpaceManagerUUID = async () => {
    const spaceManagerUUIDs = await VarvEngine.getAllUUIDsFromType('SpaceManager');
    if (spaceManagerUUIDs.length === 0) {
        console.log('No space manager found');
        return false;
    }
    return spaceManagerUUIDs[0];
};

export const getCurrentSpaceUUID = async () => {
    const spaceManagerUUID = await getSpaceManagerUUID();
    const spaceUUID = await VarvEngine.getConceptFromType('SpaceManager').getPropertyValue(spaceManagerUUID, 'locationHash');
    if (!spaceUUID) {
        console.log('No space found');
        return false;
    }
    return spaceUUID;
};

export const computeProjectionPlaneUsingPCA = async (spaceUUIDParam, movableUUIDsParam) => {
    const spaceUUID = spaceUUIDParam || await getCurrentSpaceUUID();

    let movablesUUIDs = movableUUIDsParam;
    if (!movablesUUIDs) {
        movablesUUIDs = await VarvEngine.getConceptFromType('Space').getPropertyValue(spaceUUID, 'movables');
    }

    if (!Array.isArray(movablesUUIDs) || movablesUUIDs.length &lt; 3) {
        console.log('Not enough movables to calculate projection plane');
        return false;
    }

    const movables = await Promise.all(movablesUUIDs.map(uuid => {
        const concept = VarvEngine.getConceptFromUUID(uuid);
        return {
            uuid,
            type: concept.name,
            position: concept.getPropertyValue(uuid, 'position'),
            rotation: concept.getPropertyValue(uuid, 'rotation')
        };
    }));

    const points = movables.map(movable => [movable.position[0], movable.position[1], movable.position[2]]);

    // Calculate centroid
    const origin = points.reduce((acc, point) => {
        return acc.map((coord, i) => coord + point[i] / points.length);
    }, [0, 0, 0]);

    // Project points onto X-Z plane and center them
    const xzPoints = points.map(point => [
        point[0] - origin[0],
        point[2] - origin[2]  // Now using only X and Z components
    ]);

    // Calculate PCA on X-Z projected points to get main horizontal direction
    const xzPca = new PCA(xzPoints);
    const xzComponents = xzPca.getEigenvectors().to2DArray();

    // Get main horizontal direction (in X-Z plane)
    const mainDir = new Vector3(xzComponents[0][0], 0, xzComponents[0][1]).normalize();

    // Center the original points for full 3D PCA
    const centeredPoints = points.map(point =>
        point.map((coord, i) => coord - origin[i])
    );

    // Calculate full 3D PCA
    const pca = new PCA(centeredPoints);
    const components = pca.getEigenvectors().to2DArray();

    // Get the second principal component
    const secondComponent = new Vector3(...components[1]);

    // Project second component to be orthogonal to mainDir
    const secondDir = secondComponent.clone()
        .sub(mainDir.clone().multiplyScalar(secondComponent.dot(mainDir)))
        .normalize();

    // Calculate normal from main and second directions
    const normal = new Vector3().crossVectors(mainDir, secondDir);

    // Ensure secondDir has positive Y component (points somewhat upward)
    if (secondDir.y &lt; 0) {
        secondDir.multiplyScalar(-1);
        normal.multiplyScalar(-1);
    }

    // Check if normal is pointing away from scene origin
    const originToPlane = new Vector3().fromArray(origin);
    if (normal.dot(originToPlane) > 0) {
        // Flip x and z axes to maintain right-handed coordinate system
        mainDir.multiplyScalar(-1);
        normal.multiplyScalar(-1);
    }

    const newProjectionPlane = [
        ...origin,
        ...mainDir.toArray(),
        ...secondDir.toArray(),
        ...normal.toArray()
    ];

    VarvEngine.getConceptFromType('Space').setPropertyValue(spaceUUID, 'projectionPlane', newProjectionPlane);

    return newProjectionPlane;
};

export const getProjectionPlaneFromTransform = async (spaceUUID, position, rotation) => {
    const normal = new Vector3(0, 1, 0).applyEuler(new Euler().fromArray(rotation));
    const origin = new Vector3().fromArray(position);

    const mainDir = new Vector3(1, 0, 0).applyEuler(new Euler().fromArray(rotation));
    const secondDir = new Vector3().crossVectors(normal, mainDir);

    const newProjectionPlane = [
        ...origin.toArray(),
        ...mainDir.toArray(),
        ...secondDir.toArray(),
        ...normal.toArray()
    ];

    VarvEngine.getConceptFromType('Space').setPropertyValue(spaceUUID, 'projectionPlane', newProjectionPlane);

    return newProjectionPlane;
};


export const toggleProjectionPlanePreview = async () => {
    const spaceManagerUUID = await getSpaceManagerUUID();

    const showProjectionPlane = await VarvEngine.getConceptFromType('SpaceManager').getPropertyValue(spaceManagerUUID, 'showProjectionPlane');

    VarvEngine.getConceptFromType('SpaceManager').setPropertyValue(spaceManagerUUID, 'showProjectionPlane', !showProjectionPlane);
};

export const toggleBoundaryPreview = async () => {
    const spaceManagerUUID = await getSpaceManagerUUID();

    const showBoundary = await VarvEngine.getConceptFromType('SpaceManager').getPropertyValue(spaceManagerUUID, 'showBoundary');

    VarvEngine.getConceptFromType('SpaceManager').setPropertyValue(spaceManagerUUID, 'showBoundary', !showBoundary);
};

export const resetProjectionPlane = async (spaceUUIDParam) => {
    const spaceUUID = spaceUUIDParam || await getCurrentSpaceUUID();

    VarvEngine.getConceptFromType('Space').setPropertyValue(spaceUUID, 'projectionPlane', [ 0, 1.5, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1 ]);
};

export const resetBoundary = async (spaceUUIDParam) => {
    const spaceUUID = spaceUUIDParam || await getCurrentSpaceUUID();

    VarvEngine.getConceptFromType('Space').setPropertyValue(spaceUUID, 'boundaryOrigin', [ 0, 1.5, 0 ]);
    VarvEngine.getConceptFromType('Space').setPropertyValue(spaceUUID, 'boundarySize', [ 0.5, 0.5, 0.5 ]);
};
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="tldraw Styles" auto>@import url("https://esm.sh/tldraw@3.7.0/tldraw.css");

.tldraw-canvas {
    display: block;
    position: fixed;
    inset: 0;
    z-index: 99900;
    top: 0px;
    left: 0px;
    right: 0px;
    bottom: 80px;
    border-bottom: 4px solid hsl(204, 16%, 85%);

    &.color-red {
        border-color: hsl(0, 60%, 85%);
    }
    &.color-green {
        border-color: hsl(120, 60%, 85%);
    }
    &.color-blue {
        border-color: hsl(204, 60%, 85%);
    }
    &.color-yellow {
        border-color: hsl(60, 60%, 85%);
    }
    &.color-purple {
        border-color: hsl(270, 60%, 85%);
    }
    &.color-orange {
        border-color: hsl(30, 60%, 85%);
    }
    &.color-pink {
        border-color: hsl(310, 60%, 85%);
    }

    &.color-red .tl-background {
        background-color: hsl(0, 25%, 96%);
    }
    &.color-green .tl-background {
        background-color: hsl(120, 25%, 96%);
    }
    &.color-blue .tl-background {
        background-color: hsl(204, 25%, 96%);
    }
    &.color-yellow .tl-background {
        background-color: hsl(60, 25%, 96%);
    }
    &.color-purple .tl-background {
        background-color: hsl(270, 25%, 96%);
    }
    &.color-orange .tl-background {
        background-color: hsl(30, 25%, 96%);
    }
    &.color-pink .tl-background {
        background-color: hsl(310, 25%, 96%);
    }

    /* FIXME: This only hides buttons, tools, shortcuts, and so on are still working */
    .tlui-button__tool[data-value="draw"],
    .tlui-button__tool[data-value="eraser"],
    .tlui-button__tool[data-value="text"],
    .tlui-button__tool[data-value="arrow"],
    .tlui-button__tool[data-value="note"],
    .tlui-button__tool[data-value="asset"],
    .tlui-button__tool[data-value="rectangle"],
    .tlui-button__tool.tlui-toolbar__overflow {
        display: none;
    }
}
</CODE-FRAGMENT></CODE-FOLDER><CODE-FOLDER name="Movable"><CODE-FRAGMENT data-type="text/javascript+babel" name="Movable Component" class="movable">import React from 'react';
const { useRef, useState, useEffect, useCallback, useMemo } = React;
import { Matrix4 } from 'three';
import { useFrame } from '@react-three/fiber';
import { useXRInputSourceEvent } from '@react-three/xr';
import { useProperty } from '#VarvReact';

import { useGlobalEvents } from '#Spatialstrates .global-events';
import { getDeviceFromInputEvent } from '#Spatialstrates .device-helpers';
import { deselectMovables } from '#Spatialstrates .movable-helpers';



const FAST_WRITEBACK_TIMEOUT = 33;
const SLOW_WRITEBACK_TIMEOUT = 500;

export const SELECTED_COLOR_PRIMARY = 'hsl(14, 100%, 50%)';
export const SELECTED_COLOR_SECONDARY = 'hsl(26, 100%, 60%)';
export const HOVERED_SELECTED_COLOR_PRIMARY = 'hsl(14, 100%, 65%)';
export const HOVERED_SELECTED_COLOR_SECONDARY = 'hsl(26, 100%, 75%)';



// Generic wrapper for Movable concept properties into ThreeJS transform properties
export function useTransform() {
    const [uuid] = useProperty('concept::uuid');

    const positionRef = useRef([0, 0, 0]);
    const rotationRef = useRef([0, 0, 0]);
    const [initialized, setInitialized] = useState(false);

    useEffect(() => {
        if (!uuid) return;
        const concept = VarvEngine.getConceptFromUUID(uuid);
        if (!concept) return;

        const updatePosition = async (changeUUID) => {
            if (changeUUID !== uuid) return;
            positionRef.current = await concept.getPropertyValue(uuid, 'position');
            if (!initialized) setInitialized(true);
        };

        const updateRotation = async (changeUUID) => {
            if (changeUUID !== uuid) return;
            rotationRef.current = await concept.getPropertyValue(uuid, 'rotation');
        };

        updatePosition(uuid);
        updateRotation(uuid);

        concept.getProperty('position').addUpdatedCallback(updatePosition);
        concept.getProperty('rotation').addUpdatedCallback(updateRotation);

        return () => {
            if (!concept) return;
            try {
                concept.getProperty('position').removeUpdatedCallback(updatePosition);
                concept.getProperty('rotation').removeUpdatedCallback(updateRotation);
            } catch (e) {
                // Do nothing, this can crash when the VarvEngine restarts
            }
        };
    }, [uuid, initialized]);

    const setPosition = useCallback((pos) => {
        const concept = VarvEngine.getConceptFromUUID(uuid);
        if (!concept) return;
        if (!Array.isArray(pos)) return;
        concept.setPropertyValue(uuid, 'position', [pos[0], pos[1], pos[2]], true);
    }, [uuid]);

    const setRotation = useCallback((rot) => {
        const concept = VarvEngine.getConceptFromUUID(uuid);
        if (!concept) return;
        if (!Array.isArray(rot)) return;
        concept.setPropertyValue(uuid, 'rotation', [rot[0], rot[1], rot[2]], true);
    }, [uuid]);

    const transform = useMemo(() => {
        return {
            get initialized() { return initialized },
            get position() { return positionRef.current },
            set position(pos) { setPosition(pos) },
            get rotation() { return rotationRef.current },
            set rotation(rot) { setRotation(rot) },
        };
    }, [setPosition, setRotation, initialized]);

    return transform;
}

/**
 * Make a group of children moveable with a handle that allows
 * selecting them and dragging them around
 */
export function Movable({ children, handle, upright = true, onDragStart, onDragEnd, onDragging }) {
    const transform = useTransform();
    const [selected, setSelected] = useProperty('selected');
    const [hovered, setHovered] = useProperty('hovered');
    const [beingDragged, setBeingDragged] = useProperty('beingDragged');

    // Setup refs for dragging
    const grabbingController = useRef();
    const dragRef = useRef();

    // Setup dragging devices
    const [currentXRInputSource, setCurrentXRInputSource] = useState(null);
    const [uuid] = useProperty('concept::uuid');

    const { triggerEvent, subscribeEvent } = useGlobalEvents();

    // Update the transformation of the movable
    const previousTransform = useMemo(() => new Matrix4(), []);
    const parentTransform = useMemo(() => new Matrix4(), []);
    const finalTransform = useMemo(() => new Matrix4(), []);
    const fastWritebackTimeout = useRef();
    const slowWritebackTimeout = useRef();

    const updatePreviousTransform = useCallback(() => {
        parentTransform.copy(dragRef.current.parent.matrixWorld).invert();
        previousTransform
            .copy(parentTransform) // Convert to parent space
            .multiply(grabbingController.current.matrixWorld) // Get controller in parent space
            .invert(); // Invert for future use
    }, []);

    // Handle input events for dragging and hovering
    const selectAndStartDrag = useCallback((e) => {
        if (e) e.stopPropagation();
        if (grabbingController.current) return;
        setSelected(true);
        setBeingDragged(true);
        setCurrentXRInputSource(e?.nativeEvent?.inputSource);

        deselectMovables();

        if (dragRef && dragRef.current) {
            triggerEvent('drag-start', { target: uuid });
            if (typeof onDragStart === 'function') onDragStart();
            grabbingController.current = getDeviceFromInputEvent(e);
            if (grabbingController.current) {
                updatePreviousTransform();
            }
        }
    }, [setSelected, setBeingDragged]);

    const remoteInitiateDrag = useCallback((payload) => {
        if (payload.target === uuid) selectAndStartDrag(payload.e);
    }, [uuid]);

    useEffect(() => {
        const unsubscribe = subscribeEvent('initiate-drag', remoteInitiateDrag);
        return () => unsubscribe();
    }, [remoteInitiateDrag, subscribeEvent, uuid]);

    const stopDrag = useCallback((e) => {
        if (e) e.stopPropagation();
        setBeingDragged(false);
        setCurrentXRInputSource(null);

        if (grabbingController.current) {
            grabbingController.current = undefined;
            transform.position = dragRef.current.position.toArray();
            transform.rotation = dragRef.current.rotation.toArray();
            triggerEvent('drag-end', { target: uuid });
            if (typeof onDragEnd === 'function') onDragEnd();
        }
    }, [setBeingDragged, currentXRInputSource, setCurrentXRInputSource]);

    const startHover = useCallback((e) => {
        if (e) e.stopPropagation();
        setHovered(true);
    }, [setHovered]);

    const stopHover = useCallback(() => {
        setHovered(false);
    }, [setHovered]);

    // Always stop dragging when anything lets go
    useXRInputSourceEvent(currentXRInputSource, 'selectend', stopDrag, [stopDrag, currentXRInputSource]);
    useEffect(() => {
        document.body.addEventListener('pointerup', stopDrag);
        return () => {
            document.body.removeEventListener('pointerup', stopDrag);
        };
    }, [stopDrag]);

    useFrame(() => {
        if (!beingDragged && dragRef.current) {
            dragRef.current.position.fromArray(transform.position);
            dragRef.current.rotation.fromArray(transform.rotation);
            dragRef.current.updateMatrix();
            return;
        }
        if (!grabbingController.current) return;

        finalTransform
            .copy(parentTransform) // Convert to parent space
            .multiply(grabbingController.current.matrixWorld); // Get controller in parent space

        dragRef.current.applyMatrix4(previousTransform); // Apply inverse of original position
        dragRef.current.applyMatrix4(finalTransform); // Apply new position

        if (upright) {
            dragRef.current.rotation.reorder('YXZ');
            dragRef.current.rotation.x = 0;
            dragRef.current.rotation.z = 0;
        }
        dragRef.current.updateMatrix();
        updatePreviousTransform();

        // Update the Varv state
        if (!fastWritebackTimeout.current) {
            transform.position = dragRef.current.position.toArray();
            fastWritebackTimeout.current = setTimeout(() => {
                fastWritebackTimeout.current = null;
            }, FAST_WRITEBACK_TIMEOUT);
        }
        if (!slowWritebackTimeout.current) {
            transform.rotation = dragRef.current.rotation.toArray();
            if (typeof onDragging === 'function') onDragging();
            slowWritebackTimeout.current = setTimeout(() => {
                slowWritebackTimeout.current = null;
            }, SLOW_WRITEBACK_TIMEOUT);
        }
    });

    // useEffect(() => {
    //     if (upright && dragRef.current && transform.initialized) {
    //         dragRef.current.rotation.reorder('YXZ');
    //         dragRef.current.rotation.x = 0;
    //         dragRef.current.rotation.z = 0;
    //         dragRef.current.updateMatrix();
    //         transform.rotation = dragRef.current.rotation.toArray();
    //     }
    // }, [upright, transform.initialized]);

    return &lt;group ref={dragRef}
        matrixAutoUpdate={false}
        matrixWorldAutoUpdate={true}>
        &lt;group
            onPointerDown={selectAndStartDrag}
            onPointerUp={stopDrag}
            onPointerOver={startHover}
            onPointerOut={stopHover}>
            {handle}
        &lt;/group>
        {children}
    &lt;/group>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Movable Shape" class="movable-shape dynamic-shape-component">import React from 'react';
const { useState, useEffect } = React;
import { HTMLContainer, Rectangle2d, BaseBoxShapeUtil, T } from 'tldraw';

import { CANVAS_SCALE } from '#Spatialstrates .projection-helpers';



// Workaround because &lt;Varv target="conceptUUID" /> causes flicker
export function MovableVarvScope({ shape, children }) {
    const [scope, setScope] = useState([]);

    useEffect(() => {
        if (!shape.props.conceptUUID) return;
        const asyncLookup = async () => {
            const concept = await VarvEngine.getConceptFromUUID(shape.props.conceptUUID);
            setScope([new ConceptInstanceBinding(concept, shape.props.conceptUUID)]);
        };
        asyncLookup();
    }, [shape.props.conceptUUID]);

    return &lt;VarvScope.Provider value={scope}>
        {scope.length > 0 ? children : null}
    &lt;/VarvScope.Provider>;
}

export class MovableShapeUtil extends BaseBoxShapeUtil {
    static type = 'Movable';
    static props = {
        conceptUUID: T.string,
        conceptType: T.string,
        w: T.number,
        h: T.number,
        zIndex: T.number
    };

    getDefaultProps() {
        return {
            conceptUUID: false,
            conceptType: false,
            w: CANVAS_SCALE * 0.25,
            h: CANVAS_SCALE * 0.25,
            zIndex: 0
        };
    }

    canBind = () => true;
    canCrop = () => false;
    canEdit = () => false;
    canResize = () => false;
    canScroll = () => false;
    canSnap = () => false;
    isAspectRatioLocked = () => true;
    hideRotateHandle = () => true;

    getGeometry(shape) {
        return new Rectangle2d({
            x: -shape.props.w / 2,
            y: -shape.props.h / 2,
            width: shape.props.w,
            height: shape.props.h,
            isFilled: true,
        });
    }

    indicator(shape) {
        return &lt;rect
            x={-shape.props.w / 2}
            y={-shape.props.h / 2}
            width={shape.props.w}
            height={shape.props.h}
        />;
    }

    component(shape) {
        return &lt;HTMLContainer style={{
            transform: 'translate(-50%, -50%)',
            width: shape.props.w + 'px',
            height: shape.props.h + 'px',
            backgroundColor: 'white',
            borderRadius: '8px',
            border: '1px solid red',
            padding: '8px'
        }}>Unsupported Movable of type {shape.props.conceptType}&lt;/HTMLContainer>;
    }
}

export const Main = MovableShapeUtil;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Movable Helpers" class="movable-helpers">import { Vector3 } from 'three';

import { devicePositionWithOffset, deviceRotation } from '#Spatialstrates .device-helpers';
import { getSpaceManagerUUID, getCurrentSpaceUUID, updatePointFromCanvas, CANVAS_SCALE } from '#Spatialstrates .projection-helpers';



const selectedFilter = FilterAction.constructFilter({
    property: 'selected',
    equals: true
});

const selectedAndNotDraggedFilter = FilterAction.constructFilter({
    and: [
        {
            property: 'selected',
            equals: true
        },
        {
            property: 'beingDragged',
            equals: false
        }
    ]
});

export const deselectMovables = async () => {
    const ids = await VarvEngine.getAllUUIDsFromType('Movable', true);
    for (const id of ids) {
        if (await selectedAndNotDraggedFilter.filter({ target: id })) {
            await VarvEngine.getConceptFromUUID(id).setPropertyValue(id, 'selected', false);
        }
    }
};

export const createMovable = async (conceptName, properties = {}) => {
    const spaceManager = await getSpaceManagerUUID();
    const currentSpace = await getCurrentSpaceUUID();
    const currentView = await VarvEngine.getConceptFromType('SpaceManager').getPropertyValue(spaceManager, 'currentView');
    let x, y, z, rx, ry, rz = 0;

    if (currentView === '3D') {
        [x, y, z] = devicePositionWithOffset(window.moduleDeviceManager.camera, 0.5);
        [rx, ry, rz] = deviceRotation(window.moduleDeviceManager.camera);
    } else if (currentView === '2D' && window.tldrawEditor) {
        const pageCoordinates = window.tldrawEditor.screenToPage({
            x: (window.innerWidth / 2),
            y: (window.innerHeight / 2)
        });

        const projectionPlane = await VarvEngine.getConceptFromType('Space').getPropertyValue(currentSpace, 'projectionPlane');

        [x, y, z] = updatePointFromCanvas(
            [projectionPlane[0], projectionPlane[1], projectionPlane[2]],
            [pageCoordinates.x / CANVAS_SCALE, -pageCoordinates.y / CANVAS_SCALE],
            projectionPlane
        );

        // const xAxis = new Vector3().fromArray(projectionPlane.slice(3, 6));
        // const yAxis = new Vector3().fromArray(projectionPlane.slice(6, 9));
        const zAxis = new Vector3().fromArray(projectionPlane.slice(9, 12));

        // const rotationMatrix = new Matrix4().makeBasis(xAxis, yAxis, zAxis);
        // const rotation = new Euler().setFromRotationMatrix(rotationMatrix);
        // [rx, ry, rz] = [rotation.x, rotation.y, rotation.z];

        // Always spawn new movables upright
        zAxis.y = 0;
        zAxis.normalize();
        const angleY = Math.atan2(zAxis.x, zAxis.z);
        [rx, ry, rz] = [0, angleY, 0];
    }

    const currentMovables = await VarvEngine.getConceptFromType('Space').getPropertyValue(currentSpace, 'movables');

    await deselectMovables();
    const concept = await VarvEngine.getConceptFromType(conceptName);
    const newInstance = await concept.create(null, {
        selected: true,
        position: [x, y, z],
        rotation: [rx, ry, rz],
        space: currentSpace,
        ...properties
    });
    await VarvEngine.getConceptFromType('Space').setPropertyValue(currentSpace, 'movables', [...currentMovables, newInstance]);

    return newInstance;
};

export const deleteMovable = async (uuid) => {
    // TODO: Take care of nested concepts like in DashSpace groups
    await VarvEngine.getConceptFromUUID(uuid).delete(uuid);
};

export const deleteSelectedMovable = async () => {
    const uuids = await VarvEngine.getAllUUIDsFromType('Movable', true);
    for (const uuid of uuids) {
        if (await selectedFilter.filter({ target: uuid })) {
            await deleteMovable(uuid);
        }
    }
};

export const cloneSelectedMovable = async () => {
    const ids = await VarvEngine.getAllUUIDsFromType('Movable', true);
    for (const id of ids) {
        if (await selectedFilter.filter({ target: id })) {
            // FIXME: This only creates a shallow clone right now
            const newClone = await VarvEngine.getConceptFromUUID(id).clone(id, false);

            // Move the clone up a bit so it doesn't overlap with the original
            const oldPosition = await VarvEngine.getConceptFromUUID(newClone).getPropertyValue(newClone, 'position');
            await VarvEngine.getConceptFromUUID(newClone).setPropertyValue(newClone, 'position', [
                oldPosition[0],
                oldPosition[1] + 0.2,
                oldPosition[2]
            ]);

            // Add to the space as the original
            const space = await VarvEngine.getConceptFromUUID(newClone).getPropertyValue(newClone, 'space');
            const currentMovables = await VarvEngine.getConceptFromType('Space').getPropertyValue(space, 'movables');
            await VarvEngine.getConceptFromType('Space').setPropertyValue(space, 'movables', [...currentMovables, newClone]);

            // Set the new clone as selected
            await deselectMovables();
            await VarvEngine.getConceptFromUUID(newClone).setPropertyValue(newClone, 'selected', true);
        }
    }
};
</CODE-FRAGMENT></CODE-FOLDER></WPM-PACKAGE><WPM-PACKAGE name="Container" id="Container"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The container element for Spatialstrates' spatial transclusion.",
    "dependencies": [
        "#Spatialstrates"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" auto name="Container Concepts">{
    "concepts": {
        "Container": {
            "schema": {
                "containedSpace": "Space",
                "clippingMode": { "string": {
                    "enum": [ "hide", "show", "fade" ],
                    "default": "hide"
                }},
                "collaborationLevel": { "string": {
                    "enum": [ "close", "loose", "none" ],
                    "default": "close"
                }}
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Container Component" class="default dynamic-scene-component">import React from 'react';
const { useState, useMemo, useEffect, useCallback } = React;
import { MeshStandardMaterial, Vector3, Matrix4, Box3, Euler } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { Varv, useProperty } from '#VarvReact';

import { useGlobalEvents } from '#Spatialstrates .global-events';
import { Text } from '#Spatialstrates .text';
import { useSceneMovables, SpaceMovables } from '#Spatialstrates .scene-movables';
import { BoundingBox, BoundaryResizer } from '#Spatialstrates .scene-helpers';
import { ProjectionPlanePreview } from '#Spatialstrates .projection-plane-preview';
import { ClippedMovablesFilter, moveMovableToNewSpace } from '#Container .container-helpers';
import { Movable, useTransform } from '#Spatialstrates .movable';

import { Text as UIText, Root, Container as UIContainer } from '@react-three/uikit';
import { Defaults, Card, Button, Checkbox, List, ListItem, Input } from '@react-three/uikit-apfel';
import { transcribeAudio } from '#AIHelpers .default';



const frameGeometry = new RoundedBoxGeometry(1, 0.005, 1, 1);

const frameColoredMap = new Map();
frameColoredMap.set('default', new MeshStandardMaterial({ color: '#888', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredMap.set('red', new MeshStandardMaterial({ color: '#ff6666', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredMap.set('green', new MeshStandardMaterial({ color: '#66ff66', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredMap.set('blue', new MeshStandardMaterial({ color: '#6666ff', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredMap.set('yellow', new MeshStandardMaterial({ color: '#ffff66', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredMap.set('purple', new MeshStandardMaterial({ color: '#ff66ff', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredMap.set('orange', new MeshStandardMaterial({ color: '#ff9966', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredMap.set('pink', new MeshStandardMaterial({ color: '#ff66cc', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));

const frameColoredHoveredMap = new Map();
frameColoredHoveredMap.set('default', new MeshStandardMaterial({ color: '#aaa', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredHoveredMap.set('red', new MeshStandardMaterial({ color: '#ff8888', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredHoveredMap.set('green', new MeshStandardMaterial({ color: '#88ff88', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredHoveredMap.set('blue', new MeshStandardMaterial({ color: '#8888ff', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredHoveredMap.set('yellow', new MeshStandardMaterial({ color: '#ffff88', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredHoveredMap.set('purple', new MeshStandardMaterial({ color: '#ff88ff', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredHoveredMap.set('orange', new MeshStandardMaterial({ color: '#ffaa88', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));
frameColoredHoveredMap.set('pink', new MeshStandardMaterial({ color: '#ff88cc', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.66 }));

const frameColoredSelectedMap = new Map();
frameColoredSelectedMap.set('default', new MeshStandardMaterial({ color: '#666', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredSelectedMap.set('red', new MeshStandardMaterial({ color: '#ff4444', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredSelectedMap.set('green', new MeshStandardMaterial({ color: '#44ff44', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredSelectedMap.set('blue', new MeshStandardMaterial({ color: '#4444ff', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredSelectedMap.set('yellow', new MeshStandardMaterial({ color: '#ffff44', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredSelectedMap.set('purple', new MeshStandardMaterial({ color: '#ff44ff', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredSelectedMap.set('orange', new MeshStandardMaterial({ color: '#ff8844', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredSelectedMap.set('pink', new MeshStandardMaterial({ color: '#ff44cc', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));

const frameColoredHoveredSelectedMap = new Map();
frameColoredHoveredSelectedMap.set('default', new MeshStandardMaterial({ color: '#888', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredHoveredSelectedMap.set('red', new MeshStandardMaterial({ color: '#ff6666', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredHoveredSelectedMap.set('green', new MeshStandardMaterial({ color: '#66ff66', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredHoveredSelectedMap.set('blue', new MeshStandardMaterial({ color: '#6666ff', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredHoveredSelectedMap.set('yellow', new MeshStandardMaterial({ color: '#ffff66', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredHoveredSelectedMap.set('purple', new MeshStandardMaterial({ color: '#ff66ff', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredHoveredSelectedMap.set('orange', new MeshStandardMaterial({ color: '#ff9966', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));
frameColoredHoveredSelectedMap.set('pink', new MeshStandardMaterial({ color: '#ff66cc', metalness: 0.2, roughness: 0.5, transparent: true, opacity: 0.8 }));

const dummyFrameMaterial = new MeshStandardMaterial({ color: '#444', metalness: 0.2, roughness: 0.5 });
const dummyFrameMaterialHovered = new MeshStandardMaterial({ color: '#666', metalness: 0.2, roughness: 0.5 });
const dummyFrameMaterialSelected = new MeshStandardMaterial({ color: '#222', metalness: 0.2, roughness: 0.5 });
const dummyFrameMaterialHoveredSelected = new MeshStandardMaterial({ color: '#444', metalness: 0.2, roughness: 0.5 });


function SpaceOption({ currentSpace }) {
    const [containedSpace, setContainedSpace] = useProperty('containedSpace');
    const [uuid] = useProperty('concept::uuid');
    const [name] = useProperty('name');

    return currentSpace != uuid ? &lt;ListItem selected={containedSpace === uuid} onClick={() => setContainedSpace(uuid)}>
        &lt;UIText>{name || 'No Name'}&lt;/UIText>
    &lt;/ListItem> : null;
}

function SpaceRenamer() {
    const [name, setName] = useProperty('name');
    const [listening, setListening] = useState(false);

    async function updateName() {
        if (listening) return;

        setListening(true);
        const newName = await transcribeAudio(5000, false, () => { setListening(false); });
        if (newName) setName(newName);
    }

    return &lt;UIContainer flexDirection="row" gap={8}>
        &lt;UIText>Rename&lt;/UIText>
        &lt;Button platter onClick={updateName}>
            &lt;UIText textAlign="center">{listening ? 'Speak Now' : 'Record New Name'}&lt;/UIText>
        &lt;/Button>
        &lt;Input value={name || ''} onValueChange={setName} placeholder="Space Name" />
    &lt;/UIContainer>;
}

function SpaceColorChanger() {
    const [color, setColor] = useProperty('color');

    return &lt;UIContainer flexDirection="row" gap={8}>
        &lt;UIText>Color&lt;/UIText>
        &lt;List type="plain" flexDirection="row" gap={8}>
            &lt;ListItem selected={color === ''} onClick={() => setColor('')}>
                &lt;UIText>Default&lt;/UIText>
            &lt;/ListItem>
            &lt;ListItem selected={color === 'red'} onClick={() => setColor('red')}>
                &lt;UIText>Red&lt;/UIText>
            &lt;/ListItem>
            &lt;ListItem selected={color === 'green'} onClick={() => setColor('green')}>
                &lt;UIText>Green&lt;/UIText>
            &lt;/ListItem>
            &lt;ListItem selected={color === 'blue'} onClick={() => setColor('blue')}>
                &lt;UIText>Blue&lt;/UIText>
            &lt;/ListItem>
            &lt;ListItem selected={color === 'yellow'} onClick={() => setColor('yellow')}>
                &lt;UIText>Yellow&lt;/UIText>
            &lt;/ListItem>
            &lt;ListItem selected={color === 'purple'} onClick={() => setColor('purple')}>
                &lt;UIText>Purple&lt;/UIText>
            &lt;/ListItem>
            &lt;ListItem selected={color === 'orange'} onClick={() => setColor('orange')}>
                &lt;UIText>Orange&lt;/UIText>
            &lt;/ListItem>
            &lt;ListItem selected={color === 'pink'} onClick={() => setColor('pink')}>
                &lt;UIText>Pink&lt;/UIText>
            &lt;/ListItem>
        &lt;/List>
    &lt;/UIContainer>;
}

// FIXME: This is not nice, make it a condition in the other menu
function ContainerMenuBasic() {
    const [space] = useProperty('space');
    const [containedSpace, setContainedSpace] = useProperty('containedSpace');

    const createNewSpace = useCallback(async () => {
        const newSpaceUUID = await VarvEngine.getConceptFromType('Space').create(null, {
            name: 'New Space'
        });
        setTimeout(() => {
            setContainedSpace(newSpaceUUID);
        }, 100);
    }, [setContainedSpace]);

    return &lt;group position={[0, -0.5 * 0.5, 0.5 * 0.5]} rotation={[-Math.PI * 0.1, 0, 0]}>
        &lt;Defaults>
            &lt;Root anchorX="center" anchorY="top" flexDirection="column" pixelSize={0.0005} padding={15}>
                &lt;Card borderRadius={24} padding={24} gap={16} flexDirection="column">
                    &lt;Button platter onPointerDown={() => createNewSpace()}>
                        &lt;UIText>Create New Space&lt;/UIText>
                    &lt;/Button>
                    &lt;List type="plain" flexDirection="row" gap={8}>
                        &lt;Varv concept="Space">
                            &lt;SpaceOption currentSpace={space} />
                        &lt;/Varv>
                    &lt;/List>
                &lt;/Card>
            &lt;/Root>
        &lt;/Defaults>
    &lt;/group>;
}

function ContainerMenu() {
    const [boundarySize] = useProperty('boundarySize');
    const [space] = useProperty('space');
    const [containedSpace, setContainedSpace] = useProperty('containedSpace');
    const [clippingMode, setClippingMode] = useProperty('clippingMode');
    const [collaborationLevel, setCollaborationLevel] = useProperty('collaborationLevel');

    const createNewSpace = useCallback(async () => {
        const newSpaceUUID = await VarvEngine.getConceptFromType('Space').create(null, {
            name: 'New Space'
        });
        setContainedSpace(newSpaceUUID);
    }, [setContainedSpace]);

    const enterSpace = useCallback(async () => {
        if (!containedSpace) return;
        const spaceManagerIds = await VarvEngine.getAllUUIDsFromType('SpaceManager');
        if (spaceManagerIds.length === 0) return;
        await VarvEngine.getConceptFromType('SpaceManager').setPropertyValue(spaceManagerIds[0], 'locationHash', containedSpace);
    }, [containedSpace]);

    return Array.isArray(boundarySize) ? &lt;group position={[0, -0.5 * boundarySize[1], 0.5 * boundarySize[2]]} rotation={[-Math.PI * 0.1, 0, 0]}>
        &lt;Defaults>
            &lt;Root anchorX="center" anchorY="top" flexDirection="column" pixelSize={0.0005} padding={15}>
                &lt;Card borderRadius={24} padding={24} gap={16} flexDirection="column">
                    &lt;Button platter onPointerDown={() => createNewSpace()}>
                        &lt;UIText>Create New Space&lt;/UIText>
                    &lt;/Button>
                    &lt;UIContainer flexDirection="row" gap={8}>
                        &lt;UIText>Space&lt;/UIText>
                        &lt;List type="plain" flexDirection="row" gap={8}>
                            &lt;ListItem selected={containedSpace === ''} onClick={() => setContainedSpace('')}>
                                &lt;UIText>None&lt;/UIText>
                            &lt;/ListItem>
                            &lt;Varv concept="Space">
                                &lt;SpaceOption currentSpace={space} />
                            &lt;/Varv>
                        &lt;/List>
                    &lt;/UIContainer>
                    &lt;Varv property="containedSpace">
                        &lt;SpaceRenamer />
                        &lt;SpaceColorChanger />
                        &lt;Button platter onClick={enterSpace}>
                            &lt;UIText>Enter Space&lt;/UIText>
                        &lt;/Button>
                    &lt;/Varv>
                    &lt;UIContainer flexDirection="row" gap={8}>
                        &lt;UIText>Clipping Mode&lt;/UIText>
                        &lt;List type="plain" flexDirection="row" gap={8}>
                            &lt;ListItem selected={clippingMode === 'hide'} onClick={() => setClippingMode('hide')}>
                                &lt;UIText>Hide Outside&lt;/UIText>
                            &lt;/ListItem>
                            &lt;ListItem selected={clippingMode === 'show'} onClick={() => setClippingMode('show')}>
                                &lt;UIText>Show All&lt;/UIText>
                            &lt;/ListItem>
                        &lt;/List>
                    &lt;/UIContainer>
                    &lt;UIContainer flexDirection="row" gap={8}>
                        &lt;UIText>Collaboration&lt;/UIText>
                        &lt;List type="plain" flexDirection="row" gap={8}>
                            &lt;ListItem selected={collaborationLevel === 'close'} onClick={() => setCollaborationLevel('close')}>
                                &lt;UIText>On&lt;/UIText>
                            &lt;/ListItem>
                            {/* &lt;ListItem selected={collaborationLevel === 'loose'} onClick={() => setCollaborationLevel('loose')}>
                                &lt;UIText>Loose Collaboration&lt;/UIText>
                            &lt;/ListItem> */}
                            &lt;ListItem selected={collaborationLevel === 'none'} onClick={() => setCollaborationLevel('none')}>
                                &lt;UIText>Off&lt;/UIText>
                            &lt;/ListItem>
                        &lt;/List>
                    &lt;/UIContainer>
                &lt;/Card>
            &lt;/Root>
        &lt;/Defaults>
    &lt;/group> : null;
}

function ContainerSizeAndNameForwarder({ setSizeContainer, setNameContainer, setColorContainer }) {
    const [boundarySize] = useProperty('boundarySize');
    const [name] = useProperty('name');
    const [color] = useProperty('color');

    useEffect(() => {
        if (!Array.isArray(boundarySize)) return;
        setSizeContainer(boundarySize);
    }, [boundarySize]);
    useEffect(() => {
        if (typeof name != 'string') return;
        setNameContainer(name);
    }, [name]);
    useEffect(() => {
        if (typeof color != 'string') return;
        setColorContainer(color);
    }, [color]);
}

function ContainerDummy() {
    const [conceptType] = useProperty('concept::name');
    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');

    const [size, setSize] = useState([0.5, 0.5, 0.5]);
    const [name, setName] = useState('Unnamed');
    const [color, setColor] = useState('');

    const handle = useMemo(() => Array.isArray(size) ? &lt;mesh
        geometry={frameGeometry}
        material={selected ? (hovered ? dummyFrameMaterialHoveredSelected : dummyFrameMaterialSelected) : (hovered ? dummyFrameMaterialHovered : dummyFrameMaterial)}
        scale={[size[0], 1, size[2]]}
        position={[0, -0.5 * size[1], 0]}
        autoUpdateMatrix={false}
    /> : null, [hovered, selected, size]);

    return conceptType === 'Container' ? &lt;>
        &lt;Movable handle={handle} upright={true}>
            &lt;BoundingBox scale={size} dummy={true} />
            &lt;Text
                fontSize={0.07}
                position={[0, -0.49 * size[1], 0]}
                rotation={[-Math.PI * 0.5, 0, 0]}
                color="#222">
                {name}
            &lt;/Text>
            &lt;Varv property="containedSpace">
                &lt;ContainerSizeAndNameForwarder setSizeContainer={setSize} setNameContainer={setName} setColorContainer={setColor} />
            &lt;/Varv>
        &lt;/Movable>
    &lt;/> : null;
}

function ContainedSpace({ containerUUID, outerSpaceUUID, containerTransform }) {
    const [innerSpaceUUID] = useProperty('concept::uuid');
    const [boundarySize] = useProperty('boundarySize');
    const [boundaryOrigin] = useProperty('boundaryOrigin');
    const [clippingMode] = useProperty('clippingMode');

    // Create a bounding box
    const boundingBox = useMemo(() => {
        if (!Array.isArray(boundarySize)) return null;

        // Create a box centered at origin with the correct size
        const halfSize = new Vector3(boundarySize[0] / 2, boundarySize[1] / 2, boundarySize[2] / 2);
        return new Box3(
            new Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
            new Vector3(halfSize.x, halfSize.y, halfSize.z)
        );
    }, [boundarySize]);

    // React to drag-end events
    const onDragEnd = useCallback(async (data) => {
        if (data.target === containerUUID) {
            // console.log('Container dragged');
            return;
        }

        const boundaryOriginPosition = Array.isArray(boundaryOrigin) ? boundaryOrigin.slice(0, 3) : [0, 0, 0];

        const elementUUID = data.target;
        const elementConcept = await VarvEngine.getConceptFromUUID(elementUUID);
        const elementPosition = await elementConcept.getPropertyValue(elementUUID, 'position');
        const elementRotation = await elementConcept.getPropertyValue(elementUUID, 'rotation');
        const elementPositionVector = new Vector3(...elementPosition);
        const elementParentSpace = elementConcept.getPropertyValue(elementUUID, 'space');
        const wasPointInside = elementParentSpace === innerSpaceUUID;

        // Create volume's transformation matrices
        const containerEuler = new Euler(...containerTransform.rotation);
        const containerRotationMatrix = new Matrix4().makeRotationFromEuler(containerEuler);
        const inverseRotationMatrix = containerRotationMatrix.clone().invert();

        // Point to test in world space
        let worldPosition;
        if (wasPointInside) {
            // Convert from volume's local space to world space
            worldPosition = elementPositionVector.clone()
                .sub(new Vector3(...boundaryOriginPosition))
                .applyMatrix4(containerRotationMatrix)
                .add(new Vector3(...containerTransform.position));
        } else {
            worldPosition = elementPositionVector.clone();
        }

        // Convert world position to volume's local space for testing
        const localPosition = worldPosition.clone()
            .sub(new Vector3(...containerTransform.position))
            .applyMatrix4(inverseRotationMatrix);

        const isPointInside = boundingBox.containsPoint(localPosition);

        if ((isPointInside && wasPointInside) || (!isPointInside && !wasPointInside)) {
            // Position relative to current parent hasn't changed
        } else if (!isPointInside && wasPointInside) {
            console.log('Movable within container has moved outside');
            const newWorldPosition = elementPositionVector.clone()
                .sub(new Vector3(...boundaryOriginPosition))
                .applyMatrix4(containerRotationMatrix)
                .add(new Vector3(...containerTransform.position));

            // Convert local rotation to world rotation
            const movableEuler = new Euler(...elementRotation);
            const movableRotationMatrix = new Matrix4().makeRotationFromEuler(movableEuler);
            const newWorldRotationMatrix = containerRotationMatrix.clone().multiply(movableRotationMatrix);
            const newWorldRotation = new Euler().setFromRotationMatrix(newWorldRotationMatrix);

            elementConcept.setPropertyValue(elementUUID, 'position', [
                newWorldPosition.x,
                newWorldPosition.y,
                newWorldPosition.z
            ]);
            elementConcept.setPropertyValue(elementUUID, 'rotation', [
                newWorldRotation.x,
                newWorldRotation.y,
                newWorldRotation.z
            ]);

            moveMovableToNewSpace(elementUUID, outerSpaceUUID);
        } else if (isPointInside && !wasPointInside) {
            console.log('Movable outside container has moved inside');
            const newLocalPosition = worldPosition.clone()
                .sub(new Vector3(...containerTransform.position))
                .applyMatrix4(inverseRotationMatrix);

            // Convert world rotation to local rotation
            const movableEuler = new Euler(...elementRotation);
            const movableRotationMatrix = new Matrix4().makeRotationFromEuler(movableEuler);
            const newLocalRotationMatrix = inverseRotationMatrix.clone().multiply(movableRotationMatrix);
            const newLocalRotation = new Euler().setFromRotationMatrix(newLocalRotationMatrix);

            elementConcept.setPropertyValue(elementUUID, 'position', [
                newLocalPosition.x + boundaryOriginPosition[0],
                newLocalPosition.y + boundaryOriginPosition[1],
                newLocalPosition.z + boundaryOriginPosition[2]
            ]);
            elementConcept.setPropertyValue(elementUUID, 'rotation', [
                newLocalRotation.x,
                newLocalRotation.y,
                newLocalRotation.z
            ]);

            moveMovableToNewSpace(elementUUID, innerSpaceUUID);
        }
    }, [boundingBox, containerTransform, boundarySize, innerSpaceUUID, boundaryOrigin]);

    const { subscribeEvent } = useGlobalEvents();
    useEffect(() => {
        const unsubscribe = subscribeEvent('drag-end', onDragEnd);
        return () => unsubscribe();
    }, [subscribeEvent, onDragEnd]);

    const sceneComponents = useSceneMovables();
    return &lt;>
        {/* FIXME: Fix this, caused by the &lt;SpaceMovables> component that clears the Varv scope */}
        &lt;Varv concept="SpaceManager">
            &lt;ProjectionPlanePreview positionOverride={[0, 0, 0]} scaleOverride={0.5} />
        &lt;/Varv>
        &lt;group position={Array.isArray(boundaryOrigin) ? [-boundaryOrigin[0], -boundaryOrigin[1], -boundaryOrigin[2]] : [0, 0, 0]}>
            &lt;Varv property="movables">
                &lt;ClippedMovablesFilter clippingMode={clippingMode}>
                    {sceneComponents}
                    &lt;ContainerDummy />
                &lt;/ClippedMovablesFilter>
            &lt;/Varv>
        &lt;/group>
    &lt;/>;
}

function Container() {
    const [containerUUID] = useProperty('concept::uuid');
    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');
    const [space] = useProperty('space');
    const transform = useTransform();
    const [containedSpace] = useProperty('containedSpace');

    const [size, setSize] = useState([0.5, 0.5, 0.5]);
    const [name, setName] = useState('');
    const [color, setColor] = useState('');

    const handle = useMemo(() => Array.isArray(size) ? &lt;mesh
        geometry={frameGeometry}
        material={selected ? (hovered ? frameColoredHoveredSelectedMap.get(color || 'default') : frameColoredSelectedMap.get(color || 'default')) : (hovered ? frameColoredHoveredMap.get(color || 'default') : frameColoredMap.get(color || 'default'))}
        scale={[size[0], 1, size[2]]}
        position={[0, -0.5 * size[1], 0]}
        autoUpdateMatrix={false}
    /> : null, [hovered, selected, size, color]);

    const containerMenuBasicMemo = useMemo(() => !containedSpace && selected ? &lt;ContainerMenuBasic /> : null, [containedSpace, selected]);

    const containerMenuMemo = useMemo(() => selected ? &lt;Varv property="containedSpace">
        &lt;ContainerMenu />
    &lt;/Varv> : null, [selected]);

    const containerMemo = useMemo(() => &lt;Varv property="containedSpace">
        &lt;ContainerSizeAndNameForwarder setSizeContainer={setSize} setNameContainer={setName} setColorContainer={setColor} />
        &lt;ContainedSpace containerUUID={containerUUID} outerSpaceUUID={space} containerTransform={transform} />
    &lt;/Varv>, [containerUUID, space, transform]);

    return &lt;Movable handle={handle} upright={true}>
        {Array.isArray(size) ? &lt;>
            &lt;BoundingBox scale={size} />
            &lt;Text text={name}
                fontSize={0.07}
                position={[0, -0.49 * size[1], 0]}
                rotation={[-Math.PI * 0.5, 0, 0]}
                color="#444" />
        &lt;/> : null}
        {selected ? &lt;Varv property="containedSpace">
            &lt;BoundaryResizer />
        &lt;/Varv> : null}
        {containerMenuBasicMemo}
        {containerMenuMemo}
        {containerMemo}
    &lt;/Movable>;
}

function FilterContainers() {
    const [conceptType] = useProperty('concept::name');
    return conceptType === 'Container' ? &lt;Container /> : null;
}

export function Main() {
    return &lt;Varv property="locationHash">
        &lt;SpaceMovables>
            &lt;FilterContainers />
        &lt;/SpaceMovables>
    &lt;/Varv>
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Container Shape" class="dynamic-shape-component">import React from 'react';
const { useState, useEffect, useRef, useMemo, useCallback } = React;
import { useEditor, HTMLContainer, stopEventPropagation } from 'tldraw';
import { Varv, useProperty } from '#VarvReact';

import { projectToScene, CANVAS_SCALE, shapeToConceptId } from '#Spatialstrates .projection-helpers';
import { MovableCanvasController } from '#Spatialstrates .movable-canvas-controller';
import { ClippedMovablesFilter, moveMovableToNewSpace } from '#Container .container-helpers';
import { MovableShapeUtil, MovableVarvScope } from '#Spatialstrates .movable-shape';



const FAST_WRITEBACK_TIMEOUT = 33;

function ShapeMovementHandler({ shape, containerUUID, outerSpaceUUID }) {
    const [innerSpaceUUID] = useProperty('concept::uuid');
    const [boundarySize] = useProperty('boundarySize');
    const [boundaryOrigin] = useProperty('boundaryOrigin');

    const editor = useEditor();

    const moveElementsInAndOut = useCallback(async (e) => {
        if (e.type != 'pointer' || e.name != 'pointer_up') return;
        const spaceConcept = await VarvEngine.getConceptFromType('Space');

        const containerPosition2D = {
            x: shape.x / CANVAS_SCALE,
            y: -shape.y / CANVAS_SCALE
        };
        const halfSize2D = {
            width: boundarySize[0] / 2,
            height: boundarySize[1] / 2
        };

        const innerSpaceProjectionPlane = await spaceConcept.getPropertyValue(innerSpaceUUID, 'projectionPlane');
        const outerSpaceProjectionPlane = await spaceConcept.getPropertyValue(outerSpaceUUID, 'projectionPlane');


        const selectedShapes = editor.getSelectedShapeIds();
        for (const elementShapeId of selectedShapes) {
            const elementShape = editor.getShape(elementShapeId);
            const elementPosition2D = {
                x: elementShape.x / CANVAS_SCALE,
                y: -elementShape.y / CANVAS_SCALE
            };

            const elementUUID = shapeToConceptId(elementShapeId);
            const elementConcept = await VarvEngine.getConceptFromUUID(elementUUID);
            const elementParentSpace = await elementConcept.getPropertyValue(elementUUID, 'space');

            if (elementShapeId === shape.id) {
                // console.log('Container has moved', currentShape);

                // TODO: Check all movables if they are inside the container or not
            } else if (elementParentSpace === innerSpaceUUID) {
                // console.log('Movable within container has moved', currentShape);

                if (elementPosition2D.x > halfSize2D.width
                    || elementPosition2D.x &lt; -halfSize2D.width
                    || elementPosition2D.y > halfSize2D.height
                    || elementPosition2D.y &lt; -halfSize2D.height
                ) {
                    console.log('Movable within container has moved outside');

                    const newElementPosition3D = projectToScene([
                        elementPosition2D.x + containerPosition2D.x,
                        elementPosition2D.y + containerPosition2D.y
                    ], outerSpaceProjectionPlane);
                    await elementConcept.setPropertyValue(elementUUID, 'position', newElementPosition3D);

                    moveMovableToNewSpace(elementUUID, outerSpaceUUID);
                } else {
                    // console.log('Movable within container has moved inside'); // Do othing
                }
            } else if (elementParentSpace === outerSpaceUUID) {
                // console.log('Movable outside container has moved', currentShape);

                if (elementPosition2D.x &lt; containerPosition2D.x + halfSize2D.width
                    && elementPosition2D.x > containerPosition2D.x - halfSize2D.width
                    && elementPosition2D.y &lt; containerPosition2D.y + halfSize2D.height
                    && elementPosition2D.y > containerPosition2D.y - halfSize2D.height
                ) {
                    console.log('Movable outside container has moved inside');

                    let newElementPosition3D = projectToScene([
                        elementPosition2D.x - containerPosition2D.x,
                        elementPosition2D.y - containerPosition2D.y
                    ], [
                        boundaryOrigin[0],
                        boundaryOrigin[1],
                        boundaryOrigin[2],
                        innerSpaceProjectionPlane[3],
                        innerSpaceProjectionPlane[4],
                        innerSpaceProjectionPlane[5],
                        innerSpaceProjectionPlane[6],
                        innerSpaceProjectionPlane[7],
                        innerSpaceProjectionPlane[8],
                        innerSpaceProjectionPlane[9],
                        innerSpaceProjectionPlane[10],
                        innerSpaceProjectionPlane[11]
                    ]);

                    await elementConcept.setPropertyValue(elementUUID, 'position', newElementPosition3D);

                    moveMovableToNewSpace(elementUUID, innerSpaceUUID);
                } else {
                    // console.log('Movable outside container has moved outside'); // Do othing
                }
            } else {
                // Ignore this case for now
                // TODO: Handle this case
                // console.log('Movables parent is not container or space');
                // const parentConcept = await VarvEngine.getConceptFromUUID(currentParent);
                // const currentParentPosition = {
                //     x: parentConcept.getPropertyValue(currentParent, 'position')[0],
                //     y: parentConcept.getPropertyValue(currentParent, 'position')[1]
                // };
                // if (currentPosition.x + currentParentPosition.x &lt; containerPosition.x + halfSize.width
                //     && currentPosition.x + currentParentPosition.x > containerPosition.x - halfSize.width
                //     && currentPosition.y + currentParentPosition.y &lt; containerPosition.y + halfSize.height
                //     && currentPosition.y + currentParentPosition.y > containerPosition.y - halfSize.height
                // ) {
                //     console.log('Movable outside container has moved inside');
                //     currentConcept.setPropertyValue(currentConceptId, 'space', containerUUID);
                //     currentConcept.setPropertyValue(currentConceptId, 'position', [
                //         currentPosition.x - (1 * containerPosition.x),
                //         currentPosition.y - (1 * containerPosition.y),
                //         0
                //     ]);
                //     setMovables([...movables, currentConceptId]);
                // }
            }
        }
    }, [shape, containerUUID, outerSpaceUUID, editor, innerSpaceUUID, boundarySize, boundaryOrigin]);

    useEffect(() => {
        editor.on('event', moveElementsInAndOut);
        return () => { editor.off('event', moveElementsInAndOut); };
    }, [editor, moveElementsInAndOut]);
}

function ShapeSizeHandler({ shape }) {
    const [boundarySize, setBoundarySize] = useProperty('boundarySize');

    const editor = useEditor();
    // Size: Varv -> tldraw
    const isBeingUpdated = useRef(false);
    useEffect(() => {
        if (!Array.isArray(boundarySize)) return;
        if (!editor) return;
        if (isBeingUpdated.current) return;

        // FIXME: This does only take the x and y size of a container but does not consider the projection plane
        isBeingUpdated.current = true;
        editor.updateShape({
            id: shape.id,
            props: {
                w: boundarySize[0] * CANVAS_SCALE,
                h: boundarySize[1] * CANVAS_SCALE
            }
        });
        isBeingUpdated.current = false;
    }, [boundarySize, editor]);

    // Size: tldraw -> Varv
    const fastWritebackTimeout = useRef();
    useEffect(() => {
        if (!editor) return;

        const updateChangeHandler = editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {
            if (isBeingUpdated.current) return;
            if (prev.id !== shape.id) return;
            if (next.id !== shape.id) return;
            if (prev.props.w === next.props.w && prev.props.h === next.props.h) return;

            // Update the Varv state
            if (!fastWritebackTimeout.current) {
                isBeingUpdated.current = true;

                setBoundarySize([
                    next.props.w / CANVAS_SCALE,
                    next.props.h / CANVAS_SCALE,
                    boundarySize[2]
                ]);

                isBeingUpdated.current = false;
                fastWritebackTimeout.current = setTimeout(() => {
                    fastWritebackTimeout.current = null;
                }, FAST_WRITEBACK_TIMEOUT);
            }
        });

        return () => {
            updateChangeHandler();
        };
    }, [editor, shape, boundarySize]);
}



function ContainedSpaceTitle() {
    const [name] = useProperty('name');
    return &lt;div className="container-title">{name}&lt;/div>;
}

function SpaceOption({ currentSpace }) {
    const [uuid] = useProperty('concept::uuid');
    const [name] = useProperty('name');

    return currentSpace != uuid ? &lt;option value={uuid}>{name}&lt;/option> : null;
}

function SpaceRenamer() {
    const [name, setName] = useProperty('name');

    return &lt;label>
        &lt;span>Rename:&lt;/span>
        &lt;input
            value={name}
            onChange={e => setName(e.target.value)}
            placeholder="Space Name" />
    &lt;/label>;
}

function SpaceColorChanger() {
    const [color, setColor] = useProperty('color');

    return &lt;label>
        &lt;span>Color:&lt;/span>
        &lt;select
            value={color}
            onChange={e => setColor(e.target.value)}
        >
            &lt;option value="">Default&lt;/option>
            &lt;option value="red">Red&lt;/option>
            &lt;option value="green">Green&lt;/option>
            &lt;option value="blue">Blue&lt;/option>
            &lt;option value="yellow">Yellow&lt;/option>
            &lt;option value="purple">Purple&lt;/option>
            &lt;option value="orange">Orange&lt;/option>
            &lt;option value="pink">Pink&lt;/option>
        &lt;/select>
    &lt;/label>;
}

// TODO: Use the style menu from tldraw instead:
// https://tldraw.dev/examples/shapes/tools/shape-with-custom-styles
function SpaceMenu() {
    const [space] = useProperty('space');
    const [containedSpace, setContainedSpace] = useProperty('containedSpace');
    const [clippingMode, setClippingMode] = useProperty('clippingMode');
    const [collaborationLevel, setCollaborationLevel] = useProperty('collaborationLevel');

    const createNewSpace = useCallback(async () => {
        const newSpaceUUID = await VarvEngine.getConceptFromType('Space').create(null, {
            name: 'New Space'
        });
        setContainedSpace(newSpaceUUID);
    }, [setContainedSpace]);

    const enterSpace = useCallback(async () => {
        if (!containedSpace) return;
        const spaceManagerIds = await VarvEngine.getAllUUIDsFromType('SpaceManager');
        if (spaceManagerIds.length === 0) return;
        await VarvEngine.getConceptFromType('SpaceManager').setPropertyValue(spaceManagerIds[0], 'locationHash', containedSpace);
    }, [containedSpace]);

    return &lt;div className="container-menu" style={{
        pointerEvents: 'all'
    }}
        onPointerDown={stopEventPropagation}
        onPointerMove={stopEventPropagation}>
        &lt;button onClick={createNewSpace}>Create New Space&lt;/button>
        &lt;label>
            &lt;span>Space:&lt;/span>
            &lt;select
                value={containedSpace}
                onChange={e => setContainedSpace(e.target.value)}>
                &lt;option value="">None&lt;/option>
                &lt;Varv concept="Space">
                    &lt;SpaceOption currentSpace={space} />
                &lt;/Varv>
            &lt;/select>
        &lt;/label>
        &lt;Varv property="containedSpace">
            &lt;SpaceRenamer />
            &lt;SpaceColorChanger />
            &lt;button onClick={enterSpace}>Enter Space&lt;/button>
        &lt;/Varv>
        &lt;label>
            &lt;span>Clipping Mode:&lt;/span>
            &lt;select
                value={clippingMode}
                onChange={e => setClippingMode(e.target.value)}
            >
                &lt;option value="hide">Hide Outside&lt;/option>
                &lt;option value="show">Show All&lt;/option>
            &lt;/select>
        &lt;/label>
        &lt;label>
            &lt;span>Collaboration Level:&lt;/span>
            &lt;select
                value={collaborationLevel}
                onChange={e => setCollaborationLevel(e.target.value)}
            >
                &lt;option value="close">Close&lt;/option>
                {/* &lt;option value="loose">Loose Collaboration&lt;/option> */}
                &lt;option value="none">None&lt;/option>
            &lt;/select>
        &lt;/label>
    &lt;/div>;
}

function ColorForwarder({ setColor }) {
    const [color] = useProperty('color');

    useEffect(() => {
        setColor(color);
    }, [color]);
}

function ContainerShape({ shape, isEditing }) {
    const [containerUUID] = useProperty('concept::uuid');
    const [space] = useProperty('space');
    const [containedSpace] = useProperty('containedSpace');
    const [clippingMode] = useProperty('clippingMode');
    const [color, setColor] = useState('');
    const editor = useEditor();

    const isInMainSpace = useMemo(() => shape?.parentId === 'page:page', [shape]);

    // Reset size if no space is contained
    useEffect(() => {
        if (!containedSpace) {
            editor?.updateShape({
                id: shape.id,
                props: {
                    w: 0.5 * CANVAS_SCALE,
                    h: 0.5 * CANVAS_SCALE
                }
            });
        }
    }, [editor, containedSpace]);

    return &lt;HTMLContainer className={`container-shape ${isEditing ? 'editing' : ''} ${isInMainSpace ? '' : 'nested'} color-${color || 'default'}`} style={{
        transform: 'translate(-50%, -50%)',
        width: shape.props.w + 'px',
        height: shape.props.h + 'px'
    }}>
        &lt;Varv property="containedSpace">
            &lt;ContainedSpaceTitle />
            &lt;ColorForwarder setColor={setColor} />
            &lt;ShapeSizeHandler shape={shape} />
            {isInMainSpace && !isEditing ? &lt;>
                &lt;Varv property="movables">
                    &lt;ClippedMovablesFilter clippingMode={clippingMode}>
                        &lt;MovableCanvasController parent={shape.id} />
                    &lt;/ClippedMovablesFilter>
                &lt;/Varv>
                &lt;ShapeMovementHandler
                    shape={shape}
                    containerUUID={containerUUID}
                    outerSpaceUUID={space} />
            &lt;/> : null}
        &lt;/Varv>
        {isEditing ? &lt;SpaceMenu /> : null}
    &lt;/HTMLContainer>;
}

class ContainerShapeUtil extends MovableShapeUtil {
    static type = 'Container';

    getDefaultProps() {
        return Object.assign(super.getDefaultProps(), {
            w: CANVAS_SCALE * 0.35,
            h: CANVAS_SCALE * 0.35
        });
    }

    canResize = () => true;
    isAspectRatioLocked = () => false;
    canEdit = () => true;

    component(shape) {
        const isEditing = this.editor.getEditingShapeId() === shape.id;

        return &lt;MovableVarvScope shape={shape}>
            &lt;ContainerShape shape={shape} isEditing={isEditing} />
        &lt;/MovableVarvScope>;
    }
}

export const Main = ContainerShapeUtil;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Container Helpers" class="container-helpers">import React from 'react';
const { useMemo } = React;
import { Vector3, Box3 } from 'three';
import { useProperty } from '#VarvReact';



export function ClippedMovablesFilter({ children, clippingMode }) {
    // Space
    const [boundarySize] = useProperty('boundarySize');
    const [boundaryOrigin] = useProperty('boundaryOrigin');

    // Movable
    const [beingDragged] = useProperty('beingDragged');
    const [position] = useProperty('position');

    const positionVector = useMemo(() => new Vector3(), []);
    const boundingBox = useMemo(() => {
        if (!Array.isArray(boundarySize) || !Array.isArray(boundaryOrigin)) return false;

        const halfSize = new Vector3(boundarySize[0] / 2, boundarySize[1] / 2, boundarySize[2] / 2);
        const min = new Vector3(...boundaryOrigin).sub(halfSize);
        const max = new Vector3(...boundaryOrigin).add(halfSize);

        return new Box3(min, max);
    }, [boundarySize, boundaryOrigin]);

    const withinBounds = useMemo(() => {
        if (!boundingBox) return false;
        if (!Array.isArray(position)) return false;

        return boundingBox.containsPoint(positionVector.fromArray(position));
    }, [boundingBox, position]);

    // STUB: Implement a faded mode
    return clippingMode == 'show' || withinBounds || beingDragged ? children : null;
}

export const moveMovableToNewSpace = async (elementUUID, newSpaceUUID = '') => {
    const elementConcept = await VarvEngine.getConceptFromUUID(elementUUID);
    const spaceConcept = await VarvEngine.getConceptFromType('Space');

    const oldSpaceUUID = await elementConcept.getPropertyValue(elementUUID, 'space');

    elementConcept.setPropertyValue(elementUUID, 'space', newSpaceUUID);
    if (oldSpaceUUID) spaceConcept.setPropertyValue(oldSpaceUUID, 'movables', (await spaceConcept.getPropertyValue(oldSpaceUUID, 'movables')).filter(movable => movable !== elementUUID));
    if (newSpaceUUID) spaceConcept.setPropertyValue(newSpaceUUID, 'movables', [...(await spaceConcept.getPropertyValue(newSpaceUUID, 'movables')), elementUUID]);
};
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Container Style" auto>.container-shape {
    background-color: hsl(0, 0%, 95%);
    box-shadow: rgba(100, 100, 111, 0.4) 0px 0px 4px 0px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 8px;
    padding: 10px;

    .container-title {
        font-size: 32px;
        opacity: 0.3;
        text-align: center;
    }

    .container-menu {
        width: 100%;
        font-size: 16px;
        max-width: 256px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 8px;

        input,
        select,
        button {
            flex: 1 1 auto;
            font-size: 14px;
        }

        label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;

            span {
                flex: 0 0 auto;
            }
        }
    }

    &.color-red {
        background-color: hsl(0, 40%, 90%);
    }
    &.color-green {
        background-color: hsl(120, 40%, 90%);
    }
    &.color-blue {
        background-color: hsl(204, 40%, 90%);
    }
    &.color-yellow {
        background-color: hsl(60, 40%, 90%);
    }
    &.color-purple {
        background-color: hsl(270, 40%, 90%);
    }
    &.color-orange {
        background-color: hsl(30, 40%, 90%);
    }
    &.color-pink {
        background-color: hsl(310, 40%, 90%);
    }
    &.nested {
        background-color: hsl(0, 0%, 86%);
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></code-folder><CODE-FOLDER name="Helpers"><WPM-PACKAGE name="Icon" id="Icon"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A helper function for themed icons using custom 3D models.",
    "dependencies": [],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Icon Component" class="default">import React from 'react';
import { Clone } from '@react-three/drei';



export const SELECTED_COLOR_PRIMARY = 'hsl(14, 100%, 50%)';
export const SELECTED_COLOR_SECONDARY = 'hsl(26, 100%, 60%)';
export const HOVERED_SELECTED_COLOR_PRIMARY = 'hsl(14, 100%, 65%)';
export const HOVERED_SELECTED_COLOR_SECONDARY = 'hsl(26, 100%, 75%)';



export const themes = {
    '': { primary: 'rgb(255,0,255)', secondary: 'rgb(255,255,0)' },
    ':hovered': { primary: 'rgb(255,0,0)', secondary: 'rgb(255,0,0)' },
    ':selected': { primary: 'rgb(0,255,0)', secondary: 'rgb(255,0,0)' },
    ':selected:hovered': { primary: 'rgb(0,255,255)', secondary: 'rgb(255,0,0)' }
};



export function Icon(props) {
    const { model, theme = '', themesOverride = false } = props;
    if (model == null) return null;

    const finalThemes = themesOverride || themes;

    try {
        if (model.materials['Primary']) model.materials['Primary'].color.set(finalThemes[theme].primary);
        if (model.materials['Secondary']) model.materials['Secondary'].color.set(finalThemes[theme].secondary);
    } catch (ex) {
        console.log('Missing colour for ' + theme);
    }

    return &lt;group {...props}>
        &lt;Clone object={model ? model.scene : null} deep={'materialsOnly'} />
    &lt;/group>;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Dialog" name="Dialog"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple modal dialog for displaying menus.",
    "dependencies": [],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Dialog Component" class="default">import React from 'react';



export function Dialog({ children, className, visible, setVisible }) {
    return visible ? &lt;div className="dialog-modal" onClick={() => setVisible(false)}>
        &lt;div className={`dialog${className ? ' ' + className : ''}`} onClick={(e) => e.stopPropagation()}>
            {children}
        &lt;/div>
    &lt;/div> : null;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Dialog Style" auto>@mixin heading-font {
    font-weight: 500;
    font-size: 13px;
    letter-spacing: 0.25px;
}

.dialog-modal {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    z-index: 100000;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(5px);
    background: rgba(192, 192, 192, .60) !important;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 12px;

    .dialog {
        background: #fafafa;
        border-radius: 8px;
        padding: 16px;
        display: flex;
        flex-direction: column;
        flex-wrap: nowrap;
        gap: 12px;
        max-width: 100%;
        box-shadow: 0 0 12px 0 rgba(0, 0, 0, 0.25);
        max-width: 768px;

        h2,
        p {
            margin: 0;
        }

        button {
            @include heading-font;

            user-select: none;
            border-radius: 4px;
            padding: 2px 8px;
            background: #636363;
            color: #fff;
            vertical-align: middle;
            text-align: center;
            cursor: pointer;
            border: none;
            height: 24px;

            &:hover {
                background: #848484;
            }

            &:active {
                background: #606060;
            }

            &.red {
                background: #d32f2f !important;

                &:hover {
                    background: #ff6659 !important;
                }

                &:active {
                    background: #9a0007 !important;
                }
            }

            &.green {
                background: #2e7d32 !important;

                &:hover {
                    background: #60ad5e !important;
                }

                &:active {
                    background: #005005 !important;
                }
            }
        }

        label {
            @include heading-font;

            user-select: none;
            white-space: nowrap;

            background: #eeeeee;
            color: #000000;

            border-radius: 4px;
            padding-left: 8px;
            padding-right: 8px;
            padding-right: 0;

            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            align-items: center;
            gap: 4px;

            input[type="checkbox"] {
                width: 24px;
            }

            input:not([type="checkbox"]),
            select {
                border-top-left-radius: 16px;
                border-bottom-left-radius: 16px;
                height: 100%;
            }
        }

        input:not([type="checkbox"]),
        select,
        textarea {
            border-radius: 4px;
            border: none;
            padding: 0 8px;
            text-overflow: ellipsis;
            outline: none;
            color: #000;
            width: 100%;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="AIHelpers" id="AIHelpers"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Helper functions to call the OpenAI API.",
    "dependencies": [],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="AI Helpers" class="default">export const recordAudio = (duration) => {
    return new Promise((resolve, reject) => {
        let chunks = [];

        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
            const mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = (event) => {
                chunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(chunks, { type: 'audio/wav' });
                resolve(audioBlob);
            };

            mediaRecorder.start();

            setTimeout(() => {
                mediaRecorder.stop();
            }, duration);
        }).catch(error => {
            reject(error);
        });
    });
};

export const transcribeAudio = async (duration, audioBlob = false, recordingEndedCallback = false) => {
    if (!window.API_KEY) {
        window.API_KEY = prompt('Please enter your OpenAI API key:');
        if (!window.API_KEY) {
            if (recordingEndedCallback) recordingEndedCallback();
            console.error('An API_KEY is required to transcribe audio.');
            return;
        }
    }

    let audioBlobToTranscribe = audioBlob;
    if (!audioBlobToTranscribe) {
        audioBlobToTranscribe = await recordAudio(duration);
    }

    if (recordingEndedCallback) recordingEndedCallback();

    const formData = new FormData();
    formData.append('file', audioBlobToTranscribe, 'recording.wav');
    formData.append('model', 'whisper-1');

    const whisperResponse = await fetch('https://api.openai.com/v1/audio/transcriptions', {
        method: 'POST',
        mode: 'cors',
        headers: { 'Authorization': `Bearer ${API_KEY}` },
        body: formData,
    });
    const whisperData = await whisperResponse.json();

    return whisperData.text;
};

export const sendGPTPrompt = async (body) => {
    if (!window.API_KEY) {
        window.API_KEY = prompt('Please enter your OpenAI API key:');
        if (!window.API_KEY) {
            console.error('An API_KEY is required to transcribe audio.');
            return;
        }
    }

    const options = {
        method: 'POST',
        mode: 'cors',
        headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${API_KEY}`
        },
        body: JSON.stringify(body)
    };
    console.log('OpenAI API call options:', options);

    const gptResponse = await fetch('https://api.openai.com/v1/chat/completions', options);
    const gptData = await gptResponse.json();
    return gptData;
};

export const getGPTContent = (gptData) => gptData.choices[0].message.content;
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><code-folder name="Basic" id><WPM-PACKAGE id="Menu" name="Menu"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple menu GUI for Spatialstrates.",
    "dependencies": [
        "#Spatialstrates"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Menu" class="default dynamic-gui-component">import React from 'react';
const { useState, useEffect } = React;



if (!window.moduleMenu) {
    window.moduleMenu = {
        subMenus: new Map(),
        menuNeedsUpdate: true
    };
}

class MenuItem {
    constructor(id, element, weight) {
        this.id = id;
        this.element = element;
        this.weight = weight;
    }
}

class SubMenu {
    constructor(id, weight, alwaysVisible = false) {
        this.id = id;
        this.weight = weight;
        this.alwaysVisible = alwaysVisible;
        this.items = new Map();
    }

    addItem(item) {
        this.items.set(item.id, item);
    }
}

export const addSubMenu = (id, weight, alwaysVisible) => {
    if (window.moduleMenu.subMenus.has(id)) {
        return window.moduleMenu.subMenus.get(id);
    }
    const subMenu = new SubMenu(id, weight, alwaysVisible);
    window.moduleMenu.subMenus.set(id, subMenu);
    window.moduleMenu.menuNeedsUpdate = true;
    return subMenu;
};

export const addItemToSubMenu = (subMenuId, id, element, weight) => {
    const menuItem = new MenuItem(id, element, weight);
    const subMenu = window.moduleMenu.subMenus.get(subMenuId);
    if (!subMenu) {
        console.error(`SubMenu ${subMenuId} not found`);
        return;
    }
    subMenu.addItem(menuItem);
    window.moduleMenu.menuNeedsUpdate = true;
    return menuItem;
};

export function MenuTitle({ title }) {
    return &lt;div className="title">{title}&lt;/div>;
}

export function MenuSpacer() {
    return &lt;div className="spacer">&lt;/div>;
}

export function MenuButton({ onClick, toggled, children, className }) {
    return &lt;button className={className} onClick={onClick} toggled={toggled ? 'true' : null} tabIndex="-1">{children}&lt;/button>;
}

/**
 * A heads-up display with buttons
 */
function Menu() {
    const [output, setOutput] = useState(null);

    const updateMenu = () => {
        const subMenus = Array.from(window.moduleMenu.subMenus.values());
        subMenus.sort((a, b) => a.weight - b.weight);

        setOutput(&lt;div className="floating-menus">
            {subMenus.map(subMenu => {
                const items = Array.from(subMenu.items.values());
                items.sort((a, b) => a.weight - b.weight);
                return &lt;div key={subMenu.id} id={subMenu.id} className={`floating-menu${subMenu.alwaysVisible ? ' always-visible' : ''}`}>
                    {items.map((item, index) => (React.cloneElement(item.element, { key: index })))}
                &lt;/div>;
            })}
        &lt;/div>);
    };

    useEffect(() => {
        if (window.moduleMenu.menuNeedsUpdate) {
            window.moduleMenu.menuNeedsUpdate = false;
            updateMenu();
        }
    });

    useEffect(() => {
        updateMenu();
    }, []);

    return output;
}



export function Main() {
    return &lt;Menu />;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Menu Style" auto>@mixin heading-font {
    font-weight: 500;
    font-size: 13px;
    letter-spacing: 0.25px;
}

.floating-menus {
    position: absolute;
    bottom: 8px;
    left: 8px;
    right: 8px;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    align-items: flex-end;
    justify-content: space-between;
    gap: 8px;
}

.floating-menu {
    z-index: 99999;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60) !important;
    border-radius: 12px;
    border: 1px solid #cccccc70;
    box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.025);
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 12px;
    flex: 0 1 192px;
    min-height: 40px;

    max-height: 40px;
    overflow: hidden;
    transition: max-height 500ms ease-in-out;

    &:hover:not(.always-visible) {
        max-height: initial;

        .title {
            order: 999;
        }
    }

    &.always-visible {
        max-height: initial;
    }

    .spacer {
        border-bottom: 1px solid #63636370;
        margin: 0 32px;
    }

    .title {
        @include heading-font;
        min-height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;

        user-select: none;
        text-align: center;
        cursor: default;
        color: #636363dd;
    }

    button {
        @include heading-font;
        min-height: 40px;

        user-select: none;
        border-radius: 4px;
        padding: 4px 8px;
        background: #63636390;
        color: #fff;
        vertical-align: middle;
        text-align: center;
        cursor: pointer;
        border: none;

        &:hover {
            background: #848484cc;
        }

        &:active {
            background: #606060cc;
        }

        &.red {
            background: #d32f2f90 !important;

            &:hover {
                background: #ff6659cc !important;
            }

            &:active {
                background: #9a0007cc !important;
            }
        }

        &.green {
            background: #2e7d3290 !important;

            &:hover {
                background: #61ad5ecc !important;
            }

            &:active {
                background: #005005cc !important;
            }
        }

        &[toggled="true"] {
            background: #FF910090 !important;
        }
    }

    .upload-drop-zone {
        @include heading-font;
        min-height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;

        user-select: none;
        text-align: center;
        cursor: pointer;
        background: #ddd;
        border-radius: 4px;

        &.upload-drop-zone--over {
            background: #ccc;
            cursor: copy;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ControllerMenu" name="ControllerMenu"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple controller menu for immersive XR.",
    "dependencies": [
        "#Spatialstrates"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Controller Menu" id class="default dynamic-scene-component">import React from 'react';
const { useState, useEffect, useMemo, useRef } = React;
import { Color } from 'three';
import { createPortal, useFrame } from '@react-three/fiber';
import { useXRInputSourceState } from '@react-three/xr';
import { Text as UIText, Root } from '@react-three/uikit';
import { Defaults, Card, Button, List, ListItem } from '@react-three/uikit-apfel';
import { Varv, useProperty } from '#VarvReact';



const COLORS = {
    red: '#ff3333',
    green: '#66ff66',
    blue: '#6666ff',
    yellow: '#ffcc66',
    purple: '#ff66ff',
    orange: '#ff9966',
    pink: '#ff3399',
};



function hsl(h, s, l) {
    return new Color().setHSL(h / 360, s / 100, l / 100, 'srgb')
}

if (!window.moduleControllerMenu) {
    window.moduleControllerMenu = {
        subMenus: new Map(),
        menuNeedsUpdate: true
    };
}

class MenuItem {
    constructor(id, element, weight) {
        this.id = id;
        this.element = element;
        this.weight = weight;
    }
}

class SubMenu {
    constructor(id, weight, alwaysVisible = false) {
        this.id = id;
        this.weight = weight;
        this.alwaysVisible = alwaysVisible; // Does not do anything yet
        this.items = new Map();
    }

    addItem(item) {
        this.items.set(item.id, item);
    }
}

export const addControllerSubMenu = (id, weight, alwaysVisible) => {
    if (window.moduleControllerMenu.subMenus.has(id)) {
        return window.moduleControllerMenu.subMenus.get(id);
    }
    const subMenu = new SubMenu(id, weight, alwaysVisible);
    window.moduleControllerMenu.subMenus.set(id, subMenu);
    window.moduleControllerMenu.menuNeedsUpdate = true;
    return subMenu;
};

export const addItemToControllerSubMenu = (subMenuId, id, element, weight) => {
    const menuItem = new MenuItem(id, element, weight);
    const subMenu = window.moduleControllerMenu.subMenus.get(subMenuId);
    if (!subMenu) {
        console.error(`SubMenu ${subMenuId} not found`);
        return;
    }
    subMenu.addItem(menuItem);
    window.moduleControllerMenu.menuNeedsUpdate = true;
    return menuItem;
};

export function ControllerMenuTitle({ title }) {
    return &lt;UIText
        fontSize={18}
        fontWeight="light"
        padding={16}>{title}&lt;/UIText>
}

export function ControllerMenuSpacer() {
    return &lt;UIText color={hsl(0, 0, 30)}>|&lt;/UIText>
}

export function ControllerMenuButton({ onClick, toggled, children }) {
    return &lt;ListItem
        selected={toggled}
        flexGrow={1}
        borderWidth={1.5}
        borderColor={hsl(0, 0, 10)}
        onClick={onClick}>
        &lt;UIText textAlign="center">{children}&lt;/UIText>
    &lt;/ListItem>;
}

function SubMenuComponent({ key, children }) {
    return &lt;List key={key}
        type="plain"
        maxWidth={800}
        borderRadius={16}
        padding={8}
        backgroundColor={hsl(0, 0, 20)}
        flexDirection="row"
        flexWrap="wrap"
        gap={8}>
        {children}
    &lt;/List>
}

function PropertyForwarder({ setColor, setName }) {
    const [color] = useProperty('color');
    const [name] = useProperty('name');

    useEffect(() => {
        if (typeof color !== 'string') return;
        setColor(color);
    }, [color]);

    useEffect(() => {
        if (typeof name !== 'string') return;
        setName(name);
    }, [name]);
}

function SubMenus() {
    const [showMenu, setShowMenu] = useState(false);
    const [output, setOutput] = useState(null);
    const [color, setColor] = useState('');
    const [name, setName] = useState('');

    const updateMenu = () => {
        const subMenus = Array.from(window.moduleControllerMenu.subMenus.values());
        subMenus.sort((a, b) => a.weight - b.weight);

        setOutput(&lt;>
            {subMenus.map(subMenu => {
                const items = Array.from(subMenu.items.values());
                items.sort((a, b) => a.weight - b.weight);
                return &lt;SubMenuComponent key={subMenu.id}>
                    {items.map((item, index) => (React.cloneElement(item.element, { key: index })))}
                &lt;/SubMenuComponent>;
            })}
        &lt;/>);
    }

    useEffect(() => {
        if (window.moduleControllerMenu.menuNeedsUpdate) {
            window.moduleControllerMenu.menuNeedsUpdate = false;
            updateMenu();
        }
    });

    useEffect(() => {
        updateMenu();
    }, []);

    return &lt;>
        &lt;Varv concept="SpaceManager">
            &lt;Varv property="locationHash">
                &lt;PropertyForwarder setColor={setColor} setName={setName} />
            &lt;/Varv>
        &lt;/Varv>
        &lt;Defaults>
            &lt;Root
                anchorX="center"
                anchorY="bottom"
                flexDirection="column"
                pixelSize={0.0005}>
                &lt;Card borderRadius={24}
                    borderBend={24}
                    padding={24}
                    gap={16}
                    flexDirection="column">
                    {showMenu ? output : null}
                    &lt;Button platter
                        size="lg"
                        backgroundColor={COLORS[color] || ''}
                        backgroundOpacity={0.5}
                        hover={{
                            backgroundColor: COLORS[color] || '',
                            backgroundOpacity: 0.65,
                        }}
                        onClick={() => setShowMenu(!showMenu)}>
                        &lt;UIText>{name || 'Toggle Menu'}&lt;/UIText>
                    &lt;/Button>
                &lt;/Card>
            &lt;/Root>
        &lt;/Defaults>
    &lt;/>;
}

function ControllerMenu() {
    const controllerLeft = useXRInputSourceState('controller', 'left');
    const handLeft = useXRInputSourceState('hand', 'left');
    const [output, setOutput] = useState(null);

    const submenus = useMemo(() => &lt;SubMenus />, []);
    const menu = useMemo(() => &lt;group
        position={controllerLeft ? [0, 0.11, 0.06] : [-0.02, 0.06, 0.11]}
        rotation={controllerLeft ? [-Math.PI / 2, 0, 0] : [-0.2, 0.2, -0.5]}>
        {submenus}
    &lt;/group>, [submenus, controllerLeft]);

    const slowWritebackTimeout = useRef(null);
    useFrame(() => {
        if (!slowWritebackTimeout.current) {
            const parent = controllerLeft ? controllerLeft?.object : handLeft ? handLeft?.object : null;
            if (parent) {
                setOutput(createPortal(menu, parent));
            } else {
                setOutput(null);
            }
            slowWritebackTimeout.current = setTimeout(() => {
                slowWritebackTimeout.current = null;
            }, 1000);
        }
    });

    return output;
}



export function Main() {
    return &lt;ControllerMenu />;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="BasicMenus" name="BasicMenus"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Basic menu entries to move the camera and toggle XR.",
    "dependencies": [
        "#Spatialstrates",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="XR Menu" class auto>import React from 'react';
import { Varv, useProperty } from '#VarvReact';

import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';



const toggleAR = async () => {
    if (!navigator?.xr) {
        alert('WebXR is not supported by your browser.');
        return;
    }

    const sessionMode = 'immersive-ar';
    if (!await navigator.xr.isSessionSupported(sessionMode)) {
        alert('AR sessions are not supported by your browser.');
        return;
    }

    if (!window.xrStore) {
        console.warn('No xrStore found');
        return;
    }
    if (!window.xrStore.getState().session) {
        window.xrStore?.enterAR();
    } else {
        await window.xrStore.getState().session.end();
        window.xrStore.setState({ session: null });
    }
};

const toggleVR = async () => {
    if (!navigator?.xr) {
        alert('WebXR is not supported by your browser.');
        return;
    }

    const sessionMode = 'immersive-vr';
    if (!await navigator.xr.isSessionSupported(sessionMode)) {
        alert('VR sessions are not supported by your browser.');
        return;
    }

    if (!window.xrStore) {
        console.warn('No xrStore found');
        return;
    }
    if (!window.xrStore.getState().session) {
        window.xrStore?.enterVR();
    } else {
        await window.xrStore.getState().session.end();
        window.xrStore.setState({ session: null });
    }
};

const shareLink = () => {
    let sendToQuestUrl = new URL('https://oculus.com/open_url/');
    sendToQuestUrl.searchParams.set('url', location.protocol + '//' + location.host + location.pathname);
    window.open(sendToQuestUrl, '_blank');
};

function CheckIsCanvasView({ children }) {
    const [currentView] = useProperty('currentView');
    return currentView === '2D' ? children : null;
}

function CheckIsSceneView({ children }) {
    const [currentView] = useProperty('currentView');
    return currentView === '3D' ? children : null;
}

function DepthSensingToggle() {
    const [depthSensing, setDepthSensing] = useProperty('depthSensing');

    return &lt;MenuButton onClick={() => setDepthSensing(!depthSensing)} toggled={depthSensing ? 'true' : null}>Depth Sensing ({depthSensing ? 'On' : 'Off'})&lt;/MenuButton>
}



addSubMenu('camera', 1000, true);
addItemToSubMenu('camera', 'move-camera', &lt;Varv concept="SpaceManager">
    &lt;CheckIsSceneView>
        &lt;MenuButton className="mouse-lock" onClick={() => {
            if (!window.moduleCameraControls?.controlsRef?.current) return;
            if (!window.moduleCameraControls.controlsRef.current.isLocked) {
                window.moduleCameraControls.controlsRef.current.lock();
                document.querySelector('.mouse-lock')?.blur();
            } else {
                window.moduleCameraControls.controlsRef.current.unlock();
            }
        }}>Move Camera&lt;/MenuButton>
    &lt;/CheckIsSceneView>
&lt;/Varv>, 0);
addItemToSubMenu('camera', 'spacer1', &lt;Varv concept="SpaceManager">
    &lt;CheckIsSceneView>
        &lt;MenuSpacer />
    &lt;/CheckIsSceneView>
&lt;/Varv>, 50);
addItemToSubMenu('camera', 'toggle-depth-sensing', &lt;Varv concept="SpaceManager">
    &lt;CheckIsSceneView>
        &lt;DepthSensingToggle />
    &lt;/CheckIsSceneView>
&lt;/Varv>, 100);
addItemToSubMenu('camera', 'toggle-ar', &lt;Varv concept="SpaceManager">
    &lt;CheckIsSceneView>
        &lt;MenuButton onClick={toggleAR}>Toggle AR&lt;/MenuButton>
    &lt;/CheckIsSceneView>
&lt;/Varv>, 200);
addItemToSubMenu('camera', 'spacer2', &lt;Varv concept="SpaceManager">
    &lt;CheckIsSceneView>
        &lt;MenuSpacer />
    &lt;/CheckIsSceneView>
&lt;/Varv>, 250);
addItemToSubMenu('camera', 'toggle-vr', &lt;Varv concept="SpaceManager">
    &lt;CheckIsSceneView>
        &lt;MenuButton onClick={toggleVR}>Toggle VR&lt;/MenuButton>
    &lt;/CheckIsSceneView>
&lt;/Varv>, 300);
addItemToSubMenu('camera', 'title', &lt;Varv concept="SpaceManager">
    &lt;CheckIsCanvasView>
        &lt;MenuTitle title="3D Controls Unavailable" />
    &lt;/CheckIsCanvasView>
&lt;/Varv>, 400);


addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'title', &lt;MenuTitle title="Media Sharing" />, 0);
addItemToSubMenu('media-sharing', 'share-link', &lt;MenuButton onClick={shareLink}>Send to Quest&lt;/MenuButton>, 1000);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" auto name="Projection Plane Menu">import React from 'react';
import { Varv, useProperty } from '#VarvReact';

import { computeProjectionPlaneUsingPCA, resetProjectionPlane, resetBoundary } from '#Spatialstrates .projection-helpers';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { addControllerSubMenu, addItemToControllerSubMenu, ControllerMenuTitle, ControllerMenuSpacer, ControllerMenuButton } from '#ControllerMenu .default';



function ProjectionPlaneToggleButton() {
    const [showProjectionPlane, setShowProjectionPlane] = useProperty('showProjectionPlane');
    return &lt;MenuButton onClick={() => setShowProjectionPlane(!showProjectionPlane)} toggled={showProjectionPlane ? 'true' : null}>Toggle Projection Plane ({showProjectionPlane ? 'On' : 'Off'})&lt;/MenuButton>;
}
function BoundaryToggleButton() {
    const [showBoundary, setShowBoundary] = useProperty('showBoundary');
    return &lt;MenuButton onClick={() => setShowBoundary(!showBoundary)} toggled={showBoundary ? 'true' : null}>Toggle Boundary ({showBoundary ? 'On' : 'Off'})&lt;/MenuButton>;
}
addSubMenu('projection-plane', 800, false);
addItemToSubMenu('projection-plane', 'title', &lt;MenuTitle title="Projection Plane" />, 0);
addItemToSubMenu('projection-plane', 'show-projection-plane', &lt;Varv concept="SpaceManager">
    &lt;ProjectionPlaneToggleButton />
&lt;/Varv>, 100);
addItemToSubMenu('projection-plane', 'show-boundary', &lt;Varv concept="SpaceManager">
    &lt;BoundaryToggleButton />
&lt;/Varv>, 200);
addItemToSubMenu('projection-plane', 'spacer-1', &lt;MenuSpacer />, 300);
addItemToSubMenu('projection-plane', 'compute-using-pca', &lt;MenuButton onClick={() => computeProjectionPlaneUsingPCA()}>Compute Using PCA&lt;/MenuButton>, 400);
addItemToSubMenu('projection-plane', 'spacer-2', &lt;MenuSpacer />, 500);
addItemToSubMenu('projection-plane', 'reset-projection-plane', &lt;MenuButton onClick={() => resetProjectionPlane()}>Reset Projection Plane&lt;/MenuButton>, 600);
addItemToSubMenu('projection-plane', 'reset-boundary', &lt;MenuButton onClick={() => resetBoundary()}>Reset Boundary&lt;/MenuButton>, 700);

function ProjectionPlaneToggleControllerButton() {
    const [showProjectionPlane, setShowProjectionPlane] = useProperty('showProjectionPlane');
    return &lt;ControllerMenuButton onClick={() => setShowProjectionPlane(!showProjectionPlane)} toggled={showProjectionPlane ? 'true' : null}>Toggle Projection Plane ({showProjectionPlane ? 'On' : 'Off'})&lt;/ControllerMenuButton>;
}
function BoundaryToggleControllerButton() {
    const [showBoundary, setShowBoundary] = useProperty('showBoundary');
    return &lt;ControllerMenuButton onClick={() => setShowBoundary(!showBoundary)} toggled={showBoundary ? 'true' : null}>Toggle Boundary ({showBoundary ? 'On' : 'Off'})&lt;/ControllerMenuButton>;
}
addControllerSubMenu('projection-plane', 800, false);
addItemToControllerSubMenu('projection-plane', 'title', &lt;ControllerMenuTitle title="Projection Plane" />, 0);
addItemToControllerSubMenu('projection-plane', 'show-projection-plane', &lt;Varv concept="SpaceManager">
    &lt;ProjectionPlaneToggleControllerButton />
&lt;/Varv>, 100);
addItemToControllerSubMenu('projection-plane', 'show-boundary', &lt;Varv concept="SpaceManager">
    &lt;BoundaryToggleControllerButton />
&lt;/Varv>, 200);
addItemToControllerSubMenu('projection-plane', 'spacer-1', &lt;ControllerMenuSpacer />, 300);
addItemToControllerSubMenu('projection-plane', 'compute-using-pca', &lt;ControllerMenuButton onClick={() => computeProjectionPlaneUsingPCA()}>Compute Using PCA&lt;/ControllerMenuButton>, 400);
addItemToControllerSubMenu('projection-plane', 'spacer-2', &lt;ControllerMenuSpacer />, 500);
addItemToControllerSubMenu('projection-plane', 'reset-projection-plane', &lt;ControllerMenuButton onClick={() => resetProjectionPlane()}>Reset Projection Plane&lt;/ControllerMenuButton>, 600);
addItemToControllerSubMenu('projection-plane', 'reset-boundary', &lt;ControllerMenuButton onClick={() => resetBoundary()}>Reset Boundary&lt;/ControllerMenuButton>, 700);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Movable Menu" auto>import React from 'react';

import { deselectMovables, deleteSelectedMovable, cloneSelectedMovable } from '#Spatialstrates .movable-helpers';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { addControllerSubMenu, addItemToControllerSubMenu, ControllerMenuTitle, ControllerMenuSpacer, ControllerMenuButton } from '#ControllerMenu .default';



addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'clone', &lt;MenuButton onClick={cloneSelectedMovable}>Clone&lt;/MenuButton>, 500);
addItemToSubMenu('movables', 'delete', &lt;MenuButton className="red" onClick={deleteSelectedMovable}>Delete&lt;/MenuButton>, 500);
addItemToSubMenu('movables', 'spacer1', &lt;MenuSpacer />, 550);
addItemToSubMenu('movables', 'deselect', &lt;MenuButton onClick={deselectMovables}>Deselect Objects&lt;/MenuButton>, 700);

addControllerSubMenu('movables', 100, false);
addItemToControllerSubMenu('movables', 'title', &lt;ControllerMenuTitle title="Menu" />, 0);
addItemToControllerSubMenu('movables', 'clone', &lt;ControllerMenuButton onClick={cloneSelectedMovable}>Clone&lt;/ControllerMenuButton>, 500);
addItemToControllerSubMenu('movables', 'delete', &lt;ControllerMenuButton className="red" onClick={deleteSelectedMovable}>Delete&lt;/ControllerMenuButton>, 500);
addItemToControllerSubMenu('movables', 'spacer1', &lt;ControllerMenuSpacer />, 550);
addItemToControllerSubMenu('movables', 'deselect', &lt;ControllerMenuButton onClick={deselectMovables}>Deselect Objects&lt;/ControllerMenuButton>, 700);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Container Menu" auto>import React from 'react';

import { createMovable } from '#Spatialstrates .movable-helpers';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { addControllerSubMenu, addItemToControllerSubMenu, ControllerMenuTitle, ControllerMenuSpacer, ControllerMenuButton } from '#ControllerMenu .default';



addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'add-container', &lt;MenuButton onClick={() => createMovable('Container')}>New Container&lt;/MenuButton>, 200);
addItemToSubMenu('movables', 'spacer-items', &lt;MenuSpacer />, 500);

addControllerSubMenu('movables', 100, false);
addItemToControllerSubMenu('movables', 'title', &lt;ControllerMenuTitle title="Menu" />, 0);
addItemToControllerSubMenu('movables', 'add-container', &lt;ControllerMenuButton onClick={() => createMovable('Container')}>New Container&lt;/ControllerMenuButton>, 200);
addItemToControllerSubMenu('movables', 'spacer-items', &lt;ControllerMenuSpacer />, 500);
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="SpaceManager" id="SpaceManager"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A manager for creating and managing spaces with Spatialstrates.",
    "dependencies": [
        "#Dialog",
        "#ControllerMenu",
        "#AIHelpers"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Space Manager" class="dynamic-gui-component">import React from 'react';
const { useState } = React;
import { Varv, useProperty } from '#VarvReact';

import { deleteMovable } from '#Spatialstrates .movable-helpers';
import { Dialog } from '#Dialog .default';



function SpaceRenamer() {
    const [name, setName] = useProperty('name');

    return &lt;label>
        Rename Space
        &lt;input value={name ? name : ''} onChange={e => setName(e.target.value)} title='Rename Space' />
    &lt;/label>;
}

function SpaceColorChanger() {
    const [color, setColor] = useProperty('color');

    return &lt;label>
        Change Space Color
        &lt;select value={color} onChange={e => setColor(e.target.value)} title='Change Space Color'>
            &lt;option value="">Default&lt;/option>
            &lt;option value="red">Red&lt;/option>
            &lt;option value="green">Green&lt;/option>
            &lt;option value="blue">Blue&lt;/option>
            &lt;option value="yellow">Yellow&lt;/option>
            &lt;option value="purple">Purple&lt;/option>
            &lt;option value="orange">Orange&lt;/option>
            &lt;option value="pink">Pink&lt;/option>
        &lt;/select>
    &lt;/label>;
}

function SpaceSelector({ selectSpace }) {
    const [name] = useProperty('name');
    const [color] = useProperty('color');
    const [currentSpace, setCurrentSpace] = useProperty('locationHash');
    const [uuid] = useProperty('concept::uuid');

    const deleteSpace = async (e) => {
        e.stopPropagation();
        if (currentSpace == uuid) setCurrentSpace('');
        const movables = await VarvEngine.getConceptFromType('Space').getPropertyValue(uuid, 'movables');
        for (const movable of movables) {
            await deleteMovable(movable);
        }
        await VarvEngine.getConceptFromType('Space').delete(uuid);
    };

    return &lt;div className="space"
        local={currentSpace == uuid ? 'true' : null}
        color={color}
        onClick={() => selectSpace(uuid)}
        title={'Select Space ' + name}>
        &lt;span className="space-name">{name}&lt;/span>
        &lt;span className="delete-icon material-icons-outlined" onClick={deleteSpace} title="Delete User">delete&lt;/span>
    &lt;/div>;
}

function SpaceManagerMenu() {
    const [visible, setVisible] = useState(false);
    const [space, setSpace] = useProperty('locationHash');

    const addSpace = async () => {
        setSpace(await VarvEngine.getConceptFromType('Space').create(null, { name: 'New Space' }));
    };

    const selectSpace = (spaceId) => {
        setSpace(spaceId);
    };

    return &lt;>
        &lt;Dialog className="space-manager" visible={visible} setVisible={setVisible}>
            &lt;div className="space-headline">Space Manager&lt;/div>
            &lt;div className="space-subtitle">
                &lt;span style={{ marginRight: '10px' }}>Space Selection&lt;/span>
                &lt;button title="Add Space" onClick={addSpace}>Add Space&lt;/button>&lt;/div>
            &lt;div className="space-list">
                &lt;Varv concept="Space">
                    &lt;SpaceSelector selectSpace={selectSpace} />
                &lt;/Varv>
            &lt;/div>
            &lt;Varv property="locationHash">
                &lt;div className="space-subtitle">Space Settings&lt;/div>
                &lt;div className="space-menu">
                    &lt;SpaceRenamer />
                    &lt;SpaceColorChanger />
                &lt;/div>
            &lt;/Varv>
        &lt;/Dialog>

        &lt;div className="space-manager-button" onClick={() => setVisible(true)}>Space Manager&lt;/div>
    &lt;/>;
}

function SpaceTab() {
    const [currentSpace, setCurrentSpace] = useProperty('locationHash');
    const [uuid] = useProperty('concept::uuid');
    const [name] = useProperty('name');
    const [color] = useProperty('color');

    return &lt;div
        className="space-tab"
        local={currentSpace == uuid ? 'true' : null}
        color={color}
        onClick={() => setCurrentSpace(uuid)}>
        {name}
    &lt;/ div>;
}

function NewSpaceTab() {
    const [currentSpace, setCurrentSpace] = useProperty('locationHash');

    const addSpace = async () => {
        setCurrentSpace(await VarvEngine.getConceptFromType('Space').create(null, { name: 'New Space' }));
    };

    return &lt;div className="space-tab" onClick={addSpace}>+&lt;/div>;
}



function SpaceManager() {
    const [currentView, setCurrentView] = useProperty('currentView');

    return &lt;>
        &lt;div className="space-view-toggle" title="Toggle View" onClick={() => setCurrentView(currentView === '3D' ? '2D' : '3D')}>Toggle View ({currentView})&lt;/div>
        &lt;SpaceManagerMenu />
        &lt;div className="space-tabs">
            &lt;Varv concept="Space">
                &lt;SpaceTab />
            &lt;/Varv>
            &lt;NewSpaceTab />
        &lt;/div>
    &lt;/>;
}



export function Main() {
    return &lt;Varv concept="SpaceManager">
        &lt;SpaceManager />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Space Manager Controller Menu" auto>import React from 'react';
const { useEffect, useState, useRef, useCallback } = React;
import { Varv, useProperty } from '#VarvReact';

import { addControllerSubMenu, addItemToControllerSubMenu, ControllerMenuTitle, ControllerMenuSpacer, ControllerMenuButton } from '#ControllerMenu .default';
import { transcribeAudio } from '#AIHelpers .default';



function GoBackControllerButton() {
    const [currentSpace, setCurrentSpace] = useProperty('locationHash');
    const historyRef = useRef([]);
    const programmaticHashRef = useRef(null);

    const handleHashChange = useCallback((e) => {
        const newHash = new URL(e.newURL).hash;
        const oldHash = new URL(e.oldURL).hash;

        // If this is a navigation we initiated, don't record it
        if (programmaticHashRef.current === newHash) {
            programmaticHashRef.current = null;
            return;
        }

        // Otherwise, record the old hash in history
        historyRef.current.push(oldHash);
    }, []);

    useEffect(() => {
        window.addEventListener('hashchange', handleHashChange);
        return () => {
            window.removeEventListener('hashchange', handleHashChange);
        };
    }, [handleHashChange]);

    const goBack = useCallback(() => {
        const lastSpace = historyRef.current.pop();
        if (lastSpace) {
            const targetHash = '#' + lastSpace.slice(1);
            programmaticHashRef.current = targetHash;
            setCurrentSpace(lastSpace.slice(1));
        }
    }, [setCurrentSpace]);

    return &lt;ControllerMenuButton onClick={goBack}>Go Back&lt;/ControllerMenuButton>;
}

function SpaceSelectionButton() {
    const [currentSpace, setCurrentSpace] = useProperty('locationHash');
    const [name] = useProperty('name');
    const [uuid] = useProperty('concept::uuid');

    return &lt;ControllerMenuButton
        onClick={() => setCurrentSpace(uuid)}
        toggled={currentSpace === uuid}
    >{name || 'Loading ...'}&lt;/ControllerMenuButton>;
}

function SpaceCreator() {
    const [currentSpace, setCurrentSpace] = useProperty('locationHash');

    return &lt;ControllerMenuButton onClick={async () => {
        const newSpaceUUID = await VarvEngine.getConceptFromType('Space').create(null, {
            name: 'New Space'
        });
        setCurrentSpace(newSpaceUUID);
    }}>Add Space&lt;/ControllerMenuButton>;
}

function SpaceRenamer() {
    const [name, setName] = useProperty('name');
    const [listening, setListening] = useState(false);


    async function updateName() {
        if (listening) return;

        setListening(true);
        const newName = await transcribeAudio(5000, false, () => { setListening(false); });
        if (newName) setName(newName);
    }

    return &lt;ControllerMenuButton onClick={updateName}>{listening ? 'Speak Now' : 'Record New Name'}&lt;/ControllerMenuButton>;
}

function SpaceColorChanger() {
    const [color, setColor] = useProperty('color');

    return &lt;>
        &lt;ControllerMenuButton toggled={color === ''} onClick={() => setColor('')}>Default&lt;/ControllerMenuButton>
        &lt;ControllerMenuButton toggled={color === 'red'} onClick={() => setColor('red')}>Red&lt;/ControllerMenuButton>
        &lt;ControllerMenuButton toggled={color === 'green'} onClick={() => setColor('green')}>Green&lt;/ControllerMenuButton>
        &lt;ControllerMenuButton toggled={color === 'blue'} onClick={() => setColor('blue')}>Blue&lt;/ControllerMenuButton>
        &lt;ControllerMenuButton toggled={color === 'yellow'} onClick={() => setColor('yellow')}>Yellow&lt;/ControllerMenuButton>
        &lt;ControllerMenuButton toggled={color === 'purple'} onClick={() => setColor('purple')}>Purple&lt;/ControllerMenuButton>
        &lt;ControllerMenuButton toggled={color === 'orange'} onClick={() => setColor('orange')}>Orange&lt;/ControllerMenuButton>
        &lt;ControllerMenuButton toggled={color === 'pink'} onClick={() => setColor('pink')}>Pink&lt;/ControllerMenuButton>
    &lt;/>;
}

addControllerSubMenu('spaces', 900, false);
addItemToControllerSubMenu('spaces', 'title', &lt;ControllerMenuTitle title="Spaces" />, 0);
addItemToControllerSubMenu('spaces', 'go-back', &lt;Varv concept="SpaceManager">
    &lt;GoBackControllerButton />
&lt;/Varv>, 100);
addItemToControllerSubMenu('spaces', 'spacer', &lt;ControllerMenuSpacer />, 150);
addItemToControllerSubMenu('spaces', 'spaces-list', &lt;Varv concept="SpaceManager">
    &lt;Varv concept="Space">
        &lt;SpaceSelectionButton />
    &lt;/Varv>
&lt;/Varv>, 200);
addItemToControllerSubMenu('spaces', 'spacer2', &lt;ControllerMenuSpacer />, 250);
addItemToControllerSubMenu('spaces', 'spaces-creator', &lt;Varv concept="SpaceManager">
    &lt;SpaceCreator />
&lt;/Varv>, 300);

addControllerSubMenu('currentSpace', 1000, false);
addItemToControllerSubMenu('currentSpace', 'title', &lt;ControllerMenuTitle title="Current Space" />, 0);
addItemToControllerSubMenu('currentSpace', 'spaces-renamer', &lt;Varv concept="SpaceManager">
    &lt;Varv property="locationHash">
        &lt;SpaceRenamer />
    &lt;/Varv>
&lt;/Varv>, 200);
addItemToControllerSubMenu('currentSpace', 'spacer', &lt;ControllerMenuSpacer />, 250);
addItemToControllerSubMenu('currentSpace', 'spaces-color-changer', &lt;Varv concept="SpaceManager">
    &lt;Varv property="locationHash">
        &lt;SpaceColorChanger />
    &lt;/Varv>
&lt;/Varv>, 300);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Space Manager Style" auto>@mixin heading-font {
    font-weight: 500;
    font-size: 13px;
    letter-spacing: 0.25px;
}

.space-view-toggle,
.space-manager-button {
    @include heading-font;
    height: 24px;
    line-height: 24px;
    border-radius: 4px;
    padding: 0 8px;
    background: #ddd;
    position: fixed;
    top: 12px;
    left: 180px;
    z-index: 99999;
    cursor: pointer;
    user-select: none;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60);
    border: 1px solid #cccccc70;
}

.space-tabs {
    position: fixed;
    top: 6px;
    left: 324px;
    right: 190px;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
    gap: 6px;
    z-index: 99999;

    border-radius: 4px;
    background: #ddd;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60);
    border: 1px solid #cccccc70;
    padding: 6px;

    .space-tab {
        @include heading-font;
        height: 24px;
        line-height: 24px;
        padding: 0 8px;
        cursor: pointer;
        border-radius: 4px;
        background: #ddd;
        -webkit-backdrop-filter: saturate(180%) blur(10px);
        backdrop-filter: saturate(180%) blur(10px);
        background: rgba(255, 255, 255, .60);
        border: 1px solid #cccccc70;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        user-select: none;

        &[local="true"] {
            background: hsl(34, 100%, 73%);
        }

        &[color]:before {
            content: "";
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #000;
            border-radius: 50%;
            margin-right: 6px;
            border: 1px solid #444;
        }
        &[color=""]:before {
            display: none;
        }
        &[color="red"]:before {
            background: hsl(0, 80%, 60%);
        }
        &[color="green"]:before {
            background: hsl(120, 80%, 60%);
        }
        &[color="blue"]:before {
            background: hsl(204, 80%, 60%);
        }
        &[color="yellow"]:before {
            background: hsl(60, 80%, 60%);
        }
        &[color="purple"]:before {
            background: hsl(270, 80%, 60%);
        }
        &[color="orange"]:before {
            background: hsl(30, 80%, 60%);
        }
        &[color="pink"]:before {
            background: hsl(310, 80%, 60%);
        }
    }
}

.space-view-toggle {
    top: 44px;
}

.space-manager {
    .space-headline {
        font-size: 24px;
        font-weight: 700;
        cursor: default;
        user-select: none;
    }

    .space-subtitle {
        font-size: 16px;
        font-weight: 500;
        cursor: default;
        user-select: none;
    }

    .space-menu {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 8px;
        min-height: 32px;
        padding: 8px;
        border-radius: 4px;
        background: #ddd;
    }

    .space-list {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 8px;
        padding: 8px;
        border-radius: 4px;
        background: #ddd;
    }

    .space {
        height: 32px;
        cursor: pointer;
        border-radius: 20px;
        background: #eeeeee;
        user-select: none;
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 8px;
        align-items: center;

        &[color] .space-name:before {
            content: "";
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #000;
            border-radius: 50%;
            margin-right: 6px;
            border: 1px solid #444;
        }
        &[color=""] .space-name:before {
            display: none;
        }
        &[color="red"] .space-name:before {
            background: hsl(0, 80%, 60%);
        }
        &[color="green"] .space-name:before {
            background: hsl(120, 80%, 60%);
        }
        &[color="blue"] .space-name:before {
            background: hsl(204, 80%, 60%);
        }
        &[color="yellow"] .space-name:before {
            background: hsl(60, 80%, 60%);
        }
        &[color="purple"] .space-name:before {
            background: hsl(270, 80%, 60%);
        }
        &[color="orange"] .space-name:before {
            background: hsl(30, 80%, 60%);
        }
        &[color="pink"] .space-name:before {
            background: hsl(310, 80%, 60%);
        }

        .space-name {
            padding-left: 8px;
        }

        .delete-icon {
            font-size: 20px;
            text-align: center;
            line-height: 32px;
            cursor: pointer;
            background: #d32f2f;
            color: #fff;
            border-radius: 50%;
            width: 32px;
            height: 32px;
        }
    }

    .space[local="true"] {
        background: #FFAB40;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="SpatialstratesLogo" name="SpatialstratesLogo"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Spatialstrates logo with version information.",
    "dependencies": [
        "#Spatialstrates",
        "#Dialog"
    ],
    "assets": [
        "favicon.ico",
        "manifest.json",
        "spatialstrates-icons.zip"
    ],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Spatialstrates Logo Header" class="dynamic-gui-component">import React from 'react';
const { useState } = React;

import { Dialog } from '#Dialog .default';



export function Main() {
    const [visible, setVisible] = useState(false);

    return &lt;>
        &lt;div className="spatialstrates-title" onClick={() => setVisible(!visible)}>
            &lt;img src="dash-space-icons.zip/icon_128.png" />
            &lt;h1>Spatialstrates&lt;/h1>
        &lt;/div>

        &lt;Dialog visible={visible} setVisible={setVisible}>
            &lt;h2>Spatialstrates&lt;/h2>
            &lt;p>Version 0.2.0 | &lt;a href="https://github.com/Webstrates/Spatialstrates" target="_blank">GitHub&lt;/a>&lt;/p>
        &lt;/Dialog>
    &lt;/>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Update Head Content" auto>let manifestLink = document.head.querySelector('link[rel="manifest"]');
if (!manifestLink) {
    manifestLink = document.createElement('link');
    manifestLink.setAttribute('rel', 'manifest');
    manifestLink.setAttribute('href', 'manifest.json');
    document.head.appendChild(manifestLink);
    WPMv2.stripProtection(manifestLink);
}



let iconLink = document.head.querySelector('link[rel="icon"]');
if (!iconLink) {
    iconLink = document.createElement('link');
    iconLink.setAttribute('rel', 'icon');
    document.head.appendChild(iconLink);
    WPMv2.stripProtection(iconLink);
}

// Always update the icon so that it shows in Chromium-based browsers
iconLink.setAttribute('href', 'favicon.ico');
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Spatialstrates Logo Style" auto>.spatialstrates-title {
    position: fixed;
    top: 12px;
    left: 12px;
    z-index: 99999;
    padding: 4px 5px;
    border-radius: 4px;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    gap: 8px;
    align-items: center;
    height: 48px;
    user-select: none;
    cursor: pointer;

    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60);
    border: 1px solid #cccccc70;
    box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.025);

    h1 {
        margin: 0;
        font-size: 22px;
        line-height: 32px;
        font-weight: 600;
        letter-spacing: -0.01em;
        padding-left: 4px;
        padding-right: 4px;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="CalibrationPoint" name="CalibrationPoint"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Calibration widget for immersive XR.",
    "dependencies": [
        "#Spatialstrates",
        "#Icon"
    ],
    "assets": [
        "calibration_point.glb"
    ],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Calibration Point" id class="default dynamic-scene-component">import React from 'react';
const { useRef } = React;
import { Matrix4 } from 'three';
import { useFrame, useThree } from '@react-three/fiber';
import { useXRInputSourceEvent, useXRInputSourceState, IfInSessionMode } from '@react-three/xr';
import { useGLTF } from '@react-three/drei';

import { Icon } from "#Icon .default";



const themes = {
    'calibrationPoint': { primary: 'hsl(65, 100%, 40%)', secondary: 'hsl(200, 18%, 50%)' },
    'calibrationPoint:hovered': { primary: 'hsl(65, 100%, 60%)', secondary: 'hsl(200, 18%, 60%)' }
};
useGLTF.preload('calibration_point.glb');

/**
 * Move the entire scene view based on a calibration marker or a cube that can be moved around
*/
function CalibrationPoint() {
    const calibrateIcon = useGLTF('calibration_point.glb');
    let offsetUpdate = false;
    const grabbingController = useRef();
    const previousTransform = React.useMemo(() => new Matrix4(), [])
    const dragRef = useRef();

    // If a new offset has been set, inform the XR manager
    useFrame((state) => {
        if (offsetUpdate) {
            const referenceSpace = state.gl.xr.getReferenceSpace()
            state.gl.xr.setReferenceSpace(referenceSpace.getOffsetReferenceSpace(offsetUpdate));
            offsetUpdate = false;
        }

        const controller = grabbingController.current;
        if (!controller) return;

        dragRef.current.applyMatrix4(previousTransform);
        dragRef.current.applyMatrix4(controller.matrixWorld);
        dragRef.current.rotation.reorder('YXZ');
        dragRef.current.rotation.x = 0;
        dragRef.current.rotation.z = 0;
        dragRef.current.updateMatrixWorld();
        previousTransform.copy(controller.matrixWorld).invert();
    });

    // When the reference has moved, store the offset and reset it back (but not in height)
    const calibrate = () => {
        if (!dragRef.current) return;
        dragRef.current.rotation.reorder('YXZ');
        dragRef.current.rotation.x = 0;
        dragRef.current.rotation.z = 0;
        offsetUpdate = new XRRigidTransform({
            x: dragRef.current.position.x,
            y: 0,
            z: dragRef.current.position.z
        }, dragRef.current.quaternion);
        dragRef.current.rotation.y = 0;
        dragRef.current.position.x = 0;
        dragRef.current.position.z = 0;
    };

    const { camera } = useThree();
    const controllerRight = useXRInputSourceState('controller', 'right');
    const controllerLeft = useXRInputSourceState('controller', 'left');
    const handRight = useXRInputSourceState('hand', 'right');
    const handLeft = useXRInputSourceState('hand', 'left');

    useXRInputSourceEvent('all', 'selectend', (e) => {
        if (e.target.controller === grabbingController.current) {
            grabbingController.current = undefined;
            calibrate();
        }
    }, []);

    return &lt;>
        &lt;group ref={dragRef} onPointerDown={(e) => {
            if (grabbingController.current) return;
            if (e.nativeEvent?.inputSource) {
                if (e.nativeEvent.inputSource.hand === null) {
                    grabbingController.current = e.nativeEvent.inputSource.handedness === 'right' ? controllerRight?.object : controllerLeft?.object;
                } else {
                    grabbingController.current = e.nativeEvent.inputSource.handedness === 'right' ? handRight?.object : handLeft?.object;
                }
            } else if (e.nativeEvent?.button === 0) {
                grabbingController.current = camera;
            }
            if (grabbingController.current) {
                previousTransform.copy(grabbingController.current.matrixWorld).invert();
            }
        }}
            onPointerUp={() => {
                if (grabbingController.current) {
                    grabbingController.current = undefined;
                    calibrate();
                }
            }}>
            &lt;Icon theme="calibrationPoint" model={calibrateIcon} themesOverride={themes} />
        &lt;/group>
    &lt;/>;
}



export function Main() {
    return &lt;IfInSessionMode allow={['immersive-ar', 'immersive-vr']}>
        &lt;CalibrationPoint />
    &lt;/IfInSessionMode>;
}
</CODE-FRAGMENT></WPM-PACKAGE></code-folder><code-folder name="Collaboration"><WPM-PACKAGE id="UserManager" name="UserManager"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple user manager component.",
    "dependencies": [
        "webstrate-components-repos MaterialDesignOutlinedIcons",
        "#Spatialstrates",
        "#Dialog"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="User Manager Concepts" auto>{
    "concepts": {
        "UserManager": {
            "schema": {
                "placeholder": "string",
                "localUser": "User"
            },
            "mappings": {
                "localUser": [ "memory", "cauldron" ]
            }
        },
        "User": {
            "schema": {
                "name": "string"
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="User Manager Component" id class="dynamic-gui-component">import React from 'react';
const { useState, useEffect } = React;
import { Varv, useProperty } from '#VarvReact';

import { Dialog } from '#Dialog .default';



function UserRenamer() {
    const [name, setName] = useProperty('name');
    return &lt;label>
        Rename User
        &lt;input value={name ? name : ''} onChange={e => setName(e.target.value)} title='Rename User' />
    &lt;/label>;
}

function UserSelector({ selectUser }) {
    const [name] = useProperty('name');
    const [localUser] = useProperty('localUser');
    const [uuid] = useProperty('concept::uuid');

    const deleteUser = (e) => {
        e.stopPropagation();
        VarvEngine.getConceptFromType('User').delete(uuid);
    };

    return &lt;div className='user' local={localUser == uuid ? 'true' : null} onClick={() => selectUser(uuid)} title={'Select User ' + name}>
        &lt;span className="user-name">{name}&lt;/span>
        &lt;span className="delete-icon material-icons-outlined" onClick={deleteUser} title="Delete User">delete&lt;/span>
    &lt;/div>;
}

function UserManager() {
    const [visible, setVisible] = useState(false);
    const [localUser, setLocalUser] = useProperty('localUser');
    const userConcept = VarvEngine.getConceptFromType('User');

    useEffect(() => {
        if (localUser) return;

        const runAsync = async () => {
            const users = await VarvEngine.lookupInstances('User');
            try {
                if (users.length > 0) {
                    await setLocalUser(users[0]);
                } else {
                    const uuid = await userConcept.create(null, { name: 'Guest' });
                    await setLocalUser(uuid);
                }
            } catch (e) {
                // Sometimes there are timing issues with `setLocalUser`
            }
        };

        runAsync();
    }, [setLocalUser]);

    const addUser = async () => {
        setLocalUser(await userConcept.create(null, { name: 'New User ' + Math.floor(Math.random() * 1000) }));
    };

    const selectUser = (userId) => {
        setLocalUser(userId);
    };

    return &lt;>
        &lt;Dialog className="user-manager" visible={visible} setVisible={setVisible}>
            &lt;div className="user-headline">User Manager&lt;/div>
            &lt;div className="user-menu">
                &lt;button title="Add User" onClick={addUser}>Add User&lt;/button>
                &lt;Varv property="localUser">
                    &lt;UserRenamer />
                &lt;/Varv>
            &lt;/div>
            &lt;div className="user-list">
                &lt;Varv concept="User">
                    &lt;UserSelector selectUser={selectUser} />
                &lt;/Varv>
            &lt;/div>
        &lt;/Dialog>

        &lt;div className="user-manager-button" onClick={() => setVisible(true)}>User Manager&lt;/div>
    &lt;/>;
}

export function Main() {
    return &lt;Varv concept="UserManager">
        &lt;UserManager />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Init Manager Concept" auto>const initConcept = async () => {
    try {
        const managers = await VarvEngine.lookupInstances('UserManager');
        if (managers.length == 0) {
            await VarvEngine.getConceptFromType('UserManager').create(null, {});
        }
    } catch (e) {
        // Ignore
    }
};

VarvEngine.registerEventCallback('engineReloaded', () => {
    initConcept();
});

initConcept();
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="User Manager Style" auto>@mixin heading-font {
    font-weight: 500;
    font-size: 13px;
    letter-spacing: 0.25px;
}

.user-manager-button {
    @include heading-font;
    height: 24px;
    line-height: 24px;
    border-radius: 4px;
    padding: 0 8px;
    background: #ddd;
    position: fixed;
    top: 12px;
    right: 64px;
    z-index: 99999;
    cursor: pointer;
    user-select: none;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60);
    border: 1px solid #cccccc70;
}

.user-manager {
    .user-headline {
        font-size: 24px;
        font-weight: 700;
        cursor: default;
        user-select: none;
    }

    .user-menu {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 8px;
        min-height: 32px;
        padding: 8px;
        border-radius: 4px;
        background: #ddd;
    }

    .user-list {
        display: flex;
        flex-direction: row;
        gap: 8px;
        padding: 8px;
        border-radius: 4px;
        background: #ddd;
    }

    .user {
        height: 32px;
        cursor: pointer;
        border-radius: 20px;
        background: #eeeeee;
        user-select: none;
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 8px;
        align-items: center;

        .user-name {
            padding-left: 8px;
        }

        .delete-icon {
            font-size: 20px;
            text-align: center;
            line-height: 32px;
            cursor: pointer;
            background: #d32f2f;
            color: #fff;
            border-radius: 50%;
            width: 32px;
            height: 32px;
        }
    }

    .user[local="true"] {
        background: #FFAB40;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="UserDisplay" name="UserDisplay"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Displays which users are in the current space.",
    "dependencies": [
        "varv-repos varv-signaling",
        "#Spatialstrates",
        "#UserManager"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="User Display Concepts" auto>{
    "concepts": {
        "User": {
            "schema": {
                "space": "Space"
            },
            "mappings": {
                "space": [ "signaling", "memory", "cauldron" ]
            }
        }
    },
    "dataStores": {
        "signaling": { "type": "signaling" }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="User Display GUI" class="dynamic-gui-component">import React from 'react';
const { useState, useEffect } = React;
import { Varv, useProperty } from '#VarvReact';



function UserUpdater() {
    const [localUser] = useProperty('localUser');
    const [locationHash] = useProperty('locationHash'); // SpaceManager
    const [previousLocalUser, setPreviousLocalUser] = useState(false);

    useEffect(() => {
        if (previousLocalUser && previousLocalUser !== localUser) {
            VarvEngine.getConceptFromType('User').setPropertyValue(previousLocalUser, 'space', '');
        }
    }, [previousLocalUser, localUser]);

    useEffect(() => {
        if (!locationHash) return;

        if (localUser) {
            VarvEngine.getConceptFromType('User').setPropertyValue(localUser, 'space', locationHash);
        }

        setPreviousLocalUser(localUser);
    }, [localUser, locationHash]);
}

function UserIcon() {
    const [localUser] = useProperty('localUser');
    const [userUUID] = useProperty('concept::uuid');
    const [locationHash] = useProperty('locationHash'); // SpaceManager
    const [space] = useProperty('space');
    const [name] = useProperty('name');

    return space == locationHash ? &lt;div className={`user-icon ${localUser == userUUID ? 'local-user' : ''}`}>{name || ''}&lt;/div> : null;
}

export function Main() {
    return &lt;Varv concept="UserManager">
        &lt;Varv concept="SpaceManager">
            &lt;UserUpdater />
            &lt;div className="user-display">
                &lt;Varv concept="User">
                    &lt;UserIcon />
                &lt;/Varv>
            &lt;/div>
        &lt;/Varv>
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="User Display Style" auto>@mixin heading-font {
    font-weight: 500;
    font-size: 13px;
    letter-spacing: 0.25px;
}

.user-display {
    position: absolute;
    top: 80px;
    left: 10px;
    width: 282px;
    padding: 8px;
    border-radius: 20px;
    z-index: 99999;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 6px;

    user-select: none;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60);
    border: 1px solid #cccccc70;

    .user-icon {
        @include heading-font;
        height: 22px;
        line-height: 22px;
        padding: 0 8px;
        border-radius: 12px;
        background: #ddd;
        -webkit-backdrop-filter: saturate(180%) blur(10px);
        backdrop-filter: saturate(180%) blur(10px);
        background: rgba(255, 255, 255, .60);
        border: 1px solid #cccccc70;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;

        &.local-user {
            background: hsl(34, 100%, 73%);
            order: -1;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Avatar" name="Avatar"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Awareness avatars for remote users.",
    "dependencies": [
        "varv-repos varv-signaling",
        "#Spatialstrates",
        "#Text",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [
        "avatar-models.zip"
    ],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Avatar Concepts" auto>{
    "concepts": {
        "AvatarManager": {
            "schema": {
                "enabled": "boolean"
            }
        },
        "Avatar": {
            "schema": {
                "type": {
                    "string":{
                        "default": "camera",
                        "enum": [ "camera", "controllerLeft", "controllerRight", "handLeft", "handRight", "cursor" ]
                    }
                },
                "userAgent": "string",
                "inputSourceProfile": "string",
                "client": "string",
                "clientVideoStream": { "array": {
                    "items": "VideoStream",
                    "derive": {
                        "concepts": [ "VideoStream" ],
                        "properties": [ "client" ],
                        "transform": [
                            { "get": { "property": "client", "as": "client" }},
                            { "select": {
                                "concept": "VideoStream",
                                "where": { "property": "client", "equals": "$client" },
                                "keepContext": true
                            }}
                        ]
                    }
                }},
                "clientAudioStream": { "array": {
                    "items": "AudioStream",
                    "derive": {
                        "concepts": [ "AudioStream" ],
                        "properties": [ "client" ],
                        "transform": [
                            { "get": { "property": "client", "as": "client" }},
                            { "select": {
                                "concept": "AudioStream",
                                "where": { "property": "client", "equals": "$client" },
                                "keepContext": true
                            }}
                        ]
                    }
                }},
                "userName": "string",
                "isMine": "boolean",
                "position": { "array": {
                    "items": "number",
                    "default": [ 0, 0, 0 ]
                }},
                "rotation": { "array": {
                    "items": "number",
                    "default": [ 0, 0, 0 ]
                }},
                "remoteControlled": "boolean",
                "remoteControllingClient": "string",
                "space": "Space",
                "view": "string",
                "otherSpace": "Space",
                "otherSpaceRelativePosition": { "array": {
                    "items": "number",
                    "default": [ 0, 0, 0 ]
                }},
                "otherSpaceRelativeRotation": { "array": {
                    "items": "number",
                    "default": [ 0, 0, 0 ]
                }},
                "active": "boolean"
            },
            "defaultMappings": [ "signaling", "memory", "cauldron" ],
            "mappings": {
                "isMine": [ "memory", "cauldron" ]
            }
        }
    },
    "dataStores": {
        "signaling": { "type": "signaling" }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Avatar Component" class="dynamic-scene-component" id>import React from 'react';
let { useState, useEffect } = React;
import { Cone, Gltf, useGLTF, Box, Billboard } from '@react-three/drei';
import { Varv, useProperty } from '#VarvReact';

import { Text } from '#Spatialstrates .text';



let VideoStream;
if (Fragment.one('#VideoStream .default')) {
    const videoStreamModule = await Fragment.one('#VideoStream .default').require();
    VideoStream = videoStreamModule.VideoStream;
}
let AudioStream;
if (Fragment.one('#AudioStream .default')) {
    const audioStreamModule = await Fragment.one('#AudioStream .default').require();
    AudioStream = audioStreamModule.AudioStream;
}


useGLTF.preload("avatar-models.zip/model-camera.glb");
useGLTF.preload("avatar-models.zip/model-phone.glb");
useGLTF.preload("avatar-models.zip/model-headset.glb");
useGLTF.preload("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/meta-quest-touch-plus/left.glb");
useGLTF.preload("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/meta-quest-touch-plus/right.glb");
useGLTF.preload("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/generic-hand/left.glb");
useGLTF.preload("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/generic-hand/right.glb");

const cameraModel = &lt;Gltf src="avatar-models.zip/model-camera.glb" scale={1} rotation={[0, Math.PI, 0]} />;
const phoneModel = &lt;Gltf src="avatar-models.zip/model-phone.glb" scale={0.01} />;
const headsetModel = &lt;Gltf src="avatar-models.zip/model-headset.glb" scale={0.9} rotation={[0, Math.PI, 0]} position={[0, 0.04, 0.11]} />;

const controllerLeftModel = &lt;Gltf src="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/meta-quest-touch-plus/left.glb" />;
const controllerRightModel = &lt;Gltf src="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/meta-quest-touch-plus/right.glb" />;
const handLeftModel = &lt;Gltf src="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/generic-hand/left.glb" rotation={[Math.PI / 2, -Math.PI / 2, -Math.PI / 8]} />;
const handRightModel = &lt;Gltf src="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/generic-hand/right.glb" rotation={[Math.PI / 2, Math.PI / 2, Math.PI / 8]} />;

const viewCone = &lt;Cone args={[0.1, 0.1, 32]} position={[0, 0, -0.05]} rotation={[Math.PI / 2, 0, 0]}>
    &lt;meshStandardMaterial color="skyblue" transparent={true} opacity={0.66} />
&lt;/Cone>;

const cursorModel = &lt;Box args={[0.005, 0.005, 1]} position={[0, 0, 0]}>
    &lt;meshBasicMaterial color="skyblue" />
&lt;/Box>;



function AvatarModel() {
    const [userName] = useProperty('userName');
    const [client] = useProperty('client');
    const [view] = useProperty('view');
    const [type] = useProperty('type');
    const [userAgent] = useProperty('userAgent');
    const [inputSourceProfile] = useProperty('inputSourceProfile');

    const [model, setModel] = useState(cameraModel);

    useEffect(() => {
        switch (type) {
            case 'camera':
                if (userAgent.includes('OculusBrowser')) {
                    setModel(&lt;> {headsetModel} {viewCone} &lt;/>);
                } else if (/(iPad|iPhone|iPod|Android)/i.test(userAgent)) {
                    setModel(&lt;> {phoneModel} {viewCone} &lt;/>);
                } else {
                    setModel(&lt;> {cameraModel} {viewCone} &lt;/>);
                }
                break;
            // TODO: Use the inputSourceProfile to determine the correct model
            case 'controllerLeft':
                setModel(controllerLeftModel);
                break;
            case 'controllerRight':
                setModel(controllerRightModel);
                break;
            case 'handLeft':
                setModel(handLeftModel);
                break;
            case 'handRight':
                setModel(handRightModel);
                break;
            case 'cursor':
                setModel(cursorModel);
                break;
            default:
                setModel(cameraModel);
        }
    }, [type, userAgent, inputSourceProfile]);

    // const [remoteControlled, setRemoteControlled] = useProperty('remoteControlled');
    // const [remoteControllingClient, setRemoteControllingClient] = useProperty('remoteControllingClient');

    // const remoteControlCallback = (newValue) => {
    //     // TODO: This feature needs to be re-implemented
    //     setRemoteControlled(newValue);
    //     setRemoteControllingClient(newValue ? webstrate.clientId : '');
    // };

    return &lt;>
        {view == '3D' || type == 'cursor' ? &lt;>
            {/* {type == 'camera' ? &lt;group
                onPointerDown={() => remoteControlCallback(true)}
                onPointerUp={() => remoteControlCallback(false)}> */}
            {model}
            {/* &lt;/group> : model} */}
            {type == 'camera' || type == 'cursor' ? &lt;Billboard position={type == 'camera' ? [0, 0.11, 0] : [0, 0.05, 0.0]}>
                &lt;Text
                    // rotation={type == 'camera' ? [0, Math.PI, 0] : [0, - Math.PI / 2, 0]}
                    textAlign="center"
                    anchorX="center"
                    anchorY="middle"
                    color="black"
                    outlineWidth="5%"
                    outlineColor="white"
                    fontSize={0.05}>
                    {userName}
                &lt;/Text>
            &lt;/Billboard> : null}
            {type == 'camera' && VideoStream ? &lt;Varv property="clientVideoStream">
                &lt;VideoStream client={client} />
            &lt;/Varv> : null}
        &lt;/> : null}
        {AudioStream ? &lt;Varv property="clientAudioStream">
            &lt;AudioStream client={client} />
        &lt;/Varv> : null}
    &lt;/>;
}

function AvatarInSameSpace() {
    const [position] = useProperty('position');
    const [rotation] = useProperty('rotation');

    return &lt;group position={position} rotation={rotation}>
        &lt;AvatarModel />
    &lt;/group>;
}

// FIXME: Skip this case for now as it requires to also work in the other direction
// function AvatarInOtherSpace() {
//     const [boundaryOrigin] = useProperty('boundaryOrigin');
//     const [otherSpaceRelativePosition] = useProperty('otherSpaceRelativePosition');
//     const [otherSpaceRelativeRotation] = useProperty('otherSpaceRelativeRotation');

//     return &lt;group position={boundaryOrigin}>
//         &lt;group position={otherSpaceRelativePosition} rotation={otherSpaceRelativeRotation}>
//             &lt;AvatarModel />
//         &lt;/group>
//     &lt;/group>;
// }

function AvatarInOtherContainer() {
    const [position] = useProperty('position'); // From container
    const [rotation] = useProperty('rotation'); // From container
    const [otherSpaceRelativePosition] = useProperty('otherSpaceRelativePosition');
    const [otherSpaceRelativeRotation] = useProperty('otherSpaceRelativeRotation');

    return &lt;group position={position} rotation={rotation}>
        &lt;group position={otherSpaceRelativePosition} rotation={otherSpaceRelativeRotation}>
            &lt;AvatarModel />
        &lt;/group>
    &lt;/group>;
}

function Avatar() {
    const [space] = useProperty('space');
    const [otherSpace] = useProperty('otherSpace');
    const [currentSpace] = useProperty('locationHash');
    const [active] = useProperty('active');

    const [location, setLocation] = useState('');
    const [targetContainer, setTargetContainer] = useState(null);

    useEffect(() => {
        if (!space || !currentSpace) {
            setLocation('');
            return;
        }

        const runAsync = async () => {
            if (space == currentSpace) {
                // Avatar is in the current space
                setLocation('same');
            } else if (otherSpace == currentSpace) {
                // Avatar is in another space but close to a container
                // that contains the current space
                setLocation('other');
            } else {
                const containerConcept = await VarvEngine.getConceptFromType('Container');

                const containersInCurrentSpace = await VarvEngine.lookupInstances(['Container'], FilterAction.constructFilter({
                    and: [
                        { property: 'space', equals: currentSpace },
                        { property: 'containedSpace', unequals: '' },
                        { property: 'collaborationLevel', equals: 'close' }
                    ]
                }));

                const containersWithOtherSpace = await Promise.all(containersInCurrentSpace.map(async container => {
                    return {
                        container: container,
                        containedSpace: await containerConcept.getPropertyValue(container, 'containedSpace')
                    };
                })).then(containers => containers.filter(container => {
                    return otherSpace == container.containedSpace;
                }));

                const newTargetContainer = containersWithOtherSpace.find(container => container.containedSpace == otherSpace);


                if (newTargetContainer) {
                    // Avatar is in another space but close to a container
                    // that contained space is also contained in the current scene
                    setTargetContainer(newTargetContainer.container);
                    setLocation('otherContainer');
                } else {
                    // Avatar is not visible
                    setTargetContainer(null);
                    setLocation('');
                }
            }
        };

        runAsync();
    }, [space, otherSpace, currentSpace]);

    return active && location ? &lt;>
        {location == 'same' ? &lt;AvatarInSameSpace /> : null}
        {/* {location == 'other' ? &lt;Varv property="locationHash">
            &lt;AvatarInOtherSpace />
        &lt;/Varv> : null} */}
        {location == 'otherContainer' ? &lt;Varv target={targetContainer}>
            &lt;AvatarInOtherContainer />
        &lt;/Varv> : null}
    &lt;/> : null;
}

// FIXME: This does not work with the container case anymore
// function AvatarRemoteController() {
//     const [remoteControlled] = useProperty('remoteControlled');
//     const [position] = useProperty('position');
//     const [rotation] = useProperty('rotation');

//     const camera = useThree(state => state.camera);

//     useFrame(() => {
//         if (remoteControlled) {
//             camera.position.set(position[0], position[1], position[2]);
//             camera.rotation.set(rotation[0], rotation[1], rotation[2]);
//         }
//     });
// }

function Avatars() {
    return &lt;>
        &lt;Varv concept="Avatar" if="!isMine">
            &lt;Avatar />
        &lt;/Varv>
        {/* &lt;Varv concept="Avatar" if="isMine">
            &lt;AvatarRemoteController />
        &lt;/Varv> */}
    &lt;/>;
}



export function Main() {
    return &lt;Varv concept="AvatarManager" if="enabled">
        &lt;Avatars />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Avatar Canvas Controller" class="dynamic-canvas-component">import React from 'react';
const { useState, useEffect, useRef, useCallback } = React;
import { useEditor } from 'tldraw';
import { Varv, useProperty } from '#VarvReact';

import { useTransform } from '#Spatialstrates .movable';
import { projectToCanvas, CANVAS_SCALE } from '#Spatialstrates .projection-helpers';



function AvatarCanvasController({ parent }) {
    const [conceptUUID] = useProperty('concept::uuid');
    const [shapeID, setShapeID] = useState();
    const transform = useTransform();
    const [projectionPlane] = useProperty('projectionPlane');
    const [boundaryOrigin] = useProperty('boundaryOrigin');
    const [type] = useProperty('type');

    const editor = useEditor();
    const isBeingUpdated = useRef(false);

    // Dragging: Varv -> tldraw
    // Create or update the shape when the position of the concept changes
    const updateTldrawFromVarv = useCallback(() => {
        if (!editor) return;
        if (shapeID == undefined) return;
        if (!transform.initialized) return;
        if (!editor.shapeUtils.hasOwnProperty('Avatar')) return;
        if (isBeingUpdated.current) return;
        if (!type) return;

        let x;
        let y;

        if (parent) {
            // Center the projection plane around the origin of the boundary when in a container
            [x, y] = projectToCanvas(transform.position, [
                boundaryOrigin[0],
                boundaryOrigin[1],
                boundaryOrigin[2],
                projectionPlane[3],
                projectionPlane[4],
                projectionPlane[5],
                projectionPlane[6],
                projectionPlane[7],
                projectionPlane[8],
                projectionPlane[9],
                projectionPlane[10],
                projectionPlane[11]
            ]);
        } else {
            [x, y] = projectToCanvas(transform.position, projectionPlane);
        }

        if (!editor.getShape(shapeID)) {
            editor.createShape({
                id: shapeID,
                isLocked: true,
                type: 'Avatar',
                x: x * CANVAS_SCALE,
                y: -y * CANVAS_SCALE,
                props: {
                    conceptUUID: conceptUUID,
                    conceptType: 'Avatar',
                    avatarType: type,
                    zIndex: transform.position[2]
                },
                parentId: parent || 'page:page'
            });
        } else {
            isBeingUpdated.current = true;
            editor.updateShape({
                id: shapeID,
                isLocked: false
            });
            editor.updateShape({
                id: shapeID,
                type: 'Avatar',
                isLocked: true,
                x: x * CANVAS_SCALE,
                y: -y * CANVAS_SCALE,
                props: {
                    zIndex: transform.position[2]
                },
                parentId: parent || 'page:page'
            });
            isBeingUpdated.current = false;
        }
    }, [editor, shapeID, conceptUUID, transform.initialized, projectionPlane, boundaryOrigin, type]);

    // Set the shape ID based on the concept UUID
    useEffect(() => {
        if (!conceptUUID) return;
        setShapeID('shape:' + conceptUUID);

        const concept = VarvEngine.getConceptFromUUID(conceptUUID);
        if (!concept) return;

        const updatePosition = async (changeUUID) => {
            if (changeUUID !== conceptUUID) return;
            updateTldrawFromVarv();
        };

        updatePosition(conceptUUID);
        concept.getProperty('position').addUpdatedCallback(updatePosition);

        return () => {
            if (!concept) return;
            try {
                concept.getProperty('position').removeUpdatedCallback(updatePosition);
            } catch (e) {
                // Do nothing, this can crash when the VarvEngine restarts
            }
        };
    }, [conceptUUID, updateTldrawFromVarv]);

    // Removing: Varv -> tldraw
    // Delete the shape when the component unmounts/the concept is deleted
    useEffect(() => {
        return () => {
            if (!editor) return;
            if (shapeID == undefined) return;

            editor.updateShape({
                id: shapeID,
                isLocked: false
            });
            editor.deleteShape(shapeID);
        };
    }, [editor, shapeID]);
}

function AvatarChecker() {
    const [currentSpace] = useProperty('locationHash');
    const [space] = useProperty('space');

    return currentSpace && currentSpace == space ? &lt;AvatarCanvasController /> : null;
}

export function Main() {
    return &lt;Varv concept="AvatarManager" if="enabled">
        &lt;Varv property="locationHash">
            &lt;Varv concept="Avatar" if="!isMine">
                &lt;AvatarChecker />
            &lt;/Varv>
            {/* &lt;Varv concept="Avatar" if="isMine">
            &lt;AvatarRemoteController />
        &lt;/Varv> */}
        &lt;/Varv>
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Avatar Shape" class="dynamic-shape-component">import React from 'react';
import { HTMLContainer, Rectangle2d, BaseBoxShapeUtil, T } from 'tldraw';
import { Varv, useProperty } from '#VarvReact';

import { CANVAS_SCALE } from '#Spatialstrates .projection-helpers';
import { MovableVarvScope } from '#Spatialstrates .movable-shape';



let AudioStream;
if (Fragment.one('#AudioStream .default')) {
    const audioStreamModule = await Fragment.one('#AudioStream .default').require();
    AudioStream = audioStreamModule.AudioStream;
}



function AvatarShape({ shape }) {
    const [userName] = useProperty('userName');
    const [client] = useProperty('client');
    const [view] = useProperty('view');
    const [type] = useProperty('type');

    return &lt;>
        {AudioStream ? &lt;Varv property="clientAudioStream">
            &lt;AudioStream client={client} />
        &lt;/Varv> : null}
        {view === '3D' ? (
            &lt;HTMLContainer
                className={`avatar-shape type-${type || ''}`}
                style={{
                    transform: 'translate(-50%, -50%)',
                    width: shape.props.w + 'px',
                    height: shape.props.h + 'px'
                }}
            >
                &lt;div className="user-name">{userName}&lt;/div>
                &lt;div className={`icon type-${type}`} />
            &lt;/HTMLContainer>
        ) : null}
        {type === 'cursor' ? (
            &lt;HTMLContainer
                className={`avatar-shape type-${type || ''}`}
                style={{
                    position: 'relative',
                    transform: 'translate(-50%, -50%)',
                    width: shape.props.w + 'px',
                    height: shape.props.h + 'px',
                }}
            >
                {/* Vertical Line */}
                &lt;div style={{
                    position: 'absolute',
                    left: '50%',
                    top: 0,
                    transform: 'translateX(-50%)',
                    width: '2px',
                    height: '100%',
                    backgroundColor: 'skyblue'
                }} />
                {/* Horizontal Line */}
                &lt;div style={{
                    position: 'absolute',
                    top: '50%',
                    left: 0,
                    transform: 'translateY(-50%)',
                    width: '100%',
                    height: '2px',
                    backgroundColor: 'skyblue'
                }} />
                {/* Center Dot */}
                &lt;div style={{
                    position: 'absolute',
                    top: '50%',
                    left: '50%',
                    width: '6px',
                    height: '6px',
                    borderRadius: '50%',
                    backgroundColor: 'skyblue',
                    transform: 'translate(-50%, -50%)'
                }} />
                &lt;div className="user-name" style={{
                    position: 'absolute',
                    top: '4px'
                }}>
                    {userName}
                &lt;/div>
            &lt;/HTMLContainer>
        ) : null}
    &lt;/>;
}

export class AvatarShapeUtil extends BaseBoxShapeUtil {
    static type = 'Avatar';
    static props = {
        conceptUUID: T.string,
        conceptType: T.string,
        avatarType: T.string,
        w: T.number,
        h: T.number,
        zIndex: T.number
    };

    getDefaultProps() {
        return {
            conceptUUID: false,
            conceptType: false,
            avatarType: false,
            w: CANVAS_SCALE * 0.1,
            h: CANVAS_SCALE * 0.1,
            zIndex: 0
        };
    }

    canBind = () => true;
    canCrop = () => false;
    canEdit = () => false;
    canResize = () => false;
    canScroll = () => false;
    canSnap = () => false;
    isAspectRatioLocked = () => true;
    hideRotateHandle = () => true;

    getGeometry(shape) {
        return new Rectangle2d({
            x: -shape.props.w / 2,
            y: -shape.props.h / 2,
            width: shape.props.w,
            height: shape.props.h,
            isFilled: true,
        });
    }

    indicator(shape) {
        return &lt;rect
            x={-shape.props.w / 2}
            y={-shape.props.h / 2}
            width={shape.props.w}
            height={shape.props.h}
        />;
    }

    component(shape) {
        return &lt;MovableVarvScope shape={shape}>
            &lt;AvatarShape shape={shape} />
        &lt;/MovableVarvScope>;
    }
}

export const Main = AvatarShapeUtil;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Avatar Transmitter Scene" id class="dynamic-scene-component">import React from 'react';
let { useEffect, useRef, useState, useMemo } = React;
import { Vector3, Quaternion, Euler } from 'three';
import { useFrame, useThree } from '@react-three/fiber';
import { useXRInputSourceState } from '@react-three/xr';
import { Varv, useProperty } from '#VarvReact';



// Remove other people's Avatars when clients leave or join
const cleanup = () => {
    setTimeout(async () => {
        const concept = await VarvEngine.getConceptFromType('Avatar');
        const avatars = await VarvEngine.lookupInstances('Avatar');
        for (let avatar of avatars) {
            if (!webstrate.clients.includes(await concept.getPropertyValue(avatar, 'client'))) {
                concept.delete(avatar);
            }
        }
    }, 0);
};

const MAX_DISTANCE = 1.5;

const findOtherAvatarSpaces = async (avatarUUID, currentSpaceUUID, avatarPosition, avatarRotation) => {
    if (!avatarUUID) return;
    if (!currentSpaceUUID) return;
    const avatarConcept = await VarvEngine.getConceptFromType('Avatar');
    const containerConcept = await VarvEngine.getConceptFromType('Container');

    const containers = await VarvEngine.lookupInstances(['Container'], FilterAction.constructFilter({
        and: [
            { property: 'space', equals: currentSpaceUUID },
            { property: 'containedSpace', unequals: '' },
            { property: 'collaborationLevel', equals: 'close' }
        ]
    }));

    // Use a Map to store spaces with their distances to prevent duplicates
    let closestSpace = null;
    let closestContainer = null;
    let minDistance = Infinity;

    for (let container of containers) {
        const containerPosition = await containerConcept.getPropertyValue(container, 'position');
        const distance = new Vector3(...containerPosition).distanceTo(new Vector3(...avatarPosition));

        if (distance &lt; MAX_DISTANCE && distance &lt; minDistance) {
            minDistance = distance;
            closestSpace = await containerConcept.getPropertyValue(container, 'containedSpace');
            closestContainer = container;
        }
    }

    const otherSpace = closestSpace || '';
    avatarConcept.setPropertyValue(avatarUUID, 'otherSpace', otherSpace);

    let otherSpaceRelativePosition = [0, 0, 0];
    let otherSpaceRelativeRotation = [0, 0, 0];

    if (closestContainer) {
        const containerPosition = await containerConcept.getPropertyValue(closestContainer, 'position');
        const containerRotation = await containerConcept.getPropertyValue(closestContainer, 'rotation');

        const containerQuaternion = new Quaternion().setFromEuler(new Euler(...containerRotation));

        const relativePosition = new Vector3(...avatarPosition).sub(new Vector3(...containerPosition));
        relativePosition.applyQuaternion(containerQuaternion.conjugate());
        otherSpaceRelativePosition = relativePosition.toArray();

        const relativeRotation = new Quaternion().copy(containerQuaternion).multiply(new Quaternion().setFromEuler(new Euler(...avatarRotation)));
        const relativeEuler = new Euler().setFromQuaternion(relativeRotation);
        otherSpaceRelativeRotation = [relativeEuler.x, relativeEuler.y, relativeEuler.z];
    }

    avatarConcept.setPropertyValue(avatarUUID, 'otherSpaceRelativePosition', otherSpaceRelativePosition);
    avatarConcept.setPropertyValue(avatarUUID, 'otherSpaceRelativeRotation', otherSpaceRelativeRotation);
};

function UserNameForwarder({ setUserName }) {
    const [name] = useProperty('name');

    useEffect(() => {
        setUserName(name);
    }, [name]);
}

const SLOW_WRITEBACK_TIMEOUT = 500;
function AvatarTransmitter({ device, type, inputSourceProfiles }) {
    const conceptRef = useRef(null);
    const avatarConcept = VarvEngine.getConceptFromType('Avatar');
    const [currentSpace] = useProperty('locationHash');
    const [userName, setUserName] = useState('');

    useEffect(() => {
        return () => {
            if (conceptRef.current) {
                avatarConcept.setPropertyValue(conceptRef.current, 'active', false);
            }
        };
    }, []);

    useEffect(() => {
        if (!device) return;

        const runAsync = async () => {
            let uuid;
            const ids = await VarvEngine.lookupInstances('Avatar', FilterAction.constructFilter({
                and: [
                    {
                        property: 'type',
                        equals: type
                    },
                    {
                        property: 'client',
                        equals: webstrate.clientId
                    }
                ]
            }));

            if (ids.length > 0) {
                // Reuse existing concept if available
                uuid = ids[0];
            } else {
                // Otherwise create a new one
                uuid = await avatarConcept.create(null, {
                    type: type,
                    userAgent: window.navigator.userAgent,
                    client: webstrate.clientId,
                    inputSourceProfile: inputSourceProfiles ? JSON.stringify(inputSourceProfiles) : '',
                    isMine: true
                });
            }
            conceptRef.current = uuid;
        };

        runAsync();
    }, [device, type]);

    const slowWritebackTimeout = useRef(null);
    useFrame(() => {
        if (!conceptRef.current) return;
        if (!device) {
            avatarConcept.setPropertyValue(conceptRef.current, 'active', false);
        };

        if (!slowWritebackTimeout.current) {
            let newPosition, newRotation;
            if (type === 'camera') {
                newPosition = device.position.toArray();
                newRotation = [device.rotation.x, device.rotation.y, device.rotation.z];
            } else {
                const tempPosition = new Vector3();
                device?.getWorldPosition(tempPosition);
                newPosition = tempPosition.toArray();
                const tempQuaternion = new Quaternion();
                device?.getWorldQuaternion(tempQuaternion);
                const tempEuler = new Euler().setFromQuaternion(tempQuaternion);
                newRotation = [tempEuler.x, tempEuler.y, tempEuler.z];
            }

            avatarConcept.setPropertyValue(conceptRef.current, 'active', true);
            avatarConcept.setPropertyValue(conceptRef.current, 'position', newPosition);
            avatarConcept.setPropertyValue(conceptRef.current, 'rotation', newRotation);
            avatarConcept.setPropertyValue(conceptRef.current, 'space', currentSpace || '');
            avatarConcept.setPropertyValue(conceptRef.current, 'userName', userName || '');
            avatarConcept.setPropertyValue(conceptRef.current, 'view', '3D');
            findOtherAvatarSpaces(conceptRef.current, currentSpace, newPosition, newRotation);

            slowWritebackTimeout.current = setTimeout(() => {
                slowWritebackTimeout.current = null;
            }, SLOW_WRITEBACK_TIMEOUT);
        }
    });

    const forwarderMemo = useMemo(() => &lt;Varv concept="UserManager">
        &lt;Varv property="localUser">
            &lt;UserNameForwarder setUserName={setUserName} />
        &lt;/Varv>
    &lt;/Varv>, [setUserName]);

    return forwarderMemo;
}

function AvatarTransmitters() {
    const { camera } = useThree();
    const controllerRight = useXRInputSourceState('controller', 'right');
    const controllerLeft = useXRInputSourceState('controller', 'left');
    const handRight = useXRInputSourceState('hand', 'right');
    const handLeft = useXRInputSourceState('hand', 'left');

    // Ensure that Avatars are updated in the environement
    useEffect(() => {
        webstrate.on('clientPart', cleanup);
        cleanup();
        return () => webstrate.off('clientPart', cleanup);
    }, []);

    return &lt;>
        &lt;AvatarTransmitter device={camera} type="camera" />
        {controllerRight ? &lt;AvatarTransmitter device={controllerRight.object} type="controllerRight" inputSourceProfiles={controllerRight.profiles} /> : null}
        {controllerLeft ? &lt;AvatarTransmitter device={controllerLeft.object} type="controllerLeft" inputSourceProfiles={controllerLeft.profiles} /> : null}
        {handRight ? &lt;AvatarTransmitter device={handRight.object} type="handRight" inputSourceProfiles={handRight.profiles} /> : null}
        {handLeft ? &lt;AvatarTransmitter device={handLeft.object} type="handLeft" inputSourceProfiles={handLeft.profiles} /> : null}
    &lt;/>;
}



export function Main() {
    return &lt;Varv concept="AvatarManager" if="enabled">
        &lt;AvatarTransmitters />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Avatar Transmitter Canvas" id class="dynamic-canvas-component">import React from 'react';
let { useEffect, useRef, useState, useMemo } = React;
import { Vector3, Matrix4, Euler } from 'three';
import { useEditor } from 'tldraw';
import { Varv, useProperty } from '#VarvReact';

import { updatePointFromCanvas, CANVAS_SCALE } from '#Spatialstrates .projection-helpers';



const FAST_WRITEBACK_TIMEOUT = 33;

// Remove other people's Avatars when clients leave or join
const cleanup = () => {
    setTimeout(async () => {
        const concept = await VarvEngine.getConceptFromType('Avatar');
        const avatars = await VarvEngine.lookupInstances('Avatar');
        for (let avatar of avatars) {
            if (!webstrate.clients.includes(await concept.getPropertyValue(avatar, 'client'))) {
                concept.delete(avatar);
            }
        }
    }, 0);
};

function UserNameForwarder({ setUserName }) {
    const [name] = useProperty('name');

    useEffect(() => {
        setUserName(name);
    }, [name]);
}

function AvatarTransmitter({ type }) {
    const conceptRef = useRef(null);
    const avatarConcept = VarvEngine.getConceptFromType('Avatar');
    const [currentSpace] = useProperty('locationHash');
    const [userName, setUserName] = useState('');
    const editor = useEditor();
    const [projectionPlane] = useProperty('projectionPlane');

    useEffect(() => {
        return () => {
            if (conceptRef.current) {
                avatarConcept.setPropertyValue(conceptRef.current, 'active', false);
            }
        };
    }, []);

    useEffect(() => {
        const avatarFilter = FilterAction.constructFilter({
            and: [
                {
                    property: 'type',
                    equals: type
                },
                {
                    property: 'client',
                    equals: webstrate.clientId
                }
            ]
        });

        const runAsync = async () => {
            let uuid;
            const ids = await VarvEngine.lookupInstances('Avatar', avatarFilter);

            if (ids.length > 0) {
                // Reuse existing concept if available
                uuid = ids[0];
            } else {
                // Otherwise create a new one
                uuid = await avatarConcept.create(null, {
                    type: type,
                    userAgent: window.navigator.userAgent,
                    client: webstrate.clientId,
                    isMine: true
                });
            }
            conceptRef.current = uuid;
        };

        runAsync();
    }, [type]);

    useEffect(() => {
        if (!conceptRef.current) return;
        avatarConcept.setPropertyValue(conceptRef.current, 'space', currentSpace || '');
        avatarConcept.setPropertyValue(conceptRef.current, 'userName', userName || '');
        avatarConcept.setPropertyValue(conceptRef.current, 'view', '2D');

        avatarConcept.setPropertyValue(conceptRef.current, 'otherSpace', '');
        avatarConcept.setPropertyValue(conceptRef.current, 'otherSpaceRelativePosition', [0, 0, 0]);
        avatarConcept.setPropertyValue(conceptRef.current, 'otherSpaceRelativeRotation', [0, 0, 0]);
    }, [currentSpace, userName]);

    useEffect(() => {
        if (type !== 'cursor') return;
        if (!editor) return;
        if (!projectionPlane) return;

        let lastInvocation = 0;
        const throttledUpdate = (e) => {
            if (e.name != 'pointer_move') return;
            if (!conceptRef.current) return;

            const now = Date.now();
            if (now - lastInvocation >= FAST_WRITEBACK_TIMEOUT) {
                const pageCoordinates = editor.screenToPage({ x: e.point.x, y: e.point.y });

                const newPosition = updatePointFromCanvas(
                    [0, 0, 0],
                    [pageCoordinates.x / CANVAS_SCALE, -pageCoordinates.y / CANVAS_SCALE],
                    projectionPlane
                );
                avatarConcept.setPropertyValue(conceptRef.current, 'active', true);
                avatarConcept.setPropertyValue(conceptRef.current, 'position', newPosition);

                lastInvocation = now;
            }
        };

        editor.on('event', throttledUpdate);
        return () => editor.off('event', throttledUpdate);
    }, [editor, projectionPlane]);

    useEffect(() => {
        if (type !== 'cursor') return;
        if (!editor) return;
        if (!projectionPlane) return;
        if (!conceptRef.current) return;

        const xAxis = new Vector3().fromArray(projectionPlane.slice(3, 6));
        const yAxis = new Vector3().fromArray(projectionPlane.slice(6, 9));
        const zAxis = new Vector3().fromArray(projectionPlane.slice(9, 12));

        const rotationMatrix = new Matrix4().makeBasis(xAxis, yAxis, zAxis);
        const rotation = new Euler().setFromRotationMatrix(rotationMatrix);

        avatarConcept.setPropertyValue(conceptRef.current, 'rotation', [rotation.x, rotation.y, rotation.z]);
    }, [projectionPlane]);

    const forwarderMemo = useMemo(() => &lt;Varv concept="UserManager">
        &lt;Varv property="localUser">
            &lt;UserNameForwarder setUserName={setUserName} />
        &lt;/Varv>
    &lt;/Varv>, [setUserName]);

    return forwarderMemo;
}

function AvatarTransmitters() {
    useEffect(() => {
        webstrate.on('clientPart', cleanup);
        cleanup();
        return () => webstrate.off('clientPart', cleanup);
    }, []);

    return &lt;Varv concept="SpaceManager">
        &lt;Varv property="locationHash">
            &lt;AvatarTransmitter type="camera" />
            &lt;AvatarTransmitter type="cursor" />
        &lt;/Varv>
    &lt;/Varv>;
}

export function Main() {
    return &lt;Varv concept="AvatarManager" if="enabled">
        &lt;AvatarTransmitters />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Avatar Menu" class auto>import React from 'react';
import { Varv, useProperty } from '#VarvReact';

import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { addControllerSubMenu, addItemToControllerSubMenu, ControllerMenuTitle, ControllerMenuButton } from '#ControllerMenu .default';



function AvatarToggleButton() {
    const [enabled, setEnabled] = useProperty('enabled');
    return &lt;MenuButton onClick={() => setEnabled(!enabled)} toggled={enabled ? 'true' : null}>Toggle Avatars ({enabled ? 'On' : 'Off'})&lt;/MenuButton>;
}
addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'title', &lt;MenuTitle title="Media Sharing" />, 0);
addItemToSubMenu('media-sharing', 'avatars', &lt;Varv concept="AvatarManager">
    &lt;AvatarToggleButton />
&lt;/Varv>, 750);
addItemToSubMenu('media-sharing', 'spacer4', &lt;MenuSpacer />, 800);

function AvatarToggleControllerButton() {
    const [enabled, setEnabled] = useProperty('enabled');
    return &lt;ControllerMenuButton onClick={() => setEnabled(!enabled)} toggled={enabled ? 'true' : null}>Toggle Avatars ({enabled ? 'On' : 'Off'})&lt;/ControllerMenuButton>;
}
addControllerSubMenu('media-sharing', 500, false);
addItemToControllerSubMenu('media-sharing', 'title', &lt;ControllerMenuTitle title="Media Sharing" />, 0);
addItemToControllerSubMenu('media-sharing', 'avatars', &lt;Varv concept="AvatarManager">
    &lt;AvatarToggleControllerButton />
&lt;/Varv>, 750);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Init Manager Concept" auto>const initConcept = async () => {
    try {
        const managers = await VarvEngine.lookupInstances('AvatarManager');
        if (managers.length == 0) {
            await VarvEngine.getConceptFromType('AvatarManager').create(null, {});
        }
    } catch (e) {
        // Ignore
    }
};

VarvEngine.registerEventCallback('engineReloaded', () => {
    initConcept();
});

initConcept();
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Avatar Styles" auto>@mixin heading-font {
    font-weight: 500;
    font-size: 13px;
    letter-spacing: 0.25px;
}

.avatar-shape {
    padding: 4px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 2px;

    .user-name {
        @include heading-font;
        color: #000;
        font-size: 8px;
        text-overflow: ellipsis;
    }

    .icon {
        font-family: 'Material Icons';
        font-size: 32px;
        height: 32px;
        line-height: 32px;
        color: #222;

        &.type-camera:before {
            content: 'photo_camera';
        }

        &.type-controllerLeft {
            transform: rotate(-60deg);

            &:before {
                content: 'sports_esports';
            }

        }

        &.type-controllerRight {
            transform: rotate(60deg);

            &:before {
                content: 'sports_esports';
            }

        }

        &.type-handLeft {
            transform: scaleX(-1);

            &:before {
                content: 'back_hand';
            }
        }

        &.type-handRight:before {
            content: 'back_hand';
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></code-folder><code-folder name="Streaming" id><code-folder name="Managers"><wpm-package name="StreamManager" id="StreamManager"><code-fragment data-type="wpm/descriptor"><wpm-descriptor>{
    "description": "A generic stream sharing class for Webstrate servers with stream signaling support.",
    "dependencies": [],
    "assets": [],
    "version": "0.2.0"
}
</wpm-descriptor></code-fragment><code-fragment data-type="text/javascript+babel" name="Stream Manager" id class="default">const DEBUG = false;



export class StreamShare {
    /**
     * Creates a streamshare using the given element to signal
     * addition and removal of streams. Up to one stream per client
     * is possible for each element.
     */
    constructor(element) {
        let self = this;
        this.clientStreams = new Map();
        this.addedListeners = [];
        if (!element) throw new Error('Must provide an actual DOM element for signalling, was ', element);
        if (element.parentElement === undefined) throw new Error('StreamShare element must be in DOM');
        this.supported = true;
        if (!(element.webstrate && element.webstrate.signalStream)) {
            this.supported = false;
            if (DEBUG) console.log('StreamShare: The webstrate implementation or element does not support webstrate stream signalling, stream sharing is disabled', element);
            return;
        }
        this.element = element;

        this.element.webstrate.on('signalStream', function onSignalStream(clientId, meta, accept) {
            let con = accept(function (stream) {
                if (self.clientStreams.get(clientId)) {
                    if (DEBUG) console.log('StreamShare: Warning: Only one stream per client is supported per element but ' + clientId + ' shared another one...');
                }
                self.clientStreams.set(clientId, stream);
                self._onStreamAdded(clientId, stream);
            });
        });
    }

    stopSharing() {
        if (this.currentSignallingFunction) {
            this.element.webstrate.stopStreamSignal(this.currentSignallingFunction);
            this.currentSignallingFunction = null;
        }
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
            this.currentStream = null;
        }
    }

    async shareStream(media, displayOptions = null) {
        let self = this;
        if (!this.supported) {
            console.log('Tried to share a stream on an unsupported StreamShare, see previous warnings');
            return;
        }

        // Get the stream
        if (!displayOptions) {
            console.error('displayOptions are required to share a stream.');
        }

        if (this.currentStream) {
            this.stopSharing();
        }
        if (media == 'displayMedia') {
            this.currentStream = await navigator.mediaDevices.getDisplayMedia(displayOptions);
        } else {
            this.currentStream = await navigator.mediaDevices.getUserMedia(displayOptions);
        }
        this.currentSignallingFunction = function signalStream(clientId, accept) {
            let con = accept(self.currentStream, {}, () => {
                if (DEBUG) console.log('StreamShare: client ' + clientId + ' started receiving our streamshare');
            });
            con.onclose(() => {
                if (DEBUG) console.log('StreamShare: client ' + clientId + ' stopped receiving our streamshare');
            });
        };

        // Register the stream on the element
        if (DEBUG) console.log('StreamShare: Starting streamshare');
        this._onStreamAdded(webstrate.clientId, this.currentStream);
        this.element.webstrate.signalStream(this.currentSignallingFunction);
        return this.currentStream;
    }

    _onStreamAdded(client, stream) {
        // Notify listeners
        this.clientStreams.set(client, stream);
        this.addedListeners.forEach(listener => {
            listener(client, stream);
        });
    }
    addStreamAddedListener(listener) {
        this.addedListeners.push(listener);

        // Backfill with current streams
        for (let [key, value] of this.clientStreams) {
            listener(key, value);
        }
    }
    removeStreamAddedListener(listener) {
        const index = this.addedListeners.indexOf(listener);
        if (index > -1) {
            this.addedListeners.splice(index, 1);
        }
    }
}

if (!window.moduleStreamManager) {
    window.moduleStreamManager = {
        clicked: false,
        cleanupConceptTypes: []
    };
    document.addEventListener('click', () => { window.moduleStreamManager.clicked = true; });

    const cleanup = async () => {
        // Remove screenshares when a client leaves or joins
        for (const conceptType in window.moduleStreamManager.cleanupConceptTypes) {
            if (webstrate.clients.length &lt; 1) return;
            let concept = VarvEngine.getConceptFromType(conceptType);
            let shares = await (VarvEngine.lookupInstances(conceptType));
            shares.filter(share => !webstrate.clients.includes(concept.getPropertyValue(share, 'client'))).forEach(share => { concept.delete(share); });
        }
    };

    webstrate.on('clientPart', cleanup);
    webstrate.on('clientJoin', cleanup);
}

export const doIfClicked = (callback) => {
    if (window.moduleStreamManager.clicked) {
        setTimeout(() => {
            callback();
        }, 200);
    } else {
        let called = false;
        document.addEventListener('click', () => {
            if (called) return;
            called = true;
            callback();
        });
    }
};

export const addCleanupConceptType = (type) => {
    window.moduleStreamManager.cleanupConceptTypes.push(type);
};
</code-fragment></wpm-package><wpm-package id="ScreenStreamManager" name="ScreenStreamManager"><code-fragment data-type="wpm/descriptor"><wpm-descriptor>{
    "description": "Stream manager for screen share streams.",
    "dependencies": [
        "#StreamManager"
    ],
    "assets": [],
    "version": "0.2.0"
}
</wpm-descriptor></code-fragment><code-fragment data-type="text/javascript+babel" name="Screen Stream Manager" id class="default">import { doIfClicked, StreamShare, addCleanupConceptType } from '#StreamManager .default';
import { createMovable } from '#Spatialstrates .movable-helpers';



const STREAM_ELEMENT = 'screen-signaling';
let DOM_ELEMENT = document.querySelector(STREAM_ELEMENT);
if (!DOM_ELEMENT) {
    DOM_ELEMENT = document.createElement(STREAM_ELEMENT);
    document.body.appendChild(DOM_ELEMENT);
    WPMv2.stripProtection(DOM_ELEMENT);
}
const CONCEPT_NAME = 'ScreenStream';
const ID_PREFIX = CONCEPT_NAME + '-';
export const QUERY_PREFIX = '#' + ID_PREFIX;



// Hook up new streams with a video element
if (!window.moduleScreenStreamManager) {
    window.moduleScreenStreamManager = {
        streamShare: new StreamShare(DOM_ELEMENT)
    };

    addCleanupConceptType(CONCEPT_NAME);

    window.moduleScreenStreamManager.streamShare.addStreamAddedListener((client, stream) => {
        console.log('Got screenStream from ' + client);

        // Find or create their element
        let element = document.querySelector(QUERY_PREFIX + client);
        if (!element) {
            element = document.createElement('video');
            element.style.position = 'fixed';
            element.style.width = '0px';
            element.id = ID_PREFIX + client;
            element.muted = true;
            document.body.appendChild(element);
        }
        element.srcObject = stream;
        doIfClicked(() => { element.play(); });
    });

    // Convenience functions for managing Varv spawning and despawning
    window.stopSharingMyScreen = async () => {
        window.moduleScreenStreamManager.streamShare.stopSharing();
        const concept = VarvEngine.getConceptFromType(CONCEPT_NAME);
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        instances.forEach(instance => concept.delete(instance));
    };
    window.shareMyScreen = async () => {
        const stream = await window.moduleScreenStreamManager.streamShare.shareStream('displayMedia', {
            video: {
                displaySurface: 'browser',
            },
            audio: {
                suppressLocalAudioPlayback: false,
            },
            preferCurrentTab: false,
            selfBrowserSurface: 'exclude',
            systemAudio: 'exclude',
            surfaceSwitching: 'include',
            monitorTypeSurfaces: 'include',
        });
        if (stream) {
            stream.getVideoTracks()[0].addEventListener('ended', () => {
                window.stopSharingMyScreen();
            });
            return createMovable(CONCEPT_NAME, { client: webstrate.clientId });
        }
    };
}

export const streamShare = window.moduleScreenStreamManager.streamShare;
</code-fragment></wpm-package><wpm-package id="VideoStreamManager" name="VideoStreamManager"><code-fragment data-type="wpm/descriptor"><wpm-descriptor>{
    "description": "Stream manager for camera video streams.",
    "dependencies": [
        "#StreamManager"
    ],
    "assets": [],
    "version": "0.2.0"
}
</wpm-descriptor></code-fragment><code-fragment data-type="text/javascript+babel" name="Video Stream Manager" id class="default">import { doIfClicked, StreamShare, addCleanupConceptType } from '#StreamManager .default';



const STREAM_ELEMENT = 'video-signaling';
let DOM_ELEMENT = document.querySelector(STREAM_ELEMENT);
if (!DOM_ELEMENT) {
    DOM_ELEMENT = document.createElement(STREAM_ELEMENT);
    document.body.appendChild(DOM_ELEMENT);
    WPMv2.stripProtection(DOM_ELEMENT);
}
const CONCEPT_NAME = 'VideoStream';
const ID_PREFIX = CONCEPT_NAME + '-';
export const QUERY_PREFIX = '#' + ID_PREFIX;



// Hook up new streams with a video element
if (!window.moduleVideoStreamManager) {
    window.moduleVideoStreamManager = {
        streamShare: new StreamShare(DOM_ELEMENT)
    };

    addCleanupConceptType(CONCEPT_NAME);

    window.moduleVideoStreamManager.streamShare.addStreamAddedListener((client, stream) => {
        console.log('Got videoStream from ' + client);

        // Find or create their element
        let element = document.querySelector(QUERY_PREFIX + client);
        if (!element) {
            element = document.createElement('video');
            element.style.position = 'fixed';
            element.style.width = '0px';
            element.id = ID_PREFIX + client;
            element.muted = true;
            document.body.appendChild(element);
        }
        element.srcObject = stream;
        doIfClicked(() => { element.play(); });
    });

    // Convenience functions for managing Varv spawning and despawning
    window.stopSharingMyVideo = async () => {
        window.moduleVideoStreamManager.streamShare.stopSharing();
        const concept = VarvEngine.getConceptFromType(CONCEPT_NAME);
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        instances.forEach(instance => concept.delete(instance));
    };
    window.shareMyVideo = async () => {
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        if (instances.length > 0) {
            console.log('Already sharing video');
            return;
        }
        const stream = await window.moduleVideoStreamManager.streamShare.shareStream('userMedia', {
            video: true,
            audio: false
        });
        if (stream) {
            stream.getVideoTracks()[0].addEventListener('ended', () => {
                window.stopSharingMyVideo();
            });
            return VarvEngine.getConceptFromType(CONCEPT_NAME).create(null, { client: webstrate.clientId });
        }
    };
}

export const streamShare = window.moduleVideoStreamManager.streamShare;
</code-fragment></wpm-package><wpm-package id="AudioStreamManager" name="AudioStreamManager"><code-fragment data-type="wpm/descriptor"><wpm-descriptor>{
    "description": "Stream manager for audio streams.",
    "dependencies": [
        "#StreamManager"
    ],
    "assets": [],
    "version": "0.2.0"
}
</wpm-descriptor></code-fragment><code-fragment data-type="text/javascript+babel" name="Audio Stream Manager" id class="default">import { StreamShare, addCleanupConceptType } from '#StreamManager .default';



const STREAM_ELEMENT = 'audio-signaling';
let DOM_ELEMENT = document.querySelector(STREAM_ELEMENT);
if (!DOM_ELEMENT) {
    DOM_ELEMENT = document.createElement(STREAM_ELEMENT);
    document.body.appendChild(DOM_ELEMENT);
    WPMv2.stripProtection(DOM_ELEMENT);
}
const CONCEPT_NAME = 'AudioStream';
const ID_PREFIX = CONCEPT_NAME + '-';
export const QUERY_PREFIX = '#' + ID_PREFIX;



// Hook up new streams with a video element
if (!window.moduleAudioStreamManager) {
    window.moduleAudioStreamManager = {
        streamShare: new StreamShare(DOM_ELEMENT)
    };

    addCleanupConceptType(CONCEPT_NAME);

    window.moduleAudioStreamManager.streamShare.addStreamAddedListener((client, stream) => {
        console.log('Got audioStream from ' + client);

        // Find or create their element
        // let element = document.querySelector(QUERY_PREFIX + client);
        // if (!element) {
        //     element = document.createElement('video');
        //     element.style.position = 'fixed';
        //     element.style.width = '0px';
        //     element.id = ID_PREFIX + client;
        //     element.muted = client == webstrate.clientId;
        //     document.body.appendChild(element);
        // }
        // element.srcObject = stream;
        // doIfClicked(() => { element.play(); });
    });

    // Convenience functions for managing Varv spawning and despawning
    window.stopSharingMyAudio = async () => {
        window.moduleAudioStreamManager.streamShare.stopSharing();
        const concept = VarvEngine.getConceptFromType(CONCEPT_NAME);
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        instances.forEach(instance => concept.delete(instance));
    };
    window.shareMyAudio = async () => {
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        if (instances.length > 0) {
            console.log('Already sharing audio');
            return;
        }
        const stream = await window.moduleAudioStreamManager.streamShare.shareStream('userMedia', {
            video: false,
            audio: true
        });
        if (stream) {
            stream.getAudioTracks()[0].addEventListener('ended', () => {
                window.stopSharingMyAudio();
            });
            return VarvEngine.getConceptFromType(CONCEPT_NAME).create(null, { client: webstrate.clientId });
        }
    };
}



export const streamShare = window.moduleAudioStreamManager.streamShare;
</code-fragment></wpm-package></code-folder><code-folder name="Components"><wpm-package id="ScreenStream" name="ScreenStream"><code-fragment data-type="wpm/descriptor"><wpm-descriptor>{
    "description": "Stream component for screen streams.",
    "dependencies": [
        "#StreamManager",
        "#ScreenStreamManager",
        "#Menu"
    ],
    "assets": [],
    "version": "0.2.0"
}
</wpm-descriptor></code-fragment><code-fragment data-type="text/varv" name="Screen Stream Concepts" auto>{
    "concepts": {
        "ScreenStream": {
            "schema": {
                "client": "string"
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</code-fragment><code-fragment data-type="text/javascript+babel" name="Screen Stream Component" class="default dynamic-space-scene-component">import React from 'react';
const { useState, useEffect, useMemo } = React;
import { MeshStandardMaterial, LinearMipmapLinearFilter, SRGBColorSpace } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { Plane } from '@react-three/drei';
import { useProperty } from '#VarvReact';

import { Movable, SELECTED_COLOR_PRIMARY, HOVERED_SELECTED_COLOR_PRIMARY } from '#Spatialstrates .movable';
import { doIfClicked } from '#StreamManager .default';
import { QUERY_PREFIX, streamShare } from '#ScreenStreamManager .default';



const MAX_SIZE = 0.75;

const frameGeometry = new RoundedBoxGeometry(1, 1, 0.005, 1);
const frameMaterial = new MeshStandardMaterial({ color: '#E0E0E0', metalness: 0.2, roughness: 0.5 });
const frameMaterialHovered = new MeshStandardMaterial({ color: '#FFFFFF', metalness: 0.2, roughness: 0.5 });
const frameMaterialSelected = new MeshStandardMaterial({ color: SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });
const frameMaterialHoveredSelected = new MeshStandardMaterial({ color: HOVERED_SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });



function ScreenStream() {
    const [client] = useProperty('client');

    const [screen, setScreen] = useState(document.querySelector(QUERY_PREFIX + client));
    const [width, setWidth] = useState(MAX_SIZE);
    const [height, setHeight] = useState(MAX_SIZE);

    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');

    const updateSize = (aspectRatio) => {
        if (aspectRatio > 1) {
            setWidth(MAX_SIZE);
            setHeight(MAX_SIZE / aspectRatio);
        } else {
            setWidth(MAX_SIZE * aspectRatio);
            setHeight(MAX_SIZE);
        }
    };

    useEffect(() => {
        if (screen) {
            // Playing immediately may fail, wait for interaction in that case
            doIfClicked(() => {
                updateSize(screen.videoWidth / screen.videoHeight || 1);
                screen.addEventListener('resize', () => {
                    updateSize(screen.videoWidth / screen.videoHeight || 1);
                })
            });
        }

        // Make sure to catch stream updates
        let listener = function (newStreamId) {
            if (newStreamId == client) setScreen(document.querySelector(QUERY_PREFIX + client));
        };
        streamShare.addStreamAddedListener(listener);

        return () => {
            streamShare.removeStreamAddedListener(listener);
        }
    }, [screen, client]);

    const texture = useMemo(() => screen ? &lt;videoTexture attach='map' args={[screen]} anisoptry={16} generateMipmaps={true} minFilter={LinearMipmapLinearFilter} colorSpace={SRGBColorSpace} /> : null, [screen]);

    const handle = useMemo(() => &lt;mesh
        geometry={frameGeometry}
        material={selected ? (hovered ? frameMaterialHoveredSelected : frameMaterialSelected) : (hovered ? frameMaterialHovered : frameMaterial)}
        scale={[width + 0.02, height + 0.02, 1]}
        position={[0, 0.125 - 0.0125, -0.0055]}
        autoUpdateMatrix={false}>
    &lt;/mesh>, [width, height, selected, hovered]);

    return &lt;Movable handle={handle} upright={false}>
        &lt;Plane args={[width, height]} position={[0, 0.125 - 0.0125, 0]}>
            &lt;meshBasicMaterial toneMapped={false} color={screen ? 'white' : 'darkgrey'}>
                {texture}
            &lt;/meshBasicMaterial>
        &lt;/Plane>
    &lt;/Movable>;
}


export function Main() {
    const [conceptType] = useProperty('concept::name');
    return conceptType === 'ScreenStream' ? &lt;ScreenStream /> : null;
}
</code-fragment><CODE-FRAGMENT data-type="text/javascript+babel" name="Screen Stream Shape" class="dynamic-shape-component">import React from 'react';
const { useEffect, useRef } = React;
import { useEditor, HTMLContainer } from 'tldraw';
import { useProperty } from '#VarvReact';

import { CANVAS_SCALE } from '#Spatialstrates .projection-helpers';
import { MovableShapeUtil, MovableVarvScope } from '#Spatialstrates .movable-shape';



const MAX_SIZE = 0.75;

function ScreenStreamShape({ shape }) {
    const [client] = useProperty('client');
    const editor = useEditor();
    const videoRef = useRef();

    useEffect(() => {
        if (!client) return;

        const mediaStream = moduleScreenStreamManager?.streamShare?.clientStreams?.get(client);
        if (!mediaStream) return;

        videoRef.current.srcObject = mediaStream;
        videoRef.current.play();

        videoRef.current.onloadedmetadata = () => {
            const aspectRatio = videoRef.current.videoWidth / videoRef.current.videoHeight || 1;
            let newWidth, newHeight;
            if (aspectRatio > 1) {
                newWidth = MAX_SIZE;
                newHeight = MAX_SIZE / aspectRatio;
            } else {
                newWidth = MAX_SIZE * aspectRatio;
                newHeight = MAX_SIZE
            }

            editor.updateShape({
                id: shape.id,
                props: {
                    w: newWidth * CANVAS_SCALE,
                    h: newHeight * CANVAS_SCALE
                }
            });
        };
    }, [client]);

    return &lt;HTMLContainer style={{
        transform: 'translate(-50%, -50%)',
        width: shape.props.w + 'px',
        height: shape.props.h + 'px',
        background: '#999',
        borderRadius: '8px',
        boxShadow: 'rgba(100, 100, 111, 0.4) 0px 0px 4px 0px'
    }}>
        &lt;video ref={videoRef} style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover',
            borderRadius: '8px',
        }} />
    &lt;/HTMLContainer>;
}

class ScreenStreamShapeUtil extends MovableShapeUtil {
    static type = 'ScreenStream';

    getDefaultProps() {
        return Object.assign(super.getDefaultProps(), {
            w: CANVAS_SCALE * MAX_SIZE,
            h: CANVAS_SCALE * MAX_SIZE
        });
    }

    component(shape) {
        return &lt;MovableVarvScope shape={shape}>
            &lt;ScreenStreamShape shape={shape} />
        &lt;/MovableVarvScope>;
    }
}

export const Main = ScreenStreamShapeUtil;
</CODE-FRAGMENT><code-fragment data-type="text/javascript+babel" name="Screen Stream Menu" auto>import React from 'react';

import { addSubMenu, addItemToSubMenu, MenuSpacer, MenuButton } from '#Menu .default';



// Import in order to start the manager
import ScreenStreamManager from '#ScreenStreamManager .default';



addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'share-screen', &lt;MenuButton onClick={window.shareMyScreen}>Share Screenshare&lt;/MenuButton>, 100);
addItemToSubMenu('media-sharing', 'stop-screen', &lt;MenuButton onClick={window.stopSharingMyScreen}>Stop Screenshare&lt;/MenuButton>, 200);
addItemToSubMenu('media-sharing', 'spacer1', &lt;MenuSpacer />, 250);
</code-fragment></wpm-package><wpm-package id="VideoStream" name="VideoStream"><code-fragment data-type="wpm/descriptor"><wpm-descriptor>{
    "description": "Stream component for video streams.",
    "dependencies": [
        "#StreamManager",
        "#VideoStreamManager",
        "#Menu"
    ],
    "assets": [],
    "version": "0.2.0"
}
</wpm-descriptor></code-fragment><code-fragment data-type="text/varv" name="Video Stream Concepts" auto>{
    "concepts": {
        "VideoStream": {
            "schema": {
                "client": "string"
            }
        }
    }
}</code-fragment><code-fragment data-type="text/javascript+babel" name="Video Stream Component" class="default dynamic-space-scene-component">import React from 'react';
const { useState, useEffect, useMemo } = React;
import { MeshStandardMaterial, SRGBColorSpace } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { Plane, Billboard } from '@react-three/drei';

import { doIfClicked } from '#StreamManager .default';
import { QUERY_PREFIX, streamShare } from '#VideoStreamManager .default';



const frameGeometry = new RoundedBoxGeometry(1, 1, 0.005, 1);
const frameMaterial = new MeshStandardMaterial({ color: '#E0E0E0', metalness: 0.2, roughness: 0.5 });



export function VideoStream({ client }) {
    const [video, setVideo] = useState(document.querySelector(QUERY_PREFIX + client));
    const [aspectRatio, setAspectRatio] = useState(1);

    useEffect(() => {
        if (video) {
            // Playing immediately may fail, wait for interaction in that case
            doIfClicked(() => {
                setAspectRatio(video.videoWidth / video.videoHeight);
                video.addEventListener('resize', () => {
                    setAspectRatio(video.videoWidth / video.videoHeight);
                });
            });
        }

        // Make sure to catch stream updates
        let listener = function (newStreamId) {
            if (newStreamId == client) setVideo(document.querySelector(QUERY_PREFIX + client));
        };
        streamShare.addStreamAddedListener(listener);

        return () => {
            streamShare.removeStreamAddedListener(listener);
        }
    }, [video, client]);

    let texture = useMemo(() => video ? &lt;videoTexture attach='map' args={[video]} colorSpace={SRGBColorSpace} /> : null, [video]);

    return &lt;Billboard position={[0, (0.125 / aspectRatio) + 0.2, 0]}>
        &lt;mesh geometry={frameGeometry}
            material={frameMaterial}
            position={[0, 0, -0.0055]}
            scale={[0.25 + 0.02, (0.25 / aspectRatio) + 0.02, 1]} autoUpdateMatrix={false} />
        &lt;Plane args={[0.25, 0.25 / aspectRatio]}>
            &lt;meshBasicMaterial toneMapped={false} color={video ? 'white' : 'darkgrey'}>
                {texture}
            &lt;/meshBasicMaterial>
        &lt;/Plane>
    &lt;/Billboard>;
}
</code-fragment><code-fragment data-type="text/javascript+babel" name="Video Stream Menu" auto>import React from 'react';

import { addSubMenu, addItemToSubMenu, MenuSpacer, MenuButton } from '#Menu .default';



// Import in order to start the manager
import VideoStreamManager from '#VideoStreamManager .default';



addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'share-video', &lt;MenuButton onClick={window.shareMyVideo}>Share Video&lt;/MenuButton>, 300);
addItemToSubMenu('media-sharing', 'stop-video', &lt;MenuButton onClick={window.stopSharingMyVideo}>Stop Video&lt;/MenuButton>, 400);
addItemToSubMenu('media-sharing', 'spacer2', &lt;MenuSpacer />, 450);
</code-fragment></wpm-package><wpm-package id="AudioStream" name="AudioStream"><code-fragment data-type="wpm/descriptor"><wpm-descriptor>{
    "description": "Stream component for audio streams.",
    "dependencies": [
        "#AudioStreamManager",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [],
    "version": "0.2.0"
}
</wpm-descriptor></code-fragment><code-fragment data-type="text/varv" name="Audio Stream Concepts" auto>{
    "concepts": {
        "AudioStream": {
            "schema": {
                "client": "string"
            }
        }
    }
}
</code-fragment><code-fragment data-type="text/javascript+babel" name="Audio Stream Component" class="default">import React from 'react';
const { useEffect, useRef } = React;
// import { PositionalAudio } from '@react-three/drei';
// import { ErrorBoundary } from 'react-error-boundary';
import { Varv, useProperty } from '#VarvReact';

import { doIfClicked } from '#StreamManager .default';
import { streamShare } from '#AudioStreamManager .default';



function AudioStream3D({ client }) {
    const audioRef = useRef(new Audio());
    // const positionalAudioRef = useRef();
    // const boundaryRef = useRef();

    useEffect(() => {
        if (!client) return;
        const listener = (newStreamId, newStream) => {
            if (newStreamId == client) {
                // if (boundaryRef.current) boundaryRef.current.resetErrorBoundary();
                doIfClicked(() => {
                    audioRef.current.srcObject = newStream;
                    audioRef.current.muted = false;
                    audioRef.current.play();

                    // positionalAudioRef.current?.setMediaStreamSource(audioRef.current.srcObject);
                });
            }
        };

        streamShare.addStreamAddedListener(listener);

        return () => {
            streamShare.removeStreamAddedListener(listener);
            audioRef.current.srcObject = null;
        };
    }, [client]);

    // FIXME: For whatever reason this does not work anymore.
    // return &lt;ErrorBoundary ref={boundaryRef} fallback={null}>
    //     &lt;PositionalAudio ref={positionalAudioRef}
    //         rolloffFactor={1}
    //         distance={1} />
    // &lt;/ErrorBoundary>;
}

function AudioStream2D({ client }) {
    const audioRef = useRef(new Audio());

    useEffect(() => {
        if (!client) return;
        const listener = (newStreamId, newStream) => {
            if (newStreamId == client) {
                doIfClicked(() => {
                    audioRef.current.srcObject = newStream;
                    audioRef.current.muted = false;
                    audioRef.current.play();
                });
            }
        };

        streamShare.addStreamAddedListener(listener);

        return () => {
            streamShare.removeStreamAddedListener(listener);
        };
    }, [client]);

    return &lt;audio ref={audioRef} autoPlay muted />;
}

function AudioSplitter({ client }) {
    const [currentView] = useProperty('currentView');

    return &lt;>
        {currentView == '3D' ? &lt;AudioStream3D client={client} /> : null}
        {currentView == '2D' ? &lt;AudioStream2D client={client} /> : null}
    &lt;/>;
}

export function AudioStream({ client }) {
    return &lt;Varv concept="SpaceManager">
        &lt;AudioSplitter client={client} />
    &lt;/Varv>;
}
</code-fragment><code-fragment data-type="text/javascript+babel" name="Audio Stream Menu" auto>import React from 'react';

import { addSubMenu, addItemToSubMenu, MenuSpacer, MenuButton } from '#Menu .default';
import { addControllerSubMenu, addItemToControllerSubMenu, ControllerMenuSpacer, ControllerMenuButton } from '#ControllerMenu .default';



// Import in order to start the manager
import AudioStreamManager from '#AudioStreamManager .default';



addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'share-audio', &lt;MenuButton onClick={window.shareMyAudio}>Share Audio&lt;/MenuButton>, 500);
addItemToSubMenu('media-sharing', 'stop-audio', &lt;MenuButton onClick={window.stopSharingMyAudio}>Stop Audio&lt;/MenuButton>, 600);
addItemToSubMenu('media-sharing', 'spacer3', &lt;MenuSpacer />, 700);

addControllerSubMenu('media-sharing', 500, false);
addItemToControllerSubMenu('media-sharing', 'share-audio', &lt;ControllerMenuButton onClick={window.shareMyAudio}>Share Audio&lt;/ControllerMenuButton>, 500);
addItemToControllerSubMenu('media-sharing', 'stop-audio', &lt;ControllerMenuButton onClick={window.stopSharingMyAudio}>Stop Audio&lt;/ControllerMenuButton>, 600);
addItemToControllerSubMenu('media-sharing', 'spacer3', &lt;ControllerMenuSpacer />, 700);
</code-fragment></wpm-package></code-folder></code-folder><code-folder name="Movables" id><WPM-PACKAGE id="StickyNote" name="StickyNote" class><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple sticky note component.",
    "dependencies": [
        "#Icon",
        "#AIHelpers",
        "#Menu",
        "#ControllerMenu",
        "#Text"
    ],
    "assets": [
        "microphone.glb"
    ],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Sticky Note Concepts" auto>{
    "concepts": {
        "StickyNote": {
            "schema": {
                "text": "string",
                "color": { "string": {
                    "default": "yellow"
                }}
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Sticky Note Component" class="default">import React from 'react';
const { useState, useMemo, useRef } = React;
import { MeshStandardMaterial } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useFrame } from '@react-three/fiber';
import { useGLTF } from '@react-three/drei';
import { Text as UIText, Root, Container as UIContainer } from '@react-three/uikit';
import { Defaults, Card, Button, List, ListItem } from '@react-three/uikit-apfel';
import { useProperty } from '#VarvReact';

import { Movable } from '#Spatialstrates .movable';
import { Text } from '#Spatialstrates .text';
import { Icon } from '#Icon .default';
import { transcribeAudio } from '#AIHelpers .default';




const frameGeometry = new RoundedBoxGeometry(0.15, 0.15, 0.005, 1);
useGLTF.preload('microphone.glb');

const frameMaterialMap = new Map();
frameMaterialMap.set('red', new MeshStandardMaterial({ color: 'hsl(0, 95%, 60%)', metalness: 0.2, roughness: 0.5 }));
frameMaterialMap.set('green', new MeshStandardMaterial({ color: 'hsl(120, 95%, 60%)', metalness: 0.2, roughness: 0.5 }));
frameMaterialMap.set('blue', new MeshStandardMaterial({ color: 'hsl(204, 95%, 60%)', metalness: 0.2, roughness: 0.5 }));
frameMaterialMap.set('yellow', new MeshStandardMaterial({ color: 'hsl(49, 98%, 60%)', metalness: 0.2, roughness: 0.5 }));
frameMaterialMap.set('purple', new MeshStandardMaterial({ color: 'hsl(250, 85%, 60%)', metalness: 0.2, roughness: 0.5 }));
frameMaterialMap.set('orange', new MeshStandardMaterial({ color: 'hsl(28, 95%, 60%)', metalness: 0.2, roughness: 0.5 }));
frameMaterialMap.set('pink', new MeshStandardMaterial({ color: 'hsl(310, 95%, 60%)', metalness: 0.2, roughness: 0.5 }));

const frameMaterialHoveredMap = new Map();
frameMaterialHoveredMap.set('red', new MeshStandardMaterial({ color: 'hsl(0, 95%, 70%)', metalness: 0.2, roughness: 0.5 }));
frameMaterialHoveredMap.set('green', new MeshStandardMaterial({ color: 'hsl(120, 95%, 70%)', metalness: 0.2, roughness: 0.5 }));
frameMaterialHoveredMap.set('blue', new MeshStandardMaterial({ color: 'hsl(204, 95%, 70%)', metalness: 0.2, roughness: 0.5 }));
frameMaterialHoveredMap.set('yellow', new MeshStandardMaterial({ color: 'hsl(49, 98%, 70%)', metalness: 0.2, roughness: 0.5 }));
frameMaterialHoveredMap.set('purple', new MeshStandardMaterial({ color: 'hsl(250, 85%, 70%)', metalness: 0.2, roughness: 0.5 }));
frameMaterialHoveredMap.set('orange', new MeshStandardMaterial({ color: 'hsl(28, 95%, 70%)', metalness: 0.2, roughness: 0.5 }));
frameMaterialHoveredMap.set('pink', new MeshStandardMaterial({ color: 'hsl(310, 95%, 70%)', metalness: 0.2, roughness: 0.5 }));

// const frameMaterialSelectedMap = new Map();
// frameMaterialSelectedMap.set('red', new MeshStandardMaterial({ color: 'hsl(0, 95%, 65%)', metalness: 0.2, roughness: 0.5 }));
// frameMaterialSelectedMap.set('green', new MeshStandardMaterial({ color: 'hsl(120, 95%, 65%)', metalness: 0.2, roughness: 0.5 }));
// frameMaterialSelectedMap.set('blue', new MeshStandardMaterial({ color: 'hsl(204, 95%, 65%)', metalness: 0.2, roughness: 0.5 }));
// frameMaterialSelectedMap.set('yellow', new MeshStandardMaterial({ color: 'hsl(49, 98%, 65%)', metalness: 0.2, roughness: 0.5 }));
// frameMaterialSelectedMap.set('purple', new MeshStandardMaterial({ color: 'hsl(250, 85%, 65%)', metalness: 0.2, roughness: 0.5 }));
// frameMaterialSelectedMap.set('orange', new MeshStandardMaterial({ color: 'hsl(28, 95%, 65%)', metalness: 0.2, roughness: 0.5 }));
// frameMaterialSelectedMap.set('pink', new MeshStandardMaterial({ color: 'hsl(310, 95%, 65%)', metalness: 0.2, roughness: 0.5 }));

// const frameMaterialHoveredSelectedMap = new Map();
// frameMaterialHoveredSelectedMap.set('red', new MeshStandardMaterial({ color: 'hsl(0, 95%, 75%)', metalness: 0.2, roughness: 0.5 }));
// frameMaterialHoveredSelectedMap.set('green', new MeshStandardMaterial({ color: 'hsl(120, 95%, 75%)', metalness: 0.2, roughness: 0.5 }));
// frameMaterialHoveredSelectedMap.set('blue', new MeshStandardMaterial({ color: 'hsl(204, 95%, 75%)', metalness: 0.2, roughness: 0.5 }));
// frameMaterialHoveredSelectedMap.set('yellow', new MeshStandardMaterial({ color: 'hsl(49, 98%, 75%)', metalness: 0.2, roughness: 0.5 }));
// frameMaterialHoveredSelectedMap.set('purple', new MeshStandardMaterial({ color: 'hsl(250, 85%, 75%)', metalness: 0.2, roughness: 0.5 }));
// frameMaterialHoveredSelectedMap.set('orange', new MeshStandardMaterial({ color: 'hsl(28, 95%, 75%)', metalness: 0.2, roughness: 0.5 }));
// frameMaterialHoveredSelectedMap.set('pink', new MeshStandardMaterial({ color: 'hsl(310, 95%, 75%)', metalness: 0.2, roughness: 0.5 }));



function StickyNote() {
    const iconRef = useRef();
    const microphoneIcon = useGLTF('microphone.glb');
    const [listening, setListening] = useState(false);
    const [text, setText] = useProperty('text');
    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');
    const [color, setColor] = useProperty('color');
    const [showColorOptions, setShowColorOptions] = useState(false);

    async function updateText() {
        if (listening) return;

        setListening(true);
        const newText = await transcribeAudio(5000, false, () => { setListening(false); });
        if (newText) setText(newText);
    }

    const handle = useMemo(() => &lt;mesh
        geometry={frameGeometry}
        material={hovered ? frameMaterialHoveredMap.get(color || 'yellow') : frameMaterialMap.get(color || 'yellow')}
        position={[0, 0.025, 0]}
        autoUpdateMatrix={false}
    />, [hovered, selected, color]);

    useFrame((state) => {
        if (!iconRef.current) return;
        const minScale = 0.4;
        const maxScale = 0.6;
        const targetScale = listening ? minScale + (maxScale - minScale) * (Math.sin(state.clock.elapsedTime * 5) * 0.5 + 0.5) : 0.5;
        iconRef.current.scale.setScalar(targetScale);
    });

    return &lt;Movable handle={handle} upright={false}>
        &lt;Text
            position={[0, 0.025, 0.003]} autoUpdateMatrix={false}
            maxWidth={0.13}
            textAlign='center'
            anchorX='center'
            anchorY='middle'
            color='black'
            fontSize={0.01}>
            {text}
        &lt;/Text>
        {selected ? &lt;>
            &lt;group ref={iconRef} position={[0.1, 0.025, 0]} rotation={[0, -Math.PI, 0]}>
                &lt;Icon model={microphoneIcon} onClick={updateText} />
            &lt;/group>
            &lt;group position={[0, -0.05, 0]} rotation={[0, 0, 0]}>
                &lt;Defaults>
                    &lt;Root anchorX="center" anchorY="top" flexDirection="column" pixelSize={0.0005} padding={15}>
                        &lt;Card borderRadius={24} padding={24} gap={16} flexDirection="column">
                            &lt;UIContainer flexDirection="row" gap={8} alignItems="center">
                                &lt;Button platter onClick={() => setShowColorOptions(!showColorOptions)}>
                                    &lt;UIText>Show Colors&lt;/UIText>
                                &lt;/Button>
                                {showColorOptions ? &lt;List type="plain" flexDirection="row" gap={8}>
                                    &lt;ListItem selected={color === 'red'} onClick={() => setColor('red')}>
                                        &lt;UIText>Red&lt;/UIText>
                                    &lt;/ListItem>
                                    &lt;ListItem selected={color === 'green'} onClick={() => setColor('green')}>
                                        &lt;UIText>Green&lt;/UIText>
                                    &lt;/ListItem>
                                    &lt;ListItem selected={color === 'blue'} onClick={() => setColor('blue')}>
                                        &lt;UIText>Blue&lt;/UIText>
                                    &lt;/ListItem>
                                    &lt;ListItem selected={color === 'yellow'} onClick={() => setColor('yellow')}>
                                        &lt;UIText>Yellow&lt;/UIText>
                                    &lt;/ListItem>
                                    &lt;ListItem selected={color === 'purple'} onClick={() => setColor('purple')}>
                                        &lt;UIText>Purple&lt;/UIText>
                                    &lt;/ListItem>
                                    &lt;ListItem selected={color === 'orange'} onClick={() => setColor('orange')}>
                                        &lt;UIText>Orange&lt;/UIText>
                                    &lt;/ListItem>
                                    &lt;ListItem selected={color === 'pink'} onClick={() => setColor('pink')}>
                                        &lt;UIText>Pink&lt;/UIText>
                                    &lt;/ListItem>
                                &lt;/List> : null}
                            &lt;/UIContainer>
                        &lt;/Card>
                    &lt;/Root>
                &lt;/Defaults>
            &lt;/group>
        &lt;/> : null}
    &lt;/Movable>;
}

export function Main() {
    const [conceptType] = useProperty('concept::name');
    return conceptType === 'StickyNote' ? &lt;StickyNote /> : null;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Sticky Note Menu" auto>import React from 'react';

import { createMovable } from '#Spatialstrates .movable-helpers';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { addControllerSubMenu, addItemToControllerSubMenu, ControllerMenuTitle, ControllerMenuSpacer, ControllerMenuButton } from '#ControllerMenu .default';



addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'add-sticky-note', &lt;MenuButton onClick={() => createMovable('StickyNote')}>New Sticky Note&lt;/MenuButton>, 200);
addItemToSubMenu('movables', 'spacer-items', &lt;MenuSpacer />, 400);

addControllerSubMenu('movables', 100, false);
addItemToControllerSubMenu('movables', 'title', &lt;ControllerMenuTitle title="Menu" />, 0);
addItemToControllerSubMenu('movables', 'add-sticky-note', &lt;ControllerMenuButton onClick={() => createMovable('StickyNote')}>New Sticky Note&lt;/ControllerMenuButton>, 200);
addItemToControllerSubMenu('movables', 'spacer-items', &lt;ControllerMenuSpacer />, 400);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Sticky Note Shape" class="dynamic-shape-component">import React from 'react';
const { useEffect, useRef } = React;
import { HTMLContainer, stopEventPropagation } from 'tldraw';
import { useProperty } from '#VarvReact';

import { MovableShapeUtil, MovableVarvScope } from '#Spatialstrates .movable-shape';
import { CANVAS_SCALE } from '#Spatialstrates .projection-helpers';



function StickyNoteShape({ shape, isEditing }) {
    const [selected] = useProperty('selected');
    const [text, setText] = useProperty('text');
    const [color, setColor] = useProperty('color');
    const textAreaRef = useRef(null);
    const cursorRef = useRef(0);

    useEffect(() => {
        if (textAreaRef.current) {
            textAreaRef.current.selectionStart = cursorRef.current;
            textAreaRef.current.selectionEnd = cursorRef.current;
        }
    }, [text]);

    return &lt;HTMLContainer
        className={`sticky-note-shape color-${color || 'yellow'}`}
        title="Sticky Note"
        style={{
            transform: 'translate(-50%, -50%)',
            width: shape.props.w + 'px',
            height: shape.props.h + 'px',
            pointerEvents: isEditing ? 'all' : 'none',
            borderRadius: '8px',
            boxShadow: 'rgba(100, 100, 111, 0.4) 0px 0px 4px 0px',
            padding: '4px',
            fontSize: '8px',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            textAlign: 'center',
        }}>
        {isEditing ? &lt;textarea
            ref={textAreaRef}
            title="Edit text"
            value={text}
            onChange={e => {
                cursorRef.current = e.target.selectionStart;
                setText(e.target.value);
            }}
            style={{
                width: '100%',
                height: '100%',
                border: 'none',
                outline: 'none',
                resize: 'none',
                pointerEvents: 'all',
                backgroundColor: 'transparent',
                fontFamily: 'sans-serif',
                fontSize: 'inherit',
                padding: 0
            }}
            onPointerDown={stopEventPropagation}
            onPointerMove={stopEventPropagation}
        /> : text}
        {selected ? &lt;div className="sticky-note-color-selectors" onPointerDown={stopEventPropagation}>
            &lt;div className="sticky-note-color-selector color-yellow" title="Yellow" onClick={() => setColor('yellow')}>&lt;/div>
            &lt;div className="sticky-note-color-selector color-red" title="Red" onClick={() => setColor('red')}>&lt;/div>
            &lt;div className="sticky-note-color-selector color-green" title="Green" onClick={() => setColor('green')}>&lt;/div>
            &lt;div className="sticky-note-color-selector color-blue" title="Blue" onClick={() => setColor('blue')}>&lt;/div>
            &lt;div className="sticky-note-color-selector color-purple" title="Purple" onClick={() => setColor('purple')}>&lt;/div>
            &lt;div className="sticky-note-color-selector color-orange" title="Orange" onClick={() => setColor('orange')}>&lt;/div>
            &lt;div className="sticky-note-color-selector color-pink" title="Pink" onClick={() => setColor('pink')}>&lt;/div>
        &lt;/div> : null}
    &lt;/HTMLContainer>;
}

class StickyNoteShapeUtil extends MovableShapeUtil {
    static type = 'StickyNote';

    canEdit = () => true;

    getDefaultProps() {
        return Object.assign(super.getDefaultProps(), {
            w: CANVAS_SCALE * 0.15,
            h: CANVAS_SCALE * 0.15
        });
    }

    component(shape) {
        const isEditing = this.editor.getEditingShapeId() === shape.id;

        return &lt;MovableVarvScope shape={shape}>
            &lt;StickyNoteShape shape={shape} isEditing={isEditing} />
        &lt;/MovableVarvScope>;
    }
}

export const Main = StickyNoteShapeUtil;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Sticky Note Style" auto>.sticky-note-shape {
    .sticky-note-color-selectors {
        cursor: pointer;
        pointer-events: all;
        position: absolute;
        bottom: -20px;
        left: 0;
        width: 100%;
        height: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-direction: row;
        // gap: 4px;

        .sticky-note-color-selector {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 0.5px solid hsl(0, 0%, 0%);

            &.color-red {
                background-color: hsl(0, 95%, 60%);
            }
            &.color-green {
                background-color: hsl(120, 95%, 60%);
            }
            &.color-blue {
                background-color: hsl(204, 95%, 60%);
            }
            &.color-yellow {
                background-color: hsl(60, 95%, 60%);
            }
            &.color-purple {
                background-color: hsl(270, 95%, 60%);
            }
            &.color-orange {
                background-color: hsl(30, 95%, 60%);
            }
            &.color-pink {
                background-color: hsl(310, 95%, 60%);
            }
        }
    }

    &.color-red {
        background-color: hsl(0, 95%, 60%);
    }
    &.color-green {
        background-color: hsl(120, 95%, 60%);
    }
    &.color-blue {
        background-color: hsl(204, 95%, 60%);
    }
    &.color-yellow {
        background-color: hsl(60, 95%, 60%);
    }
    &.color-purple {
        background-color: hsl(270, 95%, 60%);
    }
    &.color-orange {
        background-color: hsl(30, 95%, 60%);
    }
    &.color-pink {
        background-color: hsl(310, 95%, 60%);
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Image" name="Image"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple image component.",
    "dependencies": [
        "#Menu"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Image Concepts" auto>{
    "concepts": {
        "Image": {
            "schema": {
                "url": "string"
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="Image Component" class="default">import React from 'react';
const { useRef, useState, useEffect, useMemo } = React;
import { ErrorBoundary } from 'react-error-boundary';
import { MeshStandardMaterial } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { Image } from '@react-three/drei';
import { useProperty } from '#VarvReact';

import { Movable, SELECTED_COLOR_PRIMARY, HOVERED_SELECTED_COLOR_PRIMARY } from '#Spatialstrates .movable';



const MAX_SIZE = 0.4;

// Reuseable geometry for the image frame
const frameGeometry = new RoundedBoxGeometry(1, 1, 0.005, 1);
const frameMaterial = new MeshStandardMaterial({ color: '#E0E0E0', metalness: 0.2, roughness: 0.5 });
const frameMaterialHovered = new MeshStandardMaterial({ color: '#FFFFFF', metalness: 0.2, roughness: 0.5 });
const frameMaterialSelected = new MeshStandardMaterial({ color: SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });
const frameMaterialHoveredSelected = new MeshStandardMaterial({ color: HOVERED_SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });

function CustomImage() {
    const boundaryRef = useRef();
    const imageRef = useRef();
    const [width, setWidth] = useState(1);
    const [height, setHeight] = useState(1);
    const [url] = useProperty('url');

    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');

    // Update the aspect ratio
    useEffect(() => {
        if (boundaryRef.current) boundaryRef.current.resetErrorBoundary();
        if (imageRef.current) {
            const aspectRatio = imageRef.current.material.__r3f.memoizedProps.imageBounds[0] / imageRef.current.material.__r3f.memoizedProps.imageBounds[1] || 1;
            if (aspectRatio > 1) {
                setWidth(MAX_SIZE);
                setHeight(MAX_SIZE / aspectRatio);
            } else {
                setWidth(MAX_SIZE * aspectRatio);
                setHeight(MAX_SIZE);
            }
        }
    }, [url, imageRef]);

    const handle = useMemo(() => &lt;mesh
        geometry={frameGeometry}
        material={selected ? (hovered ? frameMaterialHoveredSelected : frameMaterialSelected) : (hovered ? frameMaterialHovered : frameMaterial)}
        scale={[width + 0.02, height + 0.02, 1]}
        position={[0, 0, -0.0029]}
        autoUpdateMatrix={false}>
    &lt;/mesh>, [width, height, selected, hovered]);

    return &lt;Movable handle={handle} upright={false}>
        &lt;ErrorBoundary ref={boundaryRef} fallback={null}>
            {url ? &lt;Image ref={imageRef} url={url} position={[0, 0, 0]} scale={[width, height, 1]} autoUpdateMatrix={false}>
                &lt;planeGeometry args={[1, 1]} />
            &lt;/Image> : null}
        &lt;/ErrorBoundary>
    &lt;/Movable>;
}

export function Main() {
    const [conceptType] = useProperty('concept::name');
    return conceptType === 'Image' ? &lt;CustomImage /> : null;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Image Shape" class="dynamic-shape-component">import React from 'react';
const { useEffect } = React;
import { useEditor, HTMLContainer, stopEventPropagation } from 'tldraw';
import { useProperty } from '#VarvReact';

import { MovableShapeUtil, MovableVarvScope } from '#Spatialstrates .movable-shape';
import { CANVAS_SCALE } from '#Spatialstrates .projection-helpers';



const MAX_SIZE = 0.42;

function ImageShape({ shape, isEditing }) {
    const [url, setUrl] = useProperty('url');
    const editor = useEditor();

    useEffect(() => {
        if (!url) return;

        const img = new Image();
        img.src = url;
        img.onload = () => {
            const aspectRatio = img.width / img.height || 1;
            let newWidth, newHeight;
            if (aspectRatio > 1) {
                newWidth = MAX_SIZE;
                newHeight = MAX_SIZE / aspectRatio;
            } else {
                newWidth = MAX_SIZE * aspectRatio;
                newHeight = MAX_SIZE
            }

            editor.updateShape({
                id: shape.id,
                props: {
                    w: newWidth * CANVAS_SCALE,
                    h: newHeight * CANVAS_SCALE
                }
            });
        };
    }, [url]);

    return &lt;HTMLContainer style={{
        transform: 'translate(-50%, -50%)',
        width: shape.props.w + 'px',
        height: shape.props.h + 'px',
        background: '#222',
        borderRadius: '8px',
        boxShadow: 'rgba(100, 100, 111, 0.4) 0px 0px 4px 0px',
        pointerEvents: isEditing ? 'all' : 'none'
    }}>
        {url ? &lt;img src={url} style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover',
            borderRadius: '8px',
        }} /> : 'No image'}
        {isEditing && &lt;input type="text" value={url} onChange={e => setUrl(e.target.value)} onPointerDown={stopEventPropagation} onPointerMove={stopEventPropagation} />}
    &lt;/HTMLContainer>;
}

class ImageShapeUtil extends MovableShapeUtil {
    static type = 'Image';

    getDefaultProps() {
        return Object.assign(super.getDefaultProps(), {
            w: CANVAS_SCALE * MAX_SIZE,
            h: CANVAS_SCALE * MAX_SIZE
        });
    }

    canEdit = () => true;

    component(shape) {
        const isEditing = this.editor.getEditingShapeId() === shape.id;

        return &lt;MovableVarvScope shape={shape}>
            &lt;ImageShape shape={shape} isEditing={isEditing} />
        &lt;/MovableVarvScope>;
    }
}

export const Main = ImageShapeUtil;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Image Uploader and Menu" id class auto>import React from 'react';

import { createMovable } from '#Spatialstrates .movable-helpers';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuButton, MenuSpacer } from '#Menu .default';



if (!window.moduleImageUploader) {
    window.moduleImageUploader = {
        active: true
    };

    addSubMenu('movables', 100, false);
    addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
    addItemToSubMenu('movables', 'add-image-note', &lt;MenuButton onClick={() => createMovable('Image')}>New Image&lt;/MenuButton>, 210);
    addItemToSubMenu('movables', 'spacer-items', &lt;MenuSpacer />, 400);

    // Setup menu item
    addSubMenu('file-upload', 500, false);
    addItemToSubMenu('file-upload', 'title', &lt;MenuTitle title="Upload Files" />, 0);
    addItemToSubMenu('file-upload', 'upload-image', &lt;div className="upload-drop-zone" id="image-upload-drop-zone">Upload Image&lt;/div>, 1000);

    // Setup drop zone for image uploads
    const handleUploadImage = (file) => {
        const formData = new FormData();
        formData.append('file', file, file.name);

        const request = new XMLHttpRequest();
        request.open('POST', window.location.pathname);
        request.send(formData);

        return new Promise((resolve, reject) => {
            request.addEventListener('load', async (e) => {
                const asset = JSON.parse(request.responseText);
                await createMovable('Image', {
                    url: asset.fileName
                });
                resolve(asset);
            });
            request.addEventListener('error', (e) => {
                reject(new Error('Failed to upload image'));
            });
        });
    };

    const handleUploadFile = (file) => {
        if (file.type === 'image/jpeg' || file.type === 'image/png') {
            handleUploadImage(file);
        } else {
            alert('File type not supported.');
        }
    };

    const activateDropZone = (element, type) => {
        if (element.__uploadDropZoneActivated) return;

        element.addEventListener('dragover', (e) => {
            e.preventDefault();
            element.classList.add('upload-drop-zone--over');
        });

        element.addEventListener('dragleave', () => {
            element.classList.remove('upload-drop-zone--over');
        });

        element.addEventListener('drop', (e) => {
            e.preventDefault();
            element.classList.remove('upload-drop-zone--over');
            const files = e.dataTransfer.files;
            for (let i = 0; i &lt; files.length; i++) {
                const file = files[i];
                handleUploadFile(file, type);
            }
        });

        element.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = 'multiple';
            input.accept = type === 'image' ? 'image/jpeg, image/png' : '';
            input.onchange = (e) => {
                for (let i = 0; i &lt; e.target.files.length; i++) {
                    handleUploadFile(e.target.files[i], type);
                }
            };
            input.click();
        });

        element.__uploadDropZoneActivated = true;
    };

    cQuery(document.body).liveQuery('.upload-drop-zone', {
        'added': (element) => {
            if (element.id === 'image-upload-drop-zone') {
                activateDropZone(element, 'image');
            }
        }
    });
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Trashcan" name="Trashcan"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A trashcan component that can be used to delete movables.",
    "dependencies": [
        "#Icon",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [
        "trash.glb"
    ],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Trashcan Concepts" auto>{
    "concepts": {
        "Trashcan": {
            "schema": {
                "placeholder": "string"
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Trashcan Component" class="default">import React from 'react';
const { useEffect, useCallback } = React;
import { Vector3 } from 'three';
import { useGLTF } from '@react-three/drei';
import { useProperty } from '#VarvReact';

import { useGlobalEvents } from '#Spatialstrates .global-events';
import { Movable } from '#Spatialstrates .movable';
import { deleteMovable } from '#Spatialstrates .movable-helpers';
import { Icon, SELECTED_COLOR_PRIMARY, SELECTED_COLOR_SECONDARY, HOVERED_SELECTED_COLOR_PRIMARY, HOVERED_SELECTED_COLOR_SECONDARY } from '#Icon .default';



const MAX_DISTANCE = 0.2;

const themes = {
    'trash': { primary: 'hsl(0, 0%, 20%)', secondary: 'hsl(0, 0%, 60%)' },
    'trash:hovered': { primary: 'hsl(0, 0%, 50%)', secondary: 'hsl(0, 0%, 70%)' },
    'trash:selected': { primary: SELECTED_COLOR_PRIMARY, secondary: SELECTED_COLOR_SECONDARY },
    'trash:selected:hovered': { primary: HOVERED_SELECTED_COLOR_PRIMARY, secondary: HOVERED_SELECTED_COLOR_SECONDARY },
};
useGLTF.preload('trash.glb');

function HandleIcon({ model, theme = '', themesOverride = '' }) {
    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');
    return &lt;Icon theme={theme + (selected ? ':selected' : '') + (hovered ? ':hovered' : '')} model={model} themesOverride={themesOverride} />
}

function Trashcan() {
    const trashcanIcon = useGLTF('trash.glb');
    const handle = &lt;HandleIcon theme="trash" model={trashcanIcon} themesOverride={themes} />
    const [position] = useProperty('position');
    const [uuid] = useProperty('concept::uuid');

    const { subscribeEvent } = useGlobalEvents();

    const onDragEnd = useCallback(async (data) => {
        if (data.target === uuid) return;

        const movablePositionArray = await VarvEngine.getConceptFromUUID(data.target).getPropertyValue(data.target, 'position');

        const trashcanPosition = new Vector3(...position);
        const movablePosition = new Vector3(...movablePositionArray);

        if (trashcanPosition.distanceTo(movablePosition) &lt; MAX_DISTANCE) {
            await deleteMovable(data.target);
        }
    }, [position]);

    useEffect(() => {
        const unsubscribe = subscribeEvent('drag-end', onDragEnd);
        return () => unsubscribe();
    }, [subscribeEvent, position]);

    return &lt;Movable handle={handle} />;
}

export function Main() {
    const [conceptType] = useProperty('concept::name');
    return conceptType === 'Trashcan' ? &lt;Trashcan /> : null;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Trashcan Shape" class="dynamic-shape-component">import React from 'react';
const { useEffect, useCallback } = React;
import { Vector2 } from 'three';
import { HTMLContainer } from 'tldraw';
import { useProperty } from '#VarvReact';

import { MovableShapeUtil, MovableVarvScope } from '#Spatialstrates .movable-shape';
import { deleteMovable } from '#Spatialstrates .movable-helpers';
import { useGlobalEvents } from '#Spatialstrates .global-events';
import { projectToCanvas, CANVAS_SCALE } from '#Spatialstrates .projection-helpers';



const MAX_DISTANCE = 0.2;

function TrashcanShape({ shape }) {
    const [position] = useProperty('position');
    const [uuid] = useProperty('concept::uuid');
    const [space] = useProperty('space');

    const { subscribeEvent } = useGlobalEvents();

    const onDragEnd = useCallback(async (data) => {
        if (data.target === uuid) return;
        if (!space) return;

        const movablePositionArray = await VarvEngine.getConceptFromUUID(data.target).getPropertyValue(data.target, 'position');

        const projectionPlane = await VarvEngine.getConceptFromType('Space').getPropertyValue(space, 'projectionPlane');
        const position2DArray = await projectToCanvas(position, projectionPlane);
        const movablePosition2DArray = await projectToCanvas(movablePositionArray, projectionPlane);

        const trashcanPosition = new Vector2(...position2DArray);
        const movablePosition = new Vector2(...movablePosition2DArray);

        if (trashcanPosition.distanceTo(movablePosition) &lt; MAX_DISTANCE) {
            await deleteMovable(data.target);
        }
    }, [position, space]);

    useEffect(() => {
        const unsubscribe = subscribeEvent('drag-end', onDragEnd);
        return () => unsubscribe();
    }, [subscribeEvent, position]);


    return &lt;HTMLContainer style={{
        transform: 'translate(-50%, -50%)',
        width: shape.props.w + 'px',
        height: shape.props.h + 'px',
        backgroundColor: '#444',
        borderRadius: '8px',
        boxShadow: `rgba(100, 100, 111, 0.4) 0px 0px 4px 0px`,
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
    }}>
        &lt;span style={{
            fontFamily: 'Material Icons',
            color: '#ddd',
            fontSize: '48px'
        }}>delete&lt;/span>
    &lt;/HTMLContainer>;
}

class TrashcanShapeUtil extends MovableShapeUtil {
    static type = 'Trashcan';

    getDefaultProps() {
        return Object.assign(super.getDefaultProps(), {
            w: CANVAS_SCALE * 0.15,
            h: CANVAS_SCALE * 0.185
        });
    }

    component(shape) {
        return &lt;MovableVarvScope shape={shape}>
            &lt;TrashcanShape shape={shape} />
        &lt;/MovableVarvScope>;
    }
}

export const Main = TrashcanShapeUtil;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Trashcan Menu" auto>import React from 'react';

import { createMovable } from '#Spatialstrates .movable-helpers';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { addControllerSubMenu, addItemToControllerSubMenu, ControllerMenuTitle, ControllerMenuSpacer, ControllerMenuButton } from '#ControllerMenu .default';



addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'add-trashcan', &lt;MenuButton onClick={() => createMovable('Trashcan')}>New Trashcan&lt;/MenuButton>, 100);
addItemToSubMenu('movables', 'spacer-items', &lt;MenuSpacer />, 400);

addControllerSubMenu('movables', 100, false);
addItemToControllerSubMenu('movables', 'title', &lt;ControllerMenuTitle title="Menu" />, 0);
addItemToControllerSubMenu('movables', 'add-trashcan', &lt;ControllerMenuButton onClick={() => createMovable('Trashcan')}>New Trashcan&lt;/ControllerMenuButton>, 100);
addItemToControllerSubMenu('movables', 'spacer-items', &lt;ControllerMenuSpacer />, 400);
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Model" name="Model"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple scalable 3D model component.",
    "dependencies": [
        "#Menu"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Model Concepts" auto>{
    "concepts": {
        "Model": {
            "schema": {
                "url": "string",
                "scale": { "number": {
                    "default": 0.001
                }},
                "upright": { "boolean": {
                    "default": true
                }}
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="Model Component" class="default">import React from 'react';
const { useMemo, useState } = React;
import { ErrorBoundary } from 'react-error-boundary';
import { Box3 } from 'three';
import { Gltf, Billboard } from '@react-three/drei';
import { Text as UIText, Root, Container as UIContainer } from '@react-three/uikit';
import { Defaults, Card, Button, Slider } from '@react-three/uikit-apfel';
import { useProperty } from '#VarvReact';

import { Movable } from '#Spatialstrates .movable';



const DEFAULT_MODEL_SCALE = 0.001;

function CustomModel() {
    const [selected] = useProperty('selected');
    const [beingDragged] = useProperty('beingDragged');
    const [url] = useProperty('url');
    const [scale, setScale] = useProperty('scale');
    const [upright, setUpright] = useProperty('upright');

    const [boundingBoxMinY, setBoundingBoxMinY] = useState(0);

    const fallback = useMemo(() => &lt;mesh castShadow receiveShadow>
        &lt;boxGeometry args={[0.1, 0.1, 0.1]} />
        &lt;meshStandardMaterial color={'#ccc'} />
    &lt;/mesh>, []);

    const handle = useMemo(() => {
        if (!!url && url != '') {
            return &lt;ErrorBoundary key={url} fallback={fallback}>
                &lt;group scale={scale || DEFAULT_MODEL_SCALE} position={[0, -boundingBoxMinY, 0]}>
                    &lt;Gltf
                        src={url}
                        castShadow
                        receiveShadow
                        onLoad={(gltf) => {
                            const box = new Box3().setFromObject(gltf.scene || gltf);
                            setBoundingBoxMinY(box.min.y * (scale || DEFAULT_MODEL_SCALE));
                        }}
                    />
                &lt;/group>
            &lt;/ErrorBoundary>;
        } else {
            return fallback;
        }
    }, [url, scale, boundingBoxMinY, fallback]);

    return &lt;Movable handle={handle} upright={upright}>
        {selected && !beingDragged ? &lt;Billboard position={[0, -0.1, 0]}>
            &lt;Defaults>
                &lt;Root anchorX="center" anchorY="top" flexDirection="column" pixelSize={0.0005} padding={15}>
                    &lt;Card borderRadius={24} padding={24} gap={16} flexDirection="column">
                        &lt;UIText fontSize={32}>{url || 'No Model Selected'}&lt;/UIText>
                        &lt;UIContainer flexDirection="row" gap={8} alignItems="center">
                            &lt;UIText>Scale&lt;/UIText>
                            &lt;Button platter onClick={() => setScale(DEFAULT_MODEL_SCALE)}>
                                &lt;UIText>Reset&lt;/UIText>
                            &lt;/Button>
                            &lt;Slider
                                min={1}
                                max={100}
                                step={1}
                                width={512}
                                value={(scale * 10000 || DEFAULT_MODEL_SCALE * 10000)}
                                onValueChange={(value) => setScale(value / 10000)} />
                        &lt;/UIContainer>
                        &lt;UIContainer flexDirection="row" gap={8} alignItems="center">
                            &lt;UIText>Upright&lt;/UIText>
                            &lt;Button platter onClick={() => setUpright(!upright)}>
                                &lt;UIText>{upright ? 'Yes' : 'No'}&lt;/UIText>
                            &lt;/Button>
                        &lt;/UIContainer>
                    &lt;/Card>
                &lt;/Root>
            &lt;/Defaults>
        &lt;/Billboard> : null}
    &lt;/Movable>;
}

export function Main() {
    const [conceptType] = useProperty('concept::name');
    return conceptType === 'Model' ? &lt;CustomModel /> : null;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Model Shape" class="dynamic-shape-component">import React from 'react';
import { HTMLContainer } from 'tldraw';

import { MovableShapeUtil, MovableVarvScope } from '#Spatialstrates .movable-shape';



function ModelShape({ shape, isEditing }) {
    return &lt;HTMLContainer style={{
        transform: 'translate(-50%, -50%)',
        width: shape.props.w + 'px',
        height: shape.props.h + 'px',
        backgroundColor: 'white',
        borderRadius: '8px',
        border: '1px solid green',
        padding: '8px'
    }}>Implement {shape.props.conceptType}&lt;/HTMLContainer>;
}

class ModelShapeUtil extends MovableShapeUtil {
    static type = 'Model';

    canEdit = () => true;

    component(shape) {
        const isEditing = this.editor.getEditingShapeId() === shape.id;

        return &lt;MovableVarvScope shape={shape}>
            &lt;ModelShape shape={shape} isEditing={isEditing} />
        &lt;/MovableVarvScope>;
    }
}

export const Main = ModelShapeUtil;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Model Uploader" id class auto>import React from 'react';

import { createMovable } from '#Spatialstrates .movable-helpers';
import { addSubMenu, addItemToSubMenu, MenuTitle } from '#Menu .default';



if (!window.moduleModelUploader) {
    window.moduleModelUploader = {
        active: true
    };

    // Setup menu item
    addSubMenu('file-upload', 500, false);
    addItemToSubMenu('file-upload', 'title', &lt;MenuTitle title="Upload Files" />, 0);
    addItemToSubMenu('file-upload', 'upload-model', &lt;div className="upload-drop-zone" id="model-upload-drop-zone">Upload 3D Model&lt;/div>, 1200);

    // Setup drop zone for model uploads
    const handleUploadModel = (file) => {
        const formData = new FormData();
        formData.append('file', file, file.name);

        const request = new XMLHttpRequest();
        request.open('POST', window.location.pathname);
        request.send(formData);

        return new Promise((resolve, reject) => {
            request.addEventListener('load', async () => {
                const asset = JSON.parse(request.responseText);
                await createMovable('Model', {
                    url: asset.fileName
                })
                resolve(asset);
            });
            request.addEventListener('error', (e) => {
                reject(new Error('Failed to upload model'));
            });
        });
    };

    const handleUploadFile = (file) => {
        // HACK: Cannot check if the file is valid yet
        // if (file.type === 'model/gltf-binary') {
            handleUploadModel(file);
        // } else {
        //     alert('File type not supported.');
        // }
    };

    const activateDropZone = (element, type) => {
        if (element.__uploadDropZoneActivated) return;

        element.addEventListener('dragover', (e) => {
            e.preventDefault();
            element.classList.add('upload-drop-zone--over');
        });

        element.addEventListener('dragleave', () => {
            element.classList.remove('upload-drop-zone--over');
        });

        element.addEventListener('drop', (e) => {
            e.preventDefault();
            element.classList.remove('upload-drop-zone--over');
            const files = e.dataTransfer.files;
            for (let i = 0; i &lt; files.length; i++) {
                const file = files[i];
                handleUploadFile(file);
            }
        });

        element.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = 'multiple';
            input.accept = '.glb';
            input.onchange = (e) => {
                for (let i = 0; i &lt; e.target.files.length; i++) {
                    handleUploadFile(e.target.files[i], type);
                }
            };
            input.click();
        });

        element.__uploadDropZoneActivated = true;
    };

    cQuery(document.body).liveQuery('.upload-drop-zone', {
        'added': (element) => {
            if (element.id === 'model-upload-drop-zone') {
                activateDropZone(element, 'model');
            }
        }
    });
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Flashlight" name="Flashlight"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A flashlight that illuminates the scene elements.",
    "dependencies": [
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Flashlight Concepts" auto>{
    "concepts": {
        "Flashlight": {
            "schema": {
                "color": { "string": {
                    "default": "white"
                }},
                "intensity": { "number": {
                    "default": 5
                }},
                "angle": { "number": {
                    "default": 0.39269908169872414
                }}
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="Flashlight Component" class="default">import React from 'react';
const { useRef, useMemo } = React;
import { MeshStandardMaterial } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useFrame } from '@react-three/fiber';
import { Cone, Billboard } from '@react-three/drei';
import { Text as UIText, Root, Container as UIContainer } from '@react-three/uikit';
import { Defaults, Card, List, ListItem } from '@react-three/uikit-apfel';
import { useProperty } from '#VarvReact';

import { Movable, SELECTED_COLOR_PRIMARY, HOVERED_SELECTED_COLOR_PRIMARY } from '#Spatialstrates .movable';



// Reuseable geometry for the image frame
const frameGeometry = new RoundedBoxGeometry(0.1, 0.1, 0.4, 2);
const frameMaterial = new MeshStandardMaterial({ color: '#222', metalness: 0.2, roughness: 0.5 });
const frameMaterialHovered = new MeshStandardMaterial({ color: '#444', metalness: 0.2, roughness: 0.5 });
const frameMaterialSelected = new MeshStandardMaterial({ color: SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });
const frameMaterialHoveredSelected = new MeshStandardMaterial({ color: HOVERED_SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });

const DEFAULT_COLOR = 'white';
const DEFAULT_INTENSITY = 5;
const DEFAULT_ANGLE = Math.PI / 8;

function Flashlight() {
    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');
    const [beingDragged] = useProperty('beingDragged');
    const [color, setColor] = useProperty('color');
    const [intensity, setIntensity] = useProperty('intensity');
    const [angle, setAngle] = useProperty('angle');

    const groupRef = useRef();
    const mainLightRef = useRef();
    const wideLightRef = useRef();
    const focusLightRef = useRef();

    const handle = useMemo(() => &lt;mesh
        scale={0.5}
        geometry={frameGeometry}
        material={selected ? (hovered ? frameMaterialHoveredSelected : frameMaterialSelected) : (hovered ? frameMaterialHovered : frameMaterial)}
        position={[0, 0, 0.1]}
        autoUpdateMatrix={false}>
    &lt;/mesh>, [selected, hovered]);

    useFrame(() => {
        if (!groupRef.current || !mainLightRef.current) return;
        const lights = [mainLightRef.current, wideLightRef.current, focusLightRef.current];
        lights.forEach(light => {
            if (!light) return;
            groupRef.current.add(light);
            groupRef.current.add(light.target);
            light.target.position.z = -1;
        });
    });

    const viewCone = useMemo(() => intensity ? &lt;Cone args={[0.15 * Math.tan(angle || DEFAULT_ANGLE), 0.15, 32]} position={[0, 0, 0]} rotation={[Math.PI / 2, 0, 0]}>
        &lt;meshStandardMaterial color={color || DEFAULT_COLOR} transparent={true} opacity={typeof intensity === 'number' ? intensity / 15 : DEFAULT_INTENSITY / 15} />
    &lt;/Cone> : null, [color, angle, intensity]);

    const currentIntensity = typeof intensity === 'number' ? intensity : DEFAULT_INTENSITY;
    const currentAngle = angle || DEFAULT_ANGLE;
    const currentColor = color || DEFAULT_COLOR;

    return &lt;>
        &lt;Movable handle={handle} upright={false}>
            {viewCone}
            &lt;group ref={groupRef} />
            {selected & !beingDragged ? &lt;Billboard position={[0, 0, 0.1]}>
                &lt;group position={[0, 0.1, 0]}>
                    &lt;Defaults>
                        &lt;Root anchorX="center" anchorY="bottom" flexDirection="column" pixelSize={0.0005} padding={15}>
                            &lt;Card borderRadius={24} padding={24} gap={16} flexDirection="column">
                                &lt;UIContainer flexDirection="row" gap={8} alignItems="center">
                                    &lt;UIText>Color&lt;/UIText>
                                    &lt;List type="plain" flexDirection="row" gap={8}>
                                        &lt;ListItem selected={color === 'white'} onClick={() => setColor('white')}>
                                            &lt;UIText>White&lt;/UIText>
                                        &lt;/ListItem>
                                        &lt;ListItem selected={color === 'red'} onClick={() => setColor('red')}>
                                            &lt;UIText>Red&lt;/UIText>
                                        &lt;/ListItem>
                                        &lt;ListItem selected={color === 'green'} onClick={() => setColor('green')}>
                                            &lt;UIText>Green&lt;/UIText>
                                        &lt;/ListItem>
                                        &lt;ListItem selected={color === 'blue'} onClick={() => setColor('blue')}>
                                            &lt;UIText>Blue&lt;/UIText>
                                        &lt;/ListItem>
                                        &lt;ListItem selected={color === 'yellow'} onClick={() => setColor('yellow')}>
                                            &lt;UIText>Yellow&lt;/UIText>
                                        &lt;/ListItem>
                                        &lt;ListItem selected={color === 'purple'} onClick={() => setColor('purple')}>
                                            &lt;UIText>Purple&lt;/UIText>
                                        &lt;/ListItem>
                                        &lt;ListItem selected={color === 'orange'} onClick={() => setColor('orange')}>
                                            &lt;UIText>Orange&lt;/UIText>
                                        &lt;/ListItem>
                                        &lt;ListItem selected={color === 'pink'} onClick={() => setColor('pink')}>
                                            &lt;UIText>Pink&lt;/UIText>
                                        &lt;/ListItem>
                                    &lt;/List>
                                &lt;/UIContainer>
                                &lt;UIContainer flexDirection="row" gap={8} alignItems="center">
                                    &lt;UIText>Intensity&lt;/UIText>
                                    &lt;List type="plain" flexDirection="row" gap={8}>
                                        &lt;ListItem selected={intensity === 0} onClick={() => setIntensity(0)}>
                                            &lt;UIText>Off&lt;/UIText>
                                        &lt;/ListItem>
                                        &lt;ListItem selected={intensity === 1} onClick={() => setIntensity(1)}>
                                            &lt;UIText>Weak&lt;/UIText>
                                        &lt;/ListItem>
                                        &lt;ListItem selected={intensity === DEFAULT_INTENSITY} onClick={() => setIntensity(DEFAULT_INTENSITY)}>
                                            &lt;UIText>Normal&lt;/UIText>
                                        &lt;/ListItem>
                                        &lt;ListItem selected={intensity === 10} onClick={() => setIntensity(10)}>
                                            &lt;UIText>Strong&lt;/UIText>
                                        &lt;/ListItem>
                                    &lt;/List>
                                &lt;/UIContainer>
                                &lt;UIContainer flexDirection="row" gap={8} alignItems="center">
                                    &lt;UIText>Angle&lt;/UIText>
                                    &lt;List type="plain" flexDirection="row" gap={8}>
                                        &lt;ListItem selected={angle === Math.PI / 16} onClick={() => setAngle(Math.PI / 16)}>
                                            &lt;UIText>Narrow&lt;/UIText>
                                        &lt;/ListItem>
                                        &lt;ListItem selected={angle === DEFAULT_ANGLE} onClick={() => setAngle(DEFAULT_ANGLE)}>
                                            &lt;UIText>Normal&lt;/UIText>
                                        &lt;/ListItem>
                                        &lt;ListItem selected={angle === Math.PI / 4} onClick={() => setAngle(Math.PI / 4)}>
                                            &lt;UIText>Wide&lt;/UIText>
                                        &lt;/ListItem>
                                    &lt;/List>
                                &lt;/UIContainer>
                            &lt;/Card>
                        &lt;/Root>
                    &lt;/Defaults>
                &lt;/group>
            &lt;/Billboard> : null}
        &lt;/Movable>
        &lt;spotLight
            ref={mainLightRef}
            position={[0, 0, 0]}
            color={currentColor}
            angle={currentAngle}
            intensity={currentIntensity * 0.6}
            distance={2}
            penumbra={0.2}
            // Only one light can cast shadows at a time or GPU overloads
            castShadow
            shadow-mapSize={256}
        />
        &lt;spotLight
            ref={wideLightRef}
            position={[0, 0, 0]}
            color={currentColor}
            angle={currentAngle * 1.5}
            intensity={currentIntensity * 0.3}
            distance={1.5}
            penumbra={0.5}
        />
        &lt;spotLight
            ref={focusLightRef}
            position={[0, 0, 0]}
            color={currentColor}
            angle={currentAngle * 0.5}
            intensity={currentIntensity * 0.4}
            distance={2.5}
            penumbra={0.2}
        />
    &lt;/>;
}

export function Main() {
    const [conceptType] = useProperty('concept::name');
    return conceptType === 'Flashlight' ? &lt;Flashlight /> : null;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Flashlight Shape" class="dynamic-shape-component">import React from 'react';
import { HTMLContainer } from 'tldraw';

import { MovableShapeUtil, MovableVarvScope } from '#Spatialstrates .movable-shape';



function FlashlightShape({ shape, isEditing }) {
    return &lt;HTMLContainer style={{
        transform: 'translate(-50%, -50%)',
        width: shape.props.w + 'px',
        height: shape.props.h + 'px',
        backgroundColor: 'white',
        borderRadius: '8px',
        border: '1px solid green',
        padding: '8px'
    }}>Implement {shape.props.conceptType}&lt;/HTMLContainer>;
}

class FlashlightShapeUtil extends MovableShapeUtil {
    static type = 'Flashlight';

    canEdit = () => true;

    component(shape) {
        const isEditing = this.editor.getEditingShapeId() === shape.id;

        return &lt;MovableVarvScope shape={shape}>
            &lt;FlashlightShape shape={shape} isEditing={isEditing} />
        &lt;/MovableVarvScope>;
    }
}

export const Main = FlashlightShapeUtil;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Flashlight Menu" auto>import React from 'react';

import { createMovable } from '#Spatialstrates .movable-helpers';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { addControllerSubMenu, addItemToControllerSubMenu, ControllerMenuTitle, ControllerMenuSpacer, ControllerMenuButton } from '#ControllerMenu .default';



addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'add-flashlight-note', &lt;MenuButton onClick={() => createMovable('Flashlight')}>New Flashlight&lt;/MenuButton>, 350);
addItemToSubMenu('movables', 'spacer-items', &lt;MenuSpacer />, 400);

addControllerSubMenu('movables', 100, false);
addItemToControllerSubMenu('movables', 'title', &lt;ControllerMenuTitle title="Menu" />, 0);
addItemToControllerSubMenu('movables', 'add-flashlight-note', &lt;ControllerMenuButton onClick={() => createMovable('Flashlight')}>New Flashlight&lt;/ControllerMenuButton>, 350);
addItemToControllerSubMenu('movables', 'spacer-items', &lt;ControllerMenuSpacer />, 400);
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Molecule" name="Molecule"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A component to display PDB molecules.",
    "dependencies": [
        "#Menu"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Molecule Concepts" auto>{
    "concepts": {
        "Molecule": {
            "schema": {
                "url": "string",
                "scale": { "number": {
                    "default": 0.001
                }},
                "note": "string"
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="Molecule Component" class="default">import React from 'react';
const { useMemo } = React;
import { ErrorBoundary } from 'react-error-boundary';
import * as THREE from 'three';
import { PDBLoader } from 'three/addons/loaders/PDBLoader.js';
import { useLoader } from '@react-three/fiber';
import { Billboard } from '@react-three/drei';
import { Text as UIText, Root } from '@react-three/uikit';
import { Defaults, Card } from '@react-three/uikit-apfel';
import { useProperty } from '#VarvReact';

import { Movable } from '#Spatialstrates .movable';
import { Text } from '#Spatialstrates .text';



function Molecule() {
    const [selected] = useProperty('selected');
    const [url] = useProperty('url');
    const [note] = useProperty('note');
    const [scale] = useProperty('scale');
    const pdb = useLoader(PDBLoader, url);

    // Create meshes from PDB data and extract atom data for labels
    const { moleculeObject, atomLabels } = useMemo(() => {
        if (!pdb) return { moleculeObject: null, atomLabels: [] };

        const root = new THREE.Group();
        const offset = new THREE.Vector3();
        const atomLabels = [];

        const geometryAtoms = pdb.geometryAtoms;
        const geometryBonds = pdb.geometryBonds;
        const json = pdb.json;

        const sphereGeometry = new THREE.IcosahedronGeometry(1, 3);
        const boxGeometry = new THREE.BoxGeometry(1, 1, 1);

        // Center the molecule
        geometryAtoms.computeBoundingBox();
        geometryAtoms.boundingBox.getCenter(offset).negate();

        geometryAtoms.translate(offset.x, offset.y, offset.z);
        geometryBonds.translate(offset.x, offset.y, offset.z);

        // Create atom meshes
        let positions = geometryAtoms.getAttribute('position');
        const colors = geometryAtoms.getAttribute('color');

        const position = new THREE.Vector3();
        const color = new THREE.Color();

        // Add atoms
        for (let i = 0; i &lt; positions.count; i++) {
            position.x = positions.getX(i);
            position.y = positions.getY(i);
            position.z = positions.getZ(i);

            color.r = colors.getX(i);
            color.g = colors.getY(i);
            color.b = colors.getZ(i);

            // Use MeshStandardMaterial instead which responds better to lighting
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.1
            });

            const object = new THREE.Mesh(sphereGeometry, material);

            object.position.copy(position);
            object.position.multiplyScalar(75);
            object.scale.multiplyScalar(25);
            root.add(object);

            // Store atom label data if JSON data is available
            if (json && json.atoms && json.atoms[i]) {
                const atom = json.atoms[i];
                atomLabels.push({
                    position: [
                        object.position.x + 30, // Offset slightly from the atom
                        object.position.y + 30,
                        object.position.z
                    ],
                    text: atom[4], // Element symbol
                    color: `rgb(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)})`,
                });
            }
        }

        // Add bonds
        positions = geometryBonds.getAttribute('position');

        const start = new THREE.Vector3();
        const end = new THREE.Vector3();

        for (let i = 0; i &lt; positions.count; i += 2) {
            start.x = positions.getX(i);
            start.y = positions.getY(i);
            start.z = positions.getZ(i);

            end.x = positions.getX(i + 1);
            end.y = positions.getY(i + 1);
            end.z = positions.getZ(i + 1);

            start.multiplyScalar(75);
            end.multiplyScalar(75);

            // Use MeshStandardMaterial for bonds too
            const object = new THREE.Mesh(boxGeometry, new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.5,
                metalness: 0.1
            }));

            object.position.copy(start);
            object.position.lerp(end, 0.5);
            object.scale.set(5, 5, start.distanceTo(end));
            object.lookAt(end);
            root.add(object);
        }

        return { moleculeObject: root, atomLabels };
    }, [pdb]);

    const handle = useMemo(() => (&lt;>
        &lt;group scale={[scale, scale, scale]}>
            {moleculeObject && &lt;primitive object={moleculeObject} />}

            {atomLabels.map((label, index) => (
                &lt;Text
                    key={index}
                    position={label.position}
                    fontSize={10}
                    color={label.color}
                    anchorX="center"
                    anchorY="middle">
                    {label.text}
                &lt;/Text>
            ))}
        &lt;/group>
    &lt;/>), [moleculeObject, atomLabels, scale]);

    const title = useMemo(() => &lt;Text position={[0, 0.075, 0]}
        fontSize={0.05}
        textAlign="center"
        anchorX="center"
        anchorY="top"
        color="black"
        outlineWidth="5%"
        outlineColor="white">{url}&lt;/Text>, [url]);

    return &lt;Movable handle={handle} upright={false}>
        &lt;Billboard position={[0, -0.375, 0]}>
            {title}
            {selected && note ? &lt;Defaults>
                &lt;Root anchorX="center" anchorY="top" flexDirection="column" pixelSize={0.0005} padding={15}>
                    &lt;Card borderRadius={24} padding={24} gap={16} flexDirection="column">
                        &lt;UIText fontSize={24}>{note}&lt;/UIText>
                    &lt;/Card>
                &lt;/Root>
            &lt;/Defaults> : null}
        &lt;/Billboard>
    &lt;/Movable>;
}

export function Main() {
    const [conceptType] = useProperty('concept::name');
    return conceptType === 'Molecule' ? &lt;ErrorBoundary fallback={null}>
        &lt;Molecule />
    &lt;/ErrorBoundary> : null;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Molecule Shape" class="dynamic-shape-component">import React from 'react';
const { useState, useEffect } = React;
import { ErrorBoundary } from 'react-error-boundary';
import { PDBLoader } from 'three/addons/loaders/PDBLoader.js';
import { useLoader } from '@react-three/fiber';
import { HTMLContainer, stopEventPropagation } from 'tldraw';
import { useProperty } from '#VarvReact';

import { MovableShapeUtil, MovableVarvScope } from '#Spatialstrates .movable-shape';
import { CANVAS_SCALE } from '#Spatialstrates .projection-helpers';



function MoleculeShape({ shape, isEditing }) {
    const [url] = useProperty('url');
    const [note, setNote] = useProperty('note');
    const pdb = useLoader(PDBLoader, url);
    const [statistics, setStatistics] = useState(null);

    useEffect(() => {
        const atoms = pdb?.json?.atoms;
        if (!atoms) return;
        const atomCounts = {};
        atoms.forEach(atom => {
            const atomType = atom[4];
            if (!atomCounts[atomType]) {
                atomCounts[atomType] = 0;
            }
            atomCounts[atomType]++;
        });
        const atomCountEntries = Object.entries(atomCounts).sort((a, b) => a[0].localeCompare(b[0]));
        const atomCountTable = (
            &lt;table>
                &lt;thead>
                    &lt;tr>
                        &lt;th>Type&lt;/th>
                        &lt;th>Count&lt;/th>
                    &lt;/tr>
                &lt;/thead>
                &lt;tbody>
                    {atomCountEntries.map(([atomType, count]) => (
                        &lt;tr key={atomType}>
                            &lt;td>{atomType}&lt;/td>
                            &lt;td>{count}&lt;/td>
                        &lt;/tr>
                    ))}
                &lt;/tbody>
            &lt;/table>
        );
        setStatistics(atomCountTable);
    }, [pdb]);

    return &lt;HTMLContainer className="molecule-shape" style={{
        transform: 'translate(-50%, -50%)',
        width: shape.props.w + 'px',
        height: shape.props.h + 'px'
    }}>
        &lt;div className="molecule-shape-url">{url}&lt;/div>
        &lt;div className="molecule-shape-note">
            {isEditing ? &lt;textarea
                placeholder="Add a note..."
                rows={3}
                value={note}
                onChange={(e) => setNote(e.target.value)}
                onPointerDown={stopEventPropagation} /> : note || 'Add a note...'}
        &lt;/div>
        &lt;div className="molecule-shape-statistics">
            {statistics}
        &lt;/div>
    &lt;/HTMLContainer>;
}

class MoleculeShapeUtil extends MovableShapeUtil {
    static type = 'Molecule';

    getDefaultProps() {
        return Object.assign(super.getDefaultProps(), {
            w: CANVAS_SCALE * 0.4,
            h: CANVAS_SCALE * 0.4
        });
    }

    canEdit = () => true;

    component(shape) {
        const isEditing = this.editor.getEditingShapeId() === shape.id;

        return &lt;MovableVarvScope shape={shape}>
            &lt;ErrorBoundary fallback={null}>
                &lt;MoleculeShape shape={shape} isEditing={isEditing} />
            &lt;/ErrorBoundary>
        &lt;/MovableVarvScope>;
    }
}

export const Main = MoleculeShapeUtil;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Molecule Uploader" id class auto>import React from 'react';

import { createMovable } from '#Spatialstrates .movable-helpers';
import { addSubMenu, addItemToSubMenu, MenuTitle } from '#Menu .default';



if (!window.moduleMoleculeUploader) {
    window.moduleMoleculeUploader = {
        active: true
    };

    // Setup menu item
    addSubMenu('file-upload', 500, false);
    addItemToSubMenu('file-upload', 'title', &lt;MenuTitle title="Upload Files" />, 0);
    addItemToSubMenu('file-upload', 'upload-molecule', &lt;div className="upload-drop-zone" id="molecule-upload-drop-zone">Upload PDB Molecule&lt;/div>, 1300);

    // Setup drop zone for model uploads
    const handleUploadMolecule = (file) => {
        const formData = new FormData();
        formData.append('file', file, file.name);

        const request = new XMLHttpRequest();
        request.open('POST', window.location.pathname);
        request.send(formData);

        return new Promise((resolve, reject) => {
            request.addEventListener('load', async () => {
                const asset = JSON.parse(request.responseText);
                await createMovable('Molecule', {
                    url: asset.fileName
                })
                resolve(asset);
            });
            request.addEventListener('error', (e) => {
                reject(new Error('Failed to upload molecule'));
            });
        });
    };

    const handleUploadFile = (file) => {
        // HACK: Cannot check if the file is valid yet
        // if (file.type === 'model/pdb') {
            handleUploadMolecule(file);
        // } else {
        //     alert('File type not supported.');
        // }
    };

    const activateDropZone = (element, type) => {
        if (element.__uploadDropZoneActivated) return;

        element.addEventListener('dragover', (e) => {
            e.preventDefault();
            element.classList.add('upload-drop-zone--over');
        });

        element.addEventListener('dragleave', () => {
            element.classList.remove('upload-drop-zone--over');
        });

        element.addEventListener('drop', (e) => {
            e.preventDefault();
            element.classList.remove('upload-drop-zone--over');
            const files = e.dataTransfer.files;
            for (let i = 0; i &lt; files.length; i++) {
                const file = files[i];
                handleUploadFile(file);
            }
        });

        element.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = 'multiple';
            input.accept = '.pdb';
            input.onchange = (e) => {
                for (let i = 0; i &lt; e.target.files.length; i++) {
                    handleUploadFile(e.target.files[i], type);
                }
            };
            input.click();
        });

        element.__uploadDropZoneActivated = true;
    };

    cQuery(document.body).liveQuery('.upload-drop-zone', {
        'added': (element) => {
            if (element.id === 'molecule-upload-drop-zone') {
                activateDropZone(element, 'model');
            }
        }
    });
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Molecule Styles" auto>.molecule-shape {
    background-color: #fff;
    border: 1px solid #eee;
    border-radius: 4px;
    padding: 4px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    gap: 8px;
    overflow: hidden;

    .molecule-shape-url {
        font-size: 16px;
        font-weight: bold;
        text-align: center;

        input {
            pointer-events: all;
        }
    }

    .molecule-shape-note {
        font-size: 14px;
        text-align: left;
        color: #666;
        padding: 4px 8px;
        background-color: #f9f9f9;
        border-radius: 4px;

        textarea {
            pointer-events: all;
            height: 50px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px;
            resize: none;
        }
    }

    .molecule-shape-statistics {
        width: 100%;
        background-color: #f9f9f9;
        border-radius: 4px;
        padding: 4px;

        table {
            width: 100%;
            border-collapse: collapse;
        }
        thead {
            th {
                padding: 4px;
                text-align: center;
                font-weight: bold;
            }
        }
        tbody {
            th, td {
                padding: 4px;
                text-align: center;
                border-top: 1px solid #ddd;
            }
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></code-folder><CODE-FOLDER name="Datavisualization"><CODE-FOLDER name="Modules"><WPM-PACKAGE id="VisModule" name="VisModule"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Adds general classes for datavisualization.",
    "dependencies": [
        "#Menu"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Vis-Helpers" id class="vis-helpers">export const SPEC_COMPONENT_TYPE = 'spec';
export const DATASET_COMPONENT_TYPE = 'dataset';
export const UNKNOWN_COMPONENT_TYPE = 'unknown';

export const COMPONENT_CONTAINER_SELECTOR = '#vis-component-container';
export const SPEC_CONTAINER_SELECTOR = '#vis-component-container .spec-container';
export const DATASET_CONTAINER_SELECTOR = '#vis-component-container .dataset-container';

export const GROUPS_CONTAINER_SELECTOR = '#vis-group-container';

export const generateComponentId = () => {
    return `vis-component-${crypto.randomUUID().replaceAll('-', '').slice(0, 20)}`;
};

export const getVegaLiteSchema = async () => {
    if (window.vegaLiteSchema) {
        return window.vegaLiteSchema;
    }

    const response = await fetch('https://vega.github.io/schema/vega-lite/v5.json');
    const vegaLiteSchema = await response.json();
    window.vegaLiteSchema = vegaLiteSchema;

    return vegaLiteSchema;
};

// Has to match the options set in getDefaultVisPiecesLibrary
export const getOptionsForPath = async (path) => {
    const schema = await getVegaLiteSchema();

    switch (path) {
        case 'data.fragment':
            return { type: 'dataset' };
        case 'mark':
        case 'mark.type':
            return {
                type: 'enum',
                // enum: schema.definitions.Mark.enum
                enum: ['bar', 'line', 'point', 'area', 'rect', 'square', 'circle']
            };
        case 'mark.opacity':
            return {
                type: 'number',
                min: 0,
                max: 1
            };
        case 'mark.filled':
            return { type: 'boolean' };
        case 'mark.color':
        case 'mark.fill':
        case 'mark.stroke':
            return { type: 'color' };

        case 'encoding.x.type':
        case 'encoding.y.type':
        case 'encoding.z.type':
        case 'encoding.color.type':
            return {
                type: 'enum',
                enum: schema.definitions.StandardType.enum
            };
        case 'encoding.x.field':
        case 'encoding.y.field':
        case 'encoding.z.field':
        case 'encoding.color.field':
            return { type: 'field' };
        case 'encoding.x.aggregate':
        case 'encoding.y.aggregate':
        case 'encoding.z.aggregate':
        case 'encoding.color.aggregate':
            return {
                type: 'enum',
                // enum: schema.definitions.AggregateOp.enum
                enum: ['count', 'mean', 'median', 'min', 'max', 'sum', 'average']
            };
        case 'encoding.x.sort':
        case 'encoding.y.sort':
        case 'encoding.z.sort':
        case 'encoding.color.sort':
            return {
                type: 'enum',
                // enum: schema.definitions.SortOrder.enum
                enum: ['ascending', 'descending', 'true', 'false']
            };
        case 'encoding.x.color':
        case 'encoding.y.color':
        case 'encoding.z.color':
        case 'encoding.color.color':
            return { type: 'color' };

        // TODO: Add transforms?

        default:
            return null;
    }
};

class VisPiece {
    constructor(path, content) {
        this.path = path;
        this.content = content;
    }
}

export const getDefaultVisPiecesLibrary = () => {
    const library = [];

    // Mark properties
    library.push(new VisPiece('mark.type', 'bar'));
    library.push(new VisPiece('mark.opacity', '0.7'));
    library.push(new VisPiece('mark.color', '#1f77b4'));
    library.push(new VisPiece('mark.filled', 'true'));
    library.push(new VisPiece('mark.fill', '#1f77b4'));
    library.push(new VisPiece('mark.stroke', '#000000'));

    // Encoding properties
    // const encodings = ['x', 'y', 'z', 'color', 'size'];
    const encodings = ['x'];
    for (const encoding of encodings) {
        library.push(new VisPiece(`encoding.${encoding}.type`, 'nominal'));
        library.push(new VisPiece(`encoding.${encoding}.field`, ''));
        library.push(new VisPiece(`encoding.${encoding}.aggregate`, ''));
        library.push(new VisPiece(`encoding.${encoding}.sort`, 'ascending'));
        library.push(new VisPiece(`encoding.${encoding}.color`, 'blue'));
    }

    // Transforms
    library.push(new VisPiece('transform', '[{"aggregate":""}]'));
    library.push(new VisPiece('transform', '[{"calculate":""}]'));
    library.push(new VisPiece('transform', '[{"filter":""}]'));

    return library;
};
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Vis-Component Manager" id class="vis-component-manager">import {
    SPEC_COMPONENT_TYPE,
    DATASET_COMPONENT_TYPE,
    UNKNOWN_COMPONENT_TYPE,
    COMPONENT_CONTAINER_SELECTOR,
    SPEC_CONTAINER_SELECTOR,
    DATASET_CONTAINER_SELECTOR,
    generateComponentId
} from '#VisModule .vis-helpers';

let visComponentContainer = document.querySelector(COMPONENT_CONTAINER_SELECTOR);
let specContainer = document.querySelector(SPEC_CONTAINER_SELECTOR);
let datasetContainer = document.querySelector(DATASET_CONTAINER_SELECTOR);

// Setup folders if not available
if (!visComponentContainer) {
    visComponentContainer = document.createElement('code-folder');
    visComponentContainer.id = 'vis-component-container';
    visComponentContainer.setAttribute('name', 'Vis-Components');
    document.body.appendChild(visComponentContainer);
    WPMv2.stripProtection(visComponentContainer);
}
if (!specContainer) {
    specContainer = document.createElement('code-folder');
    specContainer.classList.add('spec-container');
    specContainer.setAttribute('name', 'Specs');
    visComponentContainer.appendChild(specContainer);
    WPMv2.stripProtection(specContainer);
}
if (!datasetContainer) {
    datasetContainer = document.createElement('code-folder');
    datasetContainer.classList.add('dataset-container');
    datasetContainer.setAttribute('name', 'Datasets');
    visComponentContainer.appendChild(datasetContainer);
    WPMv2.stripProtection(datasetContainer);
}



export class VisComponent {
    constructor(fragmentElement) {
        if (!!fragmentElement.closest(SPEC_CONTAINER_SELECTOR)) {
            this.type = SPEC_COMPONENT_TYPE;
        } else if (!!fragmentElement.closest(DATASET_CONTAINER_SELECTOR)) {
            this.type = DATASET_COMPONENT_TYPE;
        } else {
            this.type = UNKNOWN_COMPONENT_TYPE;
        }
        this.fragmentElement = fragmentElement;
        this.fragment = Fragment.one(this.fragmentElement)
        this.name = this.fragmentElement.getAttribute('name') || this.fragmentElement.id;
        this.uuid = this.fragmentElement.getAttribute('transient-fragment-uuid');

        this.id = this.fragmentElement.id;
        if (!this.id) {
            this.id = generateComponentId();
            this.fragmentElement.id = this.id;
        }

        this.contentChangedListener = [];
        this.nameChangedListener = [];

        this.fragmentChangedCallback = () => {
            this._contentChanged();
        };
        this.fragment.registerOnFragmentChangedHandler(this.fragmentChangedCallback);

        this.observer = new MutationObserver((mutationsList, observer) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'name') {
                    this.name = this.fragmentElement.getAttribute('name');
                    this._nameChanged();
                }
            }
        });

        this.observer.observe(this.fragmentElement, { attributes: true });
    }
    disconnect() {
        this.fragment.unRegisterOnFragmentChangedHandler(this.fragmentChangedCallback);
        this.observer.disconnect();
    }
    remove() {
        this.fragmentElement.remove();
    }

    getContentRaw() {
        return this.fragment.raw;
    }
    getContentAsJSON() {
        if (this.type === DATASET_COMPONENT_TYPE || this.type === SPEC_COMPONENT_TYPE) {
            try {
                return JSON.parse(this.getContentRaw());
            } catch (e) {
                console.warn(`getContentAsJSON -> Failed to parse content as JSON: ${e.message}`);
                return this.type === DATASET_COMPONENT_TYPE ? [] : {};
            }
        } else {
            return null;
        }
    }

    _contentChanged() {
        this.contentChangedListener.forEach(listener => {
            listener(this);
        });
    }
    addContentChangedListener(listener) {
        this.contentChangedListener.push(listener);
    }
    removeContentChangedListener(listener) {
        const index = this.contentChangedListener.indexOf(listener);
        if (index > -1) {
            this.contentChangedListener.splice(index, 1);
        }
    }

    _nameChanged() {
        this.nameChangedListener.forEach(listener => {
            listener(this.name);
        });
    }
    addNameChangedListener(listener) {
        this.nameChangedListener.push(listener);
    }
    removeNameChangedListener(listener) {
        const index = this.nameChangedListener.indexOf(listener);
        if (index > -1) {
            this.nameChangedListener.splice(index, 1);
        }
    }
}

class VisComponentManager {
    constructor() {
        this.visComponents = new Map();
        this.addedListeners = [];
        this.removedListeners = [];
    }

    addVisComponent(fragmentElement) {
        const visComponent = new VisComponent(fragmentElement);
        this.visComponents.set(visComponent.uuid, visComponent);
        this._visComponentAdded(visComponent);
        return visComponent;
    }
    removeVisComponent(fragmentElement) {
        const visComponent = this.visComponents.get(fragmentElement.getAttribute('transient-fragment-uuid'));
        visComponent.disconnect();
        this.visComponents.delete(visComponent.uuid);
        this._visComponentRemoved(visComponent);
    }

    getVisComponent(uuid) {
        return this.visComponents.get(uuid);
    }
    getVisComponentById(id) {
        for (const visComponent of this.visComponents.values()) {
            if (visComponent.id === id) {
                return visComponent;
            }
        }
        return null;
    }
    getVisComponents() {
        return Array.from(this.visComponents.values());
    }
    getSpecComponents() {
        return this.getVisComponents().filter(fragment => fragment.type === SPEC_COMPONENT_TYPE);
    }
    getDatasetComponents() {
        return this.getVisComponents().filter(fragment => fragment.type === DATASET_COMPONENT_TYPE);
    }

    _visComponentAdded(visComponent) {
        this.addedListeners.forEach(listener => {
            listener(visComponent);
        });
    }
    addVisComponentAddedListener(listener) {
        this.addedListeners.push(listener);
    }
    removeVisComponentAddedListener(listener) {
        const index = this.addedListeners.indexOf(listener);
        if (index > -1) {
            this.addedListeners.splice(index, 1);
        }
    }

    _visComponentRemoved(visComponent) {
        this.removedListeners.forEach(listener => {
            listener(visComponent);
        });
    }
    addVisComponentRemovedListener(listener) {
        this.removedListeners.push(listener);
    }
    removeVisComponentRemovedListener(listener) {
        const index = this.removedListeners.indexOf(listener);
        if (index > -1) {
            this.removedListeners.splice(index, 1);
        }
    }
}


if (!window.moduleVisComponentManager) {
    window.moduleVisComponentManager = {
        visComponentManager: new VisComponentManager()
    }

    cQuery(visComponentContainer).liveQuery('code-fragment', {
        'added': (fragmentElement) => {
            window.moduleVisComponentManager.visComponentManager.addVisComponent(fragmentElement);
        },
        'removed': (fragmentElement) => {
            window.moduleVisComponentManager.visComponentManager.removeVisComponent(fragmentElement);
        }
    });
}
const visComponentManager = window.moduleVisComponentManager.visComponentManager;


const createFragmentElement = (content = '', name = 'New Component') => {
    const dataType = 'application/json';
    const fragment = Fragment.create(dataType);
    fragment.raw = content;
    fragment.html[0].setAttribute('name', name);
    fragment.html[0].id = generateComponentId();
    WPMv2.stripProtection(fragment.html[0]);

    return fragment.html[0];
};
export const createSpecVisComponent = (content, name) => {
    const fragmentElement = createFragmentElement(content, name);
    specContainer.appendChild(fragmentElement);
    const visComponent = visComponentManager.addVisComponent(fragmentElement);
    return visComponent;
};
export const createDatasetVisComponent = (content, name) => {
    const fragmentElement = createFragmentElement(content, name);
    datasetContainer.appendChild(fragmentElement);
    const visComponent = visComponentManager.addVisComponent(fragmentElement);
    return visComponent;
};



export const getVisComponent = visComponentManager.getVisComponent.bind(visComponentManager);
export const getVisComponentById = visComponentManager.getVisComponentById.bind(visComponentManager);

export const getVisComponents = visComponentManager.getVisComponents.bind(visComponentManager);
export const getSpecComponents = visComponentManager.getSpecComponents.bind(visComponentManager);
export const getDatasetComponents = visComponentManager.getDatasetComponents.bind(visComponentManager);

export const addVisComponentAddedListener = visComponentManager.addVisComponentAddedListener.bind(visComponentManager);
export const removeVisComponentAddedListener = visComponentManager.removeVisComponentAddedListener.bind(visComponentManager);
export const addVisComponentRemovedListener = visComponentManager.addVisComponentRemovedListener.bind(visComponentManager);
export const removeVisComponentRemovedListener = visComponentManager.removeVisComponentRemovedListener.bind(visComponentManager);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Vis-Composer" id class="vis-composer">import * as mergeModule from 'lodash.mergewith';
const deepMerge = mergeModule.default;

// https://lodash.com/docs/4.17.15#mergeWith
// Merge arrays instead of overwriting them
function deepMergeCustomizer(objValue, srcValue) {
    if (_.isArray(objValue)) {
        return objValue.concat(srcValue);
    }
}

import { SPEC_COMPONENT_TYPE, DATASET_COMPONENT_TYPE } from '#VisModule .vis-helpers';
import { getVisComponentById } from '#VisModule .vis-component-manager';



/* Varv Helpers */

export const createVarvVisPieces = async (pieces) => {
    const concept = VarvEngine.getConceptFromType('VisPiece');
    const instanceUUIDs = [];

    for (let piece of pieces) {
        const uuid = await concept.create(null, {
            path: piece.path,
            content: piece.content,
        });
        instanceUUIDs.push(uuid);
    }

    return instanceUUIDs;
};

export const integrateVisPiecesIntoGroup = async (groupUUID, pieces) => {
    const existingPieces = await recursivelyFindPieces(groupUUID);
    const pieceConcept = VarvEngine.getConceptFromType('VisPiece');
    const groupConcept = VarvEngine.getConceptFromType('VisGroup');

    console.log('integrateVisPiecesIntoGroup', groupUUID, pieces, existingPieces)

    // Iterate backwards so that we do not set overwritten pieces
    for (let i = pieces.length - 1; i >= 0; i--) {
        const piece = pieces[i];
        const existingPiece = existingPieces.find(p => p.path === piece.path);

        if (existingPiece) {
            existingPiece.overwritten = true;
            await pieceConcept.getProperty('content').setValue(existingPiece.pieceUUID, piece.content);
            await pieceConcept.getProperty('disabled').setValue(existingPiece.pieceUUID, false);
        } else {
            const newPieceUUID = await pieceConcept.create(null, {
                path: piece.path,
                content: piece.content,
                group: groupUUID
            });
            const oldPieces = groupConcept.getProperty('pieces').getValue(groupUUID, true);
            oldPieces.push(newPieceUUID);
            await groupConcept.getProperty('pieces').setValue(groupUUID, oldPieces);
        }
    }

    // Disable not overwritten pieces
    for (let i = 0; i &lt; existingPieces.length; i++) {
        const existingPiece = existingPieces[i];
        if (!existingPiece.overwritten) {
            await pieceConcept.getProperty('disabled').setValue(existingPiece.pieceUUID, true);
        }
    }
};

const recursivelyFindPieces = async (groupUUID, proximityAuthoring = false) => {
    const concept = VarvEngine.getConceptFromUUID(groupUUID);
    const pieces = [];
    const piecesToIterate = [];

    const groupPieces = await concept.getProperty('pieces').getValue(groupUUID, true);
    piecesToIterate.push(...groupPieces);

    if (proximityAuthoring) {
        const proximityPieces = await concept.getProperty('proximityPieces').getValue(groupUUID, true);
        piecesToIterate.push(...proximityPieces);
    }

    for (let i = 0; i &lt; piecesToIterate.length; i++) {
        const pieceUUID = piecesToIterate[i];
        const conceptType = await VarvEngine.getConceptFromUUID(pieceUUID).name;

        if (conceptType === 'VisPiece') {
            const path = await VarvEngine.getConceptFromUUID(pieceUUID).getProperty('path').getValue(pieceUUID, true);
            const content = await VarvEngine.getConceptFromUUID(pieceUUID).getProperty('content').getValue(pieceUUID, true);
            const disabled = await VarvEngine.getConceptFromUUID(pieceUUID).getProperty('disabled').getValue(pieceUUID, true);
            pieces.push({ pieceUUID, path, content, disabled });
        } else if (conceptType === 'VisGroup') {
            const disabled = await VarvEngine.getConceptFromUUID(pieceUUID).getProperty('disabled').getValue(pieceUUID, true);
            if (!disabled) {
                const groupPieces = await recursivelyFindPieces(pieceUUID);
                pieces.push(...groupPieces);
            }
        }
    }

    return pieces;
};

export const isPieceOverwritten = async (groupUUID, pieceUUID) => {
    const proximityAuthoring = await VarvEngine.getConceptFromUUID(groupUUID).getProperty('proximityAuthoring').getValue(groupUUID, true);
    const pieces = await recursivelyFindPieces(groupUUID, proximityAuthoring);

    // Arrays are always merged
    const content = await VarvEngine.getConceptFromUUID(pieceUUID).getProperty('content').getValue(pieceUUID, true);
    if (content.startsWith('[')) return false;

    let targetPath = await VarvEngine.getConceptFromUUID(pieceUUID).getProperty('path').getValue(pieceUUID, true);

    // Data is always overwritten
    if (targetPath.startsWith('data.')) targetPath = 'data';

    const piecesWithSamePath = pieces.filter(p => (p.path.startsWith(targetPath) && !p.disabled));

    return piecesWithSamePath.length > 1 && piecesWithSamePath[piecesWithSamePath.length - 1].pieceUUID !== pieceUUID;
};

export const findAllFields = async () => {
    const pieces = await VarvEngine.getAllUUIDsFromType('VisPiece');
    const concept = VarvEngine.getConceptFromType('VisPiece');

    const fields = [];

    for (let i = 0; i &lt; pieces.length; i++) {
        const pieceUUID = pieces[i];
        const path = await concept.getProperty('path').getValue(pieceUUID, true);

        if (path.startsWith('data.')) {
            const content = await concept.getProperty('content').getValue(pieceUUID, true);
            let values = [];

            switch (path) {
                case 'data.values':
                    values = JSON.parse(content);
                    break;
                case 'data.fragment':
                    const component = getVisComponentById(content);
                    if (!component) {
                        console.error('Component not found', content);
                    }
                    values = component.getContentAsJSON();
                    break;
                case 'data.url':
                    const response = await fetch(content);
                    values = await response.json();
                    break;
                default:
                    console.warn('Unhandled data path', path);
                    break;
            }

            const firstElement = values[0];
            if (typeof firstElement === 'object') {
                for (const key in firstElement) {
                    fields.push(key);
                }
            }
        }
    }

    // Remove duplicates
    return [...new Set(fields)];
}



/* Composition */

const convertPieceToObject = (piece) => {
    const object = {};
    const pathParts = piece.path.split('.');

    let currentObject = object;
    for (let i = 0; i &lt; pathParts.length; i++) {
        const pathPart = pathParts[i];
        if (i === pathParts.length - 1) {
            try {
                // Arrays are stored as JSON strings
                // Numbers and booleans also need to be transformed
                const parsed = JSON.parse(piece.content);
                if (Array.isArray(parsed)) {
                    currentObject[pathPart] = parsed;
                } else if (typeof parsed == 'number') {
                    currentObject[pathPart] = parsed;
                } else if (typeof parsed == 'boolean') {
                    currentObject[pathPart] = parsed;
                } else {
                    throw new Error('Not an array');
                }
            } catch (e) {
                // Other values are plain strings
                currentObject[pathPart] = piece.content;
            }
        } else {
            currentObject[pathPart] = {};
            currentObject = currentObject[pathPart];
        }
    }

    return object;
};

const composeSpecFromGroupRecursively = async (groupUUID, proximityAuthoring = false) => {
    if (!groupUUID) return [];

    const pieces = [];

    const piecesToIterate = [];

    const groupPieces = await VarvEngine.getConceptFromUUID(groupUUID).getProperty('pieces').getValue(groupUUID, true);
    piecesToIterate.push(...groupPieces);

    if (proximityAuthoring) {
        const proximityPieces = await VarvEngine.getConceptFromUUID(groupUUID).getProperty('proximityPieces').getValue(groupUUID, true);

        const proximityPiecesObjects = [];
        for (let i = 0; i &lt; proximityPieces.length; i++) {
            const pieceUUID = proximityPieces[i];
            const position = await VarvEngine.getConceptFromUUID(pieceUUID).getProperty('position').getValue(pieceUUID, true);
            const positionY = position[1];
            proximityPiecesObjects.push({ pieceUUID, positionY });
        }
        proximityPiecesObjects.sort((a, b) => a.positionY - b.positionY);
        const orderedProximityPieces = proximityPiecesObjects.map(p => p.pieceUUID);

        piecesToIterate.push(...orderedProximityPieces);
    }

    for (let i = 0; i &lt; piecesToIterate.length; i++) {
        const pieceUUID = piecesToIterate[i];
        const conceptType = await VarvEngine.getConceptFromUUID(pieceUUID).name;
        const disabled = await VarvEngine.getConceptFromUUID(pieceUUID).getProperty('disabled').getValue(pieceUUID, true);

        if (!disabled) {
            if (conceptType === 'VisPiece') {
                const path = await VarvEngine.getConceptFromUUID(pieceUUID).getProperty('path').getValue(pieceUUID, true);
                const content = await VarvEngine.getConceptFromUUID(pieceUUID).getProperty('content').getValue(pieceUUID, true);
                pieces.push({
                    path: path,
                    content: content
                });
            } else if (conceptType === 'VisGroup') {
                const groupPieces = await composeSpecFromGroupRecursively(pieceUUID);
                pieces.push(...groupPieces);
            }
        }
    }

    return pieces;
};

export const composeSpecFromPieces = (pieces) => {
    let spec = {};

    for (let i = 0; i &lt; pieces.length; i++) {
        const piece = pieces[i];
        const pieceObject = convertPieceToObject(piece);
        spec = deepMerge(spec, pieceObject, deepMergeCustomizer);
    }

    return spec;
};

export const composeSpecFromGroup = async (groupUUID, proximityAuthoring) => {
    const pieces = await composeSpecFromGroupRecursively(groupUUID, proximityAuthoring);
    return composeSpecFromPieces(pieces);
};



/* Decomposition */

export const decomposeComponent = (component) => {
    if (component.type === DATASET_COMPONENT_TYPE) {
        return decomposeDatasetComponent(component);
    } else if (component.type === SPEC_COMPONENT_TYPE) {
        return decomposeSpecComponent(component);
    } else {
        return [];
    }
};

const decomposeDatasetComponent = (datasetComponent) => {
    return [
        {
            path: 'data.fragment',
            content: datasetComponent.id
        }
    ];
};

const decomposeSpecComponent = (specComponent) => {
    const spec = specComponent.getContentAsJSON();

    // Split into piece objects
    return decomposeSpec(spec);
};

export const decomposeSpec = (spec) => {

    // Removed properties
    delete spec['$schema'];
    delete spec.background;
    delete spec.padding;
    delete spec.autosize;
    delete spec.config;
    delete spec.usermeta;

    delete spec.name;
    delete spec.description;
    delete spec.title;
    delete spec.params;

    delete spec.width;
    delete spec.height;
    delete spec.view;
    delete spec.projection;

    return recursivelyDecomposeSpec(spec);
};

const recursivelyDecomposeSpec = (spec, path = '') => {
    const pieces = [];

    for (const key in spec) {
        const value = spec[key];
        const currentPath = path ? `${path}.${key}` : key;

        if (currentPath === 'data.values') {
            const piece = {
                path: currentPath,
                content: JSON.stringify(value)
            };
            pieces.push(piece);
        } else if (Array.isArray(value)) {
            for (let i = 0; i &lt; value.length; i++) {
                const subValue = value[i];
                const piece = {
                    path: currentPath,
                    content: JSON.stringify([subValue])
                };
                pieces.push(piece);
            }
        } else if (typeof value === 'object') {
            const subPieces = recursivelyDecomposeSpec(value, currentPath);
            pieces.push(...subPieces);
        } else if (typeof value === 'number' || typeof value === 'boolean') {
            const piece = {
                path: currentPath,
                content: JSON.stringify(value)
            };
            pieces.push(piece);
        } else {
            const piece = {
                path: currentPath,
                content: value
            };
            pieces.push(piece);
        }
    }

    return pieces;
};
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Vis-Uploader" id auto>import React from 'react';

import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer } from '#Menu .default';
import { SPEC_COMPONENT_TYPE, DATASET_COMPONENT_TYPE } from '#VisModule .vis-helpers';
import { createSpecVisComponent, createDatasetVisComponent } from '#VisModule .vis-component-manager';



if (!window.moduleVisComponentUploader) {
    window.moduleVisComponentUploader = {
        active: true
    };

    // Setup menu item
    addSubMenu('file-upload', 500, false);
    addItemToSubMenu('file-upload', 'title', &lt;MenuTitle title="Upload Files" />, 0);
    addItemToSubMenu('file-upload', 'upload-spec', &lt;div className="upload-drop-zone" id="spec-upload-drop-zone">Upload Vega-Lite Spec&lt;/div>, 100);
    addItemToSubMenu('file-upload', 'upload-dataset', &lt;div className="upload-drop-zone" id="dataset-upload-drop-zone">Upload Dataset&lt;/div>, 200);
    addItemToSubMenu('file-upload', 'spacer1', &lt;MenuSpacer />, 300);

    // TODO: This is not super robust
    const convertCSVtoJSON = (csv) => {
        const lines = csv.split('\n');
        const result = [];
        const headers = lines[0].split(',');
        for (let i = 1; i &lt; lines.length; i++) {
            const obj = {};
            const currentline = lines[i].split(',');
            for (let j = 0; j &lt; headers.length; j++) {
                const value = currentline[j];
                obj[headers[j]] = isNaN(value) ? value : parseFloat(value);
            }
            result.push(obj);
        }
        return JSON.stringify(result, null, 4);
    };

    const convertFileName = (fileName) => {
        return fileName.split('.').slice(0, -1).join('.').replace(/\s+/g, '_');
    };


    const handleUploadFile = (file, type) => {
        const reader = new FileReader();
        if (file.type === 'application/json') {
            reader.onload = (e) => {
                const content = e.target.result;
                const id = convertFileName(file.name);
                if (type === SPEC_COMPONENT_TYPE) {
                    createSpecVisComponent(content, id);
                } else if (type === DATASET_COMPONENT_TYPE) {
                    createDatasetVisComponent(content, id);
                }
            };
            reader.readAsText(file);
        } else if (file.type === 'text/csv') {
            reader.onload = (e) => {
                const content = e.target.result;
                const id = convertFileName(file.name);
                const dataset = convertCSVtoJSON(content);
                createDatasetVisComponent(dataset, id);
            };
            reader.readAsText(file);
        } else {
            alert('File type not supported.');
        }
    };

    const activateDropZone = (element, type) => {
        if (element.__uploadDropZoneActivated) return;

        element.addEventListener('dragover', (e) => {
            e.preventDefault();
            element.classList.add('upload-drop-zone--over');
        });

        element.addEventListener('dragleave', () => {
            element.classList.remove('upload-drop-zone--over');
        });

        element.addEventListener('drop', (e) => {
            e.preventDefault();
            element.classList.remove('upload-drop-zone--over');
            const files = e.dataTransfer.files;
            for (let i = 0; i &lt; files.length; i++) {
                const file = files[i];
                handleUploadFile(file, type);
            }
        });

        element.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = 'multiple';
            input.accept = type === SPEC_COMPONENT_TYPE ? 'application/json' : 'application/json, text/csv';
            input.onchange = (e) => {
                for (let i = 0; i &lt; e.target.files.length; i++) {
                    handleUploadFile(e.target.files[i], type);
                }
            };
            input.click();
        });

        element.__uploadDropZoneActivated = true;
    };

    cQuery(document.body).liveQuery('.upload-drop-zone', {
        'added': (element) => {
            if (element.id === 'spec-upload-drop-zone') {
                activateDropZone(element, SPEC_COMPONENT_TYPE);
            } else if (element.id === 'dataset-upload-drop-zone') {
                activateDropZone(element, DATASET_COMPONENT_TYPE);
            }
        }
    });
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="Optomancy" id="Optomancy"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
  "description": "Adds the Optomancy library for 3D visualizations.",
  "dependencies": [],
  "assets": [
    "optomancy.zip"
  ],
  "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Components"><WPM-PACKAGE id="Visualization" class name="Visualization"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Visualization components to render Vega-Lite in scenes.",
    "dependencies": [
        "#VisModule",
        "#Icon",
        "#Optomancy"
    ],
    "assets": [],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="default" name="Visualization">import React from 'react';
const { useMemo } = React;

import { VegaLite2DVisualization } from '#Visualization .vega-lite-2d';
import { VegaLite25DVisualization } from '#Visualization .vega-lite-25d';
import { OptomancyVisualization } from '#Visualization .optomancy';



export function Visualization({ mergedSpec }) {
    const visualization = useMemo(() => {
        if (mergedSpec.encoding?.z) {
            return &lt;OptomancyVisualization mergedSpec={mergedSpec} />;
        // } else if (mergedSpec.mark == 'arc'
        //     || mergedSpec.mark == 'image'
        //     || mergedSpec.mark == 'text'
        //     || mergedSpec.mark == 'trail'
        //     || mergedSpec.mark == 'geoshape'
        //     || mergedSpec.mark?.type == 'arc'
        //     || mergedSpec.mark?.type == 'image'
        //     || mergedSpec.mark?.type == 'text'
        //     || mergedSpec.mark?.type == 'trail'
        //     || mergedSpec.mark?.type == 'geoshape'
        // ) {
        } else {
            return &lt;VegaLite2DVisualization mergedSpec={mergedSpec} />;
        // } else {
        //     return &lt;VegaLite25DVisualization mergedSpec={mergedSpec} />;
        }
    }, [mergedSpec]);

    return visualization;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Vega-Lite 2D Visualization" id class="vega-lite-2d">import React from 'react';
const { useState, useEffect, useRef, useCallback, useMemo } = React;
import { MeshStandardMaterial, LinearMipmapLinearFilter, SRGBColorSpace } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { Plane } from '@react-three/drei';
import embed from 'vega-embed';



const VIS_SIZE = 512;

const frameGeometry = new RoundedBoxGeometry(1, 1, 0.01, 1);
const frameMaterial = new MeshStandardMaterial({ color: '#E0E0E0', metalness: 0.2, roughness: 0.5 });



export const createStringHash = (string) => {
    return crypto.subtle.digest('SHA-1', new TextEncoder().encode(string)).then(hashBuffer => {
        return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
    });
}

export function VegaLite2DVisualization({ mergedSpec }) {
    const canvas = useRef(document.createElement('canvas'));
    const context = useRef(canvas.current.getContext('2d'));

    const [aspectRatio, setAspectRatio] = useState(1);
    const [textureHash, setTextureHash] = useState();

    const [specHash, setSpecHash] = useState('');

    const updateVisualization = useCallback((tempDiv) => {
        const tempCanvas = tempDiv.querySelector('canvas');

        canvas.current.width = tempCanvas.width;
        canvas.current.height = tempCanvas.height;

        context.current.fillStyle = 'white';
        context.current.fillRect(0, 0, canvas.current.width, canvas.current.height);
        context.current.drawImage(tempCanvas, 0, 0);

        setAspectRatio(canvas.current.width / canvas.current.height);
        setTextureHash(crypto.randomUUID());
    }, [canvas, context]);

    const resetCanvas = useCallback(() => {
        context.current.fillStyle = 'white';
        context.current.fillRect(0, 0, canvas.current.width, canvas.current.height);
        setAspectRatio(1);
        setTextureHash(crypto.randomUUID());
    }, [canvas, context]);

    useEffect(() => {
        if (mergedSpec) {
            const newHash = createStringHash(JSON.stringify(mergedSpec));
            if (newHash !== specHash) {
                setSpecHash(newHash);

                mergedSpec.width = VIS_SIZE;
                mergedSpec.height = VIS_SIZE;

                const tempDiv = document.createElement('div');
                embed(tempDiv, mergedSpec, { renderer: 'canvas' }).then((result) => {
                    updateVisualization(tempDiv);
                    result.finalize();
                }).catch((error) => {
                    console.error(error);
                    resetCanvas();
                });
            }
        } else {
            resetCanvas();
        }
    }, [mergedSpec]);

    const texture = useMemo(() => &lt;canvasTexture attach="map" image={canvas.current} key={textureHash} anisoptry={16} generateMipmaps={true} minFilter={LinearMipmapLinearFilter} colorSpace={SRGBColorSpace} />, [textureHash]);

    return &lt;>
        &lt;mesh geometry={frameGeometry} material={frameMaterial}
            scale={[0.5 + 0.02, (0.5 / aspectRatio) + 0.02, 1]} position={[0.5, (0.25 / aspectRatio), -0.0055]} autoUpdateMatrix={false} />
        &lt;Plane args={[0.5, 0.5 / aspectRatio]} position={[0.5, 0.25 / aspectRatio, 0]} autoUpdateMatrix={false}>
            &lt;meshBasicMaterial toneMapped={false} color="white">
                {texture}
            &lt;/meshBasicMaterial>
        &lt;/Plane>
    &lt;/>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Vega-Lite 2D Visualization Canvas" id class="vega-lite-2d-canvas">import React from 'react';
const { useState, useEffect } = React;
import { Vega } from 'react-vega';



const VIS_SIZE = 190;

export const createStringHash = (string) => {
    return crypto.subtle.digest('SHA-1', new TextEncoder().encode(string)).then(hashBuffer => {
        return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
    });
}

export function VegaLite2DVisualizationCanvas({ mergedSpec }) {
    const [specHash, setSpecHash] = useState('');
    const [finalSpec, setFinalSpec] = useState({});

    useEffect(() => {
        if (mergedSpec) {
            const newHash = createStringHash(JSON.stringify(mergedSpec));
            if (newHash !== specHash) {
                setSpecHash(newHash);

                mergedSpec.width = VIS_SIZE;
                mergedSpec.height = VIS_SIZE;

                setFinalSpec(mergedSpec);
            }
        } else {
            setFinalSpec({});
        }
    }, [mergedSpec]);

    return &lt;Vega actions={false} spec={finalSpec} />;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Vega-Lite 25D Visualization" id class="vega-lite-25d">import React from 'react';
const { useState, useEffect, useRef } = React;
import { Color, Vector3, Object3D, MeshStandardMaterial, BoxGeometry } from 'three';
import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
import { useFrame } from '@react-three/fiber';
import { Sphere, RenderTexture, OrthographicCamera } from '@react-three/drei';
import embed from 'vega-embed';

import { Text } from '#Spatialstrates .text';



const USE_IMPOSTER_TEXT = false;
const DEBUG = false;

const VIS_SIZE = 200;
const CANVAS_SCALE = 1 / VIS_SIZE;
const DEPTH = 0.02
const VIS_OFFSET = 0.001;

const metalnessValue = 0.4;
const roughnessValue = 0.5;
const defaultGraphMaterial = new MeshStandardMaterial({ metalness: metalnessValue, roughness: roughnessValue });
const defaultGraphBoxGeometry = new BoxGeometry();



// Helpers to get the sizes right
const getItemX = (item) => {
    return item.hasOwnProperty('x2') ? Math.min(item.x, item.x2) * CANVAS_SCALE : item.x * CANVAS_SCALE;
};
const getItemY = (item) => {
    return item.hasOwnProperty('y2') ? Math.min(item.y, item.y2) * CANVAS_SCALE : item.y * CANVAS_SCALE;
};

const getItemSize = (item) => {
    return item.hasOwnProperty('size') ? (item.size / 18) * CANVAS_SCALE : 0.0025;
};
const getItemWidth = (item) => {
    return item.hasOwnProperty('width') ? item.width * CANVAS_SCALE : getItemWidthBounds(item);
};
const getItemHeight = (item) => {
    return item.hasOwnProperty('height') ? item.height * CANVAS_SCALE : getItemHeightBounds(item);
};

const getItemWidthBounds = (item) => {
    return item.hasOwnProperty('x2') ? Math.abs(item.x2 - item.x) * CANVAS_SCALE : 0.0025;
};
const getItemHeightBounds = (item) => {
    return item.hasOwnProperty('y2') ? Math.abs(item.y2 - item.y) * CANVAS_SCALE : 0.0025;
};

const getLineLength = (item, nextItem) => {
    if (!nextItem) nextItem = item;
    return (Math.sqrt(Math.pow(nextItem.x - item.x, 2) + Math.pow(nextItem.y - item.y, 2)) * CANVAS_SCALE);
};
const getLineHeight = (item, nextItem) => {
    if (!nextItem) nextItem = item;
    const lineLength = getLineLength(item, nextItem);
    const rotationAngle = Math.atan2(nextItem.y - item.y, nextItem.x - item.x);
    return lineLength * Math.sin(rotationAngle);
};
const getLineWidth = (item, nextItem) => {
    if (!nextItem) nextItem = item;
    const lineLength = getLineLength(item, nextItem);
    const rotationAngle = Math.atan2(nextItem.y - item.y, nextItem.x - item.x);
    return lineLength * Math.cos(rotationAngle);
};
const getLineRotation = (item, nextItem) => {
    if (!nextItem) nextItem = item;
    return [0, 0, -Math.atan2(nextItem.y - item.y, nextItem.x - item.x)];
};



// Used for area drawings in Vega Lite
function Trapezoid({ points, depth, color }) {
    const [geometry, setGeometry] = useState();

    useEffect(() => {
        const allPoints = [
            ...points,
            [points[0][0], points[0][1], points[0][2] - depth],
            [points[1][0], points[1][1], points[1][2] - depth],
            [points[2][0], points[2][1], points[2][2] - depth],
            [points[3][0], points[3][1], points[3][2] - depth]
        ].map(point => new Vector3(...point));

        const newGeometry = new ConvexGeometry(allPoints);

        setGeometry(newGeometry);
    }, [points, depth]);

    return &lt;mesh geometry={geometry}>
        &lt;meshStandardMaterial metalness={metalnessValue} roughness={roughnessValue} color={color} />
    &lt;/mesh>;
}

const collectBoxes = (items, state) => {
    let boxes = [];

    if (!items) return boxes;

    items.forEach((item) => {
        switch (item.marktype) {
            case 'rect':
                item.items.forEach((innerItem) => {
                    boxes.push({
                        color: innerItem.fill ? innerItem.fill : 'black',
                        scale: [getItemWidth(innerItem), getItemHeight(innerItem), DEPTH + VIS_OFFSET],
                        position: [state.position[0] + getItemX(innerItem) + (getItemWidth(innerItem) * 0.5), 1 - (state.position[1] + getItemY(innerItem) + (getItemHeight(innerItem) * 0.5)), -VIS_OFFSET]
                    })
                });
                break;
            case 'line':
                item.items.forEach((innerItem, index) => {
                    boxes.push({
                        color: innerItem.stroke ? innerItem.stroke : 'black',
                        scale: [getLineLength(innerItem, item.items[index + 1]), innerItem.strokeWidth * CANVAS_SCALE, DEPTH + VIS_OFFSET],
                        position: [state.position[0] + getItemX(innerItem) + (getLineWidth(innerItem, item.items[index + 1]) * 0.5), 1 - (state.position[1] + getItemY(innerItem) + getLineHeight(innerItem, item.items[index + 1]) * 0.5), -VIS_OFFSET],
                        rotation: getLineRotation(innerItem, item.items[index + 1])
                    })
                });
                break;
            case 'rule':
                item.items.forEach((innerItem) => {
                    boxes.push({
                        color: innerItem.stroke ? innerItem.stroke : 'black',
                        scale: [getItemWidth(innerItem), getItemHeight(innerItem), DEPTH],
                        position: [state.position[0] + getItemX(innerItem) + (getItemWidthBounds(innerItem) * 0.5), 1 - (state.position[1] + getItemY(innerItem) + (getItemHeightBounds(innerItem) * 0.5)), -VIS_OFFSET]
                    });
                });
                break;
            default:
                let newState = structuredClone(state);
                if (item.x) newState.position[0] += getItemX(item);
                if (item.y) newState.position[1] += getItemY(item);
                let childBoxes = collectBoxes(item.items, newState);
                boxes = [...boxes, ...childBoxes];
        }
    });

    return boxes;
};

const generateNonInstanced = (items, key) => {
    const itemComponents = [];

    for (let i = 0; i &lt; items.length; i++) {
        const item = items[i];
        const itemKey = key + '.' + i;
        const marktype = item.marktype ? item.marktype : '';

        switch (marktype) {
            case '':
                let childComponents = [];
                let itemComponent;
                if (item.items) {
                    childComponents = generateNonInstanced(item.items, itemKey)
                }
                if (item.x && item.y) {
                    itemComponent = &lt;group key={itemKey} position={[getItemX(item), 0 - getItemY(item), 0]}>{childComponents}&lt;/group>
                } else if (item.x) {
                    itemComponent = &lt;group key={itemKey} position={[getItemX(item), 0, 0]}>{childComponents}&lt;/group>
                } else if (item.y) {
                    itemComponent = &lt;group key={itemKey} position={[0, 0 - getItemY(item), 0]}>{childComponents}&lt;/group>
                } else {
                    itemComponent = &lt;group key={itemKey}>{childComponents}&lt;/group>
                }
                if (childComponents.length > 0) {
                    itemComponents.push(itemComponent);
                }
                break;
            case 'arc':
                console.warn('Missing marktype:', marktype, item);
                break;
            case 'group':
                itemComponents.push(&lt;group key={itemKey}>{generateNonInstanced(item.items, itemKey)}&lt;/group>);
                break;
            case 'image':
                console.warn('Missing marktype:', marktype, item);
                break;
            case 'path':
                console.warn('Missing marktype:', marktype, item);
                break;
            case 'area':
                const areas = item.items.map((innerItem, index) =>
                    &lt;Trapezoid key={itemKey + '-' + index}
                        points={[
                            [
                                getItemX(innerItem),
                                1 - getItemY(innerItem) - getItemHeightBounds(innerItem),
                                VIS_OFFSET + (DEPTH / 2)
                            ],
                            [
                                getItemX(innerItem),
                                1 - getItemY(innerItem) + getItemHeight(innerItem) - getItemHeightBounds(innerItem),
                                VIS_OFFSET + (DEPTH / 2)
                            ],
                            [
                                getItemX(item.items[index + 1] || innerItem),
                                1 - getItemY(item.items[index + 1] || innerItem) + getItemHeight(item.items[index + 1] || innerItem) - getItemHeightBounds(item.items[index + 1] || innerItem),
                                VIS_OFFSET + (DEPTH / 2)
                            ],
                            [
                                getItemX(item.items[index + 1] || innerItem),
                                1 - getItemY(item.items[index + 1] || innerItem) - getItemHeightBounds(item.items[index + 1] || innerItem),
                                VIS_OFFSET + (DEPTH / 2)
                            ]
                        ]}
                        depth={DEPTH + VIS_OFFSET}
                        color={innerItem.fill ? innerItem.fill : 'black'} />
                );
                itemComponents.push(areas);
                break;
            case 'symbol':
                // FIXME: This only does do spheres so far
                const symbols = item.items.map((innerItem, index) =>
                    &lt;Sphere key={itemKey + '-' + index}
                        args={[getItemSize(innerItem)]}
                        position={[getItemX(innerItem) + (getItemSize(innerItem) * 0.5), 1 - (getItemY(innerItem) + (getItemSize(innerItem) * 0)), -VIS_OFFSET]}>
                        &lt;meshStandardMaterial metalness={metalnessValue} roughness={roughnessValue} color={innerItem.stroke ? innerItem.stroke : innerItem.fill ? innerItem.fill : 'black'} />
                    &lt;/Sphere>
                );
                itemComponents.push(symbols);
                break;
            case 'trail':
                console.warn('Missing marktype:', marktype, item);
                break;
        }
    }

    return itemComponents;
};

const generateText = (items, key) => {
    const itemComponents = [];

    for (let i = 0; i &lt; items.length; i++) {
        const item = items[i];
        const itemKey = key + '.' + i;
        const marktype = item.marktype ? item.marktype : '';

        switch (marktype) {
            case '':
                let childComponents = [];
                let itemComponent;
                if (item.items) {
                    childComponents = generateText(item.items, itemKey)
                }
                if (item.x && item.y) {
                    itemComponent = &lt;group key={itemKey} position={[getItemX(item), 0 - getItemY(item), 0]}>{childComponents}&lt;/group>
                } else if (item.x) {
                    itemComponent = &lt;group key={itemKey} position={[getItemX(item), 0, 0]}>{childComponents}&lt;/group>
                } else if (item.y) {
                    itemComponent = &lt;group key={itemKey} position={[0, 0 - getItemY(item), 0]}>{childComponents}&lt;/group>
                } else {
                    itemComponent = &lt;group key={itemKey}>{childComponents}&lt;/group>
                }
                if (childComponents.length > 0) {
                    itemComponents.push(itemComponent);
                }
                break;
            case 'group':
                itemComponents.push(&lt;group key={itemKey}>{generateText(item.items, itemKey)}&lt;/group>);
                break;
            case 'text':
                const texts = item.items.map((innerItem, index) =>
                    &lt;Text key={itemKey + '-' + index}
                        position={[getItemX(innerItem), 1 - getItemY(innerItem), -VIS_OFFSET]}
                        textAlign={innerItem.align ? innerItem.align : 'center'}
                        anchorX={innerItem.align ? innerItem.align : 'center'}
                        anchorY={innerItem.baseline ? innerItem.baseline : 'middle'}
                        color={innerItem.fill ? innerItem.fill : 'black'}
                        outlineWidth="2%"
                        outlineColor="white"
                        fontSize={innerItem.fontSize * CANVAS_SCALE}
                        rotation={[0, 0, innerItem.angle ? -(innerItem.angle / 180) * Math.PI : 0]}>
                        {innerItem.text ? innerItem.text : null}
                    &lt;/Text>);
                itemComponents.push(texts);
                break;
        }
    }

    return itemComponents;
};

/**
 * Turn Vega-based specs into 3D visualizations
 */
const matrixProvider = new Object3D();
export function VegaLite25DVisualization({ mergedSpec }) {
    const [instancedMeshes, setInstancedMeshes] = useState([]);
    const [nonInstancedMeshes, setNonInstancedMeshes] = useState([]);
    const [textMeshes, setTextMeshes] = useState([]);
    const boxRefs = useRef();

    // When the mergedSpec changes, have Vega render it and convert to fiber when it is done
    useEffect(() => {
        if (mergedSpec) {
            if (DEBUG) console.log('Updating vega scene', mergedSpec);
            mergedSpec.width = VIS_SIZE;
            mergedSpec.height = VIS_SIZE;

            const temp = document.createElement('div');
            embed(temp, mergedSpec).then((result) => {
                setInstancedMeshes(collectBoxes(result.view._scenegraph.root.items, { position: [0, 0, 0], scale: [1, 1, 1], color: 'black' }));
                setNonInstancedMeshes(generateNonInstanced(result.view._scenegraph.root.items));
                setTextMeshes(generateText(result.view._scenegraph.root.items));
                result.finalize();
            }).catch((e) => {
                setInstancedMeshes([]);
                setNonInstancedMeshes([]);
                setTextMeshes([]);
                console.error(e);
            });
        }
    }, [mergedSpec]);

    // A bug in the Instancing component means we have to manually recompute the bounding box
    let needsBoundingUpdates = false;
    useFrame(() => {
        if (instancedMeshes && needsBoundingUpdates) {
            boxRefs.current.computeBoundingSphere();
            needsBoundingUpdates = false;
        }
    });
    useEffect(() => {
        if (instancedMeshes) {
            for (let i = 0; i &lt; instancedMeshes.length; i++) {
                let box = instancedMeshes[i];
                if (box.position) matrixProvider.position.set(box.position[0], box.position[1], box.position[2]);
                if (box.rotation) matrixProvider.rotation.set(box.rotation[0], box.rotation[1], box.rotation[2]);
                if (box.scale) matrixProvider.scale.set(box.scale[0], box.scale[1], box.scale[2]);
                matrixProvider.updateMatrix();
                boxRefs.current.setMatrixAt(i, matrixProvider.matrix)
                boxRefs.current.setColorAt(i, new Color(box.color));
            };
        }
        boxRefs.current.instanceMatrix.needsUpdate = true;
        if (boxRefs.current.instanceColor) boxRefs.current.instanceColor.needsUpdate = true;
        needsBoundingUpdates = true;
    }, [instancedMeshes]);

    const useImposterText = USE_IMPOSTER_TEXT; // Turns on or off imposter-based text rendering
    const overshoot = 2;

    return &lt;group scale={0.5} position={[0.25, 0.05, 0]}>
        &lt;instancedMesh ref={boxRefs} geometry={defaultGraphBoxGeometry} material={defaultGraphMaterial} args={[null, null, instancedMeshes ? instancedMeshes.length : 0]} />
        {nonInstancedMeshes}
        {useImposterText ? textMeshes && textMeshes.length > 0 ? &lt;mesh position={[0.5, 0.5, 0]} scale={overshoot}>
            &lt;planeGeometry />
            &lt;meshStandardMaterial transparent={true}>
                &lt;RenderTexture attach="map" frames={2} width={1024} height={1024} generateMipmaps={true}>
                    &lt;OrthographicCamera
                        makeDefault
                        zoom={1}
                        top={0.5 * overshoot}
                        bottom={-0.5 * overshoot}
                        left={-0.5 * overshoot}
                        right={0.5 * overshoot}
                        near={1}
                        far={2000}
                        position={[0.5, 0.5, 200]} />
                    &lt;ambientLight intensity={0.5} />
                    &lt;directionalLight position={[10, 10, 5]} />
                    {textMeshes}
                &lt;/RenderTexture>
            &lt;/meshStandardMaterial>
        &lt;/mesh> : null : textMeshes}
    &lt;/group>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Optomancy Visualization" id class="optomancy">import React from 'react';
let { useState, useEffect, useRef, useMemo } = React;
import { ErrorBoundary } from 'react-error-boundary';

const { OptomancyR3F } = await import(location.origin + location.pathname + 'optomancy.zip/optomancy-r3f.js');



const DEBUG = false;
const VIS_SIZE = 0.5;



export function OptomancyVisualization({ mergedSpec }) {
    const boundaryRef = useRef();
    const [config, setConfig] = useState({
        datasets: [],
        workspaces: []
    });

    useEffect(() => {
        if (DEBUG) console.log('OptomancyVisualization -> mergedSpec', mergedSpec);
        if (mergedSpec && mergedSpec.data) {
            const copiedSpec = Object.assign({}, mergedSpec);
            copiedSpec.data = null;
            copiedSpec.width = VIS_SIZE;
            copiedSpec.height = VIS_SIZE;
            copiedSpec.depth = VIS_SIZE;

            const config = {
                datasets: [
                    {
                        name: 'default_dataset',
                        values: mergedSpec.data.values,
                    }
                ],
                workspaces: [
                    {
                        data: 'default_dataset',
                        views: [ copiedSpec ]
                    }
                ]
            };
            if (DEBUG) console.log('OptomancyVisualization -> config', config);
            setConfig(config);
            if (boundaryRef.current) boundaryRef.current.resetErrorBoundary();
        } else {
            setConfig({
                datasets: [],
                workspaces: []
            });
        }
    }, [mergedSpec]);

    const visualization = useMemo(() => &lt;OptomancyR3F config={config} options={{ theme: 'light', renderText: true }} />, [config]);

    return &lt;ErrorBoundary ref={boundaryRef} fallback={null}>
        &lt;group position={[0.5, -0.35, 0.75]}>
            {visualization}
        &lt;/group>
    &lt;/ErrorBoundary>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Visualization Styles" auto></CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="VisPiece" name="VisPiece"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
  "description": "The VisPiece and VisGroup components for DashSpace.",
  "dependencies": [
    "#Container",
    "#VisModule",
    "#Icon",
    "#AIHelpers"
  ],
  "assets": [
    "components_dataset.glb",
    "components_snippets.glb",
    "components_specs.glb"
  ],
  "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Vis-Piece and Group Concepts" auto>{
    "concepts": {
        "VisMovable": {
            "schema": {
                "disabled": "boolean",
                "locked": "boolean",
                "group": { "VisGroup": { "default": "" }},
                "dropHighlight": "boolean"
            },
            "mappings": {
                "dropHighlight": [ "memory", "cauldron" ]
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        },
        "VisPiece": {
            "schema": {
                "path": "string",
                "content": "string",
                "editMode": "boolean",
                "editModeAxis": "boolean",
                "showDataset": "boolean"
            },
            "extensions": {
                "inject": [ "Movable", "VisMovable" ]
            }
        },
        "VisGroup": {
            "schema": {
                "name": { "string": { "default": "New Group" }},
                "pieces": { "array": "VisMovable" },
                "showVisualization": "boolean",
                "showSpec": "boolean",
                "force2DVisualization": "boolean",
                "paginationStartIndex": "number",
                "editorPiece": "VisPiece",
                "proximityAuthoring": "boolean",
                "proximityPieces": { "array": "VisMovable" }
            },
            "extensions": {
                "inject": [ "Movable", "VisMovable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="Vis-Piece Component" class="vis-piece">import React from 'react';
let { useState, useEffect, useMemo, useCallback } = React;
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { Sphere, useGLTF } from '@react-three/drei';
import { Root, Container, Text as UIText } from "@react-three/uikit";
import { useProperty } from '#VarvReact';

import { Text } from '#Spatialstrates .text';
import { Movable, useTransform } from '#Spatialstrates .movable';
import { deselectMovables, createMovable } from '#Spatialstrates .movable-helpers';
import { Icon } from '#Icon .default';

import { getOptionsForPath } from '#VisModule .vis-helpers';
import { getVisComponentById } from '#VisModule .vis-component-manager';
import { EnumEditor, NumberEditor, BooleanEditor, ColorEditor, FieldEditor, DatasetEditor, AxisEditor } from '#VisPiece .vis-editors-scene';
import { VisButton, visThemes, visMaterials, useIsVisible, SpeechToVisPiece, TranscribeIcon, frameGeometry, frameMaterial, getPieceTheme, onDragEndGroupingCallback, onDraggingUpdateGroupingHighlight, onDragEndResetGroupingHighlight, onDraggingUpdateProximityAuthoring, useUpdateProximityAuthoringOnSpaceChange } from '#VisPiece .vis-helpers';



const VIS_PIECE_WIDTH = 0.125;
const VIS_PIECE_HEIGHT = 0.125;
const DISTANCE_TO_BOX = 0.04;

/* Hooks and Components */

function VisPieceEditor({ position }) {
    const [path] = useProperty('path');
    const [editor, setEditor] = useState();

    useEffect(() => {
        if (!path) {
            setEditor(null);
            return;
        }

        const asyncCallback = async () => {
            const newOptions = await getOptionsForPath(path);
            switch (newOptions?.type) {
                case 'enum':
                    setEditor(&lt;EnumEditor options={newOptions} />);
                    break;
                case 'number':
                    setEditor(&lt;NumberEditor options={newOptions} />);
                    break;
                case 'boolean':
                    setEditor(&lt;BooleanEditor options={newOptions} />);
                    break;
                case 'color':
                    setEditor(&lt;ColorEditor options={newOptions} />);
                    break;
                case 'field':
                    setEditor(&lt;FieldEditor options={newOptions} />);
                    break;
                case 'dataset':
                    setEditor(&lt;DatasetEditor options={newOptions} />);
                    break;
                default:
                    setEditor(null);
            }
        };
        asyncCallback();
    }, [path]);

    return &lt;group position={position}>
        {editor}
    &lt;/group>;
}



function DatasetDisplay({ position }) {
    const [path] = useProperty('path');
    const [content] = useProperty('content');
    const [text, setText] = useState('');

    const updatePreview = useCallback((dataset) => {
        // setText(JSON.stringify(dataset.slice(0, 5), null, 2).replace(/^( +)/gm, match => match.replace(/ /g, '_')));
        setText(JSON.stringify(dataset.slice(0, 5), null, 3).replace(/^/gm, '|  '));
    }, [setText]);

    useEffect(() => {
        if (!path || !content || !path.startsWith('data')) {
            setText('');
            return;
        }

        if (path === 'data.fragment') {
            const component = getVisComponentById(content);
            if (component) {
                const dataset = component.getContentAsJSON();
                if (Array.isArray(dataset)) {
                    updatePreview(dataset);
                } else {
                    setText('');
                }
            } else {
                setText('');
            }
        } else if (path === 'data.url') {
            setText('Loading...');
            fetch(content)
                .then(response => response.json())
                .then(dataset => {
                    updatePreview(dataset);
                })
                .catch(() => {
                    setText('Error loading dataset from URL: ' + content);
                });
        } else if (path === 'data.values') {
            updatePreview(JSON.parse(content));
        }
    }, [path, content]);

    return &lt;>
        &lt;mesh geometry={frameGeometry}
            material={frameMaterial}
            scale={[0.25, 0.25, 1]}
            position={[position[0], position[1] + 0.125, -0.0026]}
            autoUpdateMatrix={false}>
        &lt;/mesh>
        &lt;group position={[position[0], position[1], 0]} autoUpdateMatrix={false}>
            &lt;Root anchorX="center" anchorY="bottom" flexDirection="column" pixelSize={0.0005} padding={15}>
                &lt;Container borderRadius={16} gap={16} width={470} height={470} overflow="scroll" flexDirection="column">
                    &lt;UIText textAlign="left" fontSize={16} color="white" whiteSpace="pre">{text}&lt;/UIText>
                &lt;/Container>
            &lt;/Root>
        &lt;/group>
    &lt;/>;
}



/* VisPiece Component */

function HandleIcon({ model, theme = '', themesOverride = '' }) {
    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');
    return &lt;Icon theme={theme + (selected ? ':selected' : '') + (hovered ? ':hovered' : '')} model={model} themesOverride={themesOverride} />
}

useGLTF.preload('components_snippets.glb');
useGLTF.preload('bookshelf.glb');

function VisPiece() {
    const snippetIcon = useGLTF('components_snippets.glb');
    const groupIcon = useGLTF('bookshelf.glb');
    const visible = useIsVisible();
    const [path] = useProperty('path');
    const [content] = useProperty('content');
    const [editMode, setEditMode] = useProperty('editMode');
    const [dropHighlight] = useProperty('dropHighlight');
    const [selected, setSelected] = useProperty('selected');
    const [locked, setLocked] = useProperty('locked');
    const [showDataset, setShowDataset] = useProperty('showDataset');
    const [hideEditor, setHideEditor] = useState();
    const [conceptUUID] = useProperty('concept::uuid');
    const [group, setGroup] = useProperty('group');
    const transform = useTransform();

    useEffect(() => {
        if (!path) {
            setHideEditor(true);
            return;
        }

        const asyncCallback = async () => {
            const newOptions = await getOptionsForPath(path);
            if (!newOptions) {
                setHideEditor(true);
            } else {
                setHideEditor(false);
            }
        };
        asyncCallback();
    }, [path]);

    const title = useMemo(() => {
        let contentTitle = content || '';

        if (path === 'data.fragment') {
            const component = getVisComponentById(content);
            if (component) {
                contentTitle = component.name;
            }
        }

        if (!selected) {
            contentTitle = contentTitle.length > 15 ? contentTitle.slice(0, 15) + '...' : contentTitle;
        } else {
            contentTitle = contentTitle.length > 50 ? contentTitle.slice(0, 50) + '...' : contentTitle;
        }

        return `${path}:
${contentTitle}`;
    }, [path, content, selected]);

    const [editModeAxis, setEditModeAxis] = useProperty('editModeAxis');
    const [axisEditable, setAxisEditable] = useState(false);

    useEffect(() => {
        if (!path) return;
        setAxisEditable(path.startsWith('encoding.'));
    }, [path]);

    const handle = useMemo(() => &lt;HandleIcon
        theme={getPieceTheme(path)}
        model={snippetIcon}
        themesOverride={visThemes}
    />, [path]);

    useUpdateProximityAuthoringOnSpaceChange();

    return visible ? &lt;Movable handle={handle}
        onDragEnd={async () => {
            await onDragEndResetGroupingHighlight();
            await onDraggingUpdateProximityAuthoring(conceptUUID);
            await onDragEndGroupingCallback(conceptUUID);
        }} onDragging={async () => {
            await onDraggingUpdateGroupingHighlight(conceptUUID);
            await onDraggingUpdateProximityAuthoring(conceptUUID);
        }}>
        &lt;Text position={[0, 0.025, 0.01]}
            autoUpdateMatrix={false}
            maxWidth={0.1}
            textAlign="center"
            anchorX="center"
            anchorY="center"
            color="white"
            outlineWidth="5%"
            outlineColor="black"
            lineHeight={2}
            fontSize={0.0125}>
            {title}
        &lt;/Text>

        {path?.startsWith('data') && (selected || showDataset) ? &lt;VisButton
            position={[0, 0.5 * VIS_PIECE_HEIGHT + DISTANCE_TO_BOX, 0]}
            callback={async () => {
                setShowDataset(!showDataset);
                await deselectMovables();
                setSelected(true);
            }}
            active={showDataset} title="Show Dataset" /> : null}
        {path?.startsWith('data') && showDataset ? &lt;DatasetDisplay position={[0, 0.5 * VIS_PIECE_HEIGHT + (2 * DISTANCE_TO_BOX), 0]} /> : null}

        {(selected || editMode) && !hideEditor ? &lt;VisButton
            position={[0.5 * VIS_PIECE_WIDTH + DISTANCE_TO_BOX, 0, 0]}
            rotation={[0, 0, Math.PI / 2]}
            callback={async () => {
                setEditMode(!editMode);
                await deselectMovables();
                setSelected(true);
            }}
            active={editMode} title="Edit Value" /> : null}
        {editMode ? &lt;VisPieceEditor position={[0.5 * VIS_PIECE_WIDTH + (2 * DISTANCE_TO_BOX) + 0.04, 0, 0]} /> : null}

        {(selected || editModeAxis) && axisEditable ? &lt;VisButton
            position={[-0.5 * VIS_PIECE_WIDTH - DISTANCE_TO_BOX, 0, 0]}
            rotation={[0, 0, -Math.PI / 2]}
            callback={async () => {
                setEditModeAxis(!editModeAxis);
                await deselectMovables();
                setSelected(true);
            }}
            active={editModeAxis} title="Edit Axis" /> : null}
        {editModeAxis ? &lt;group position={[-0.5 * VIS_PIECE_WIDTH - (2 * DISTANCE_TO_BOX) - 0.04, 0, 0]} autoUpdateMatrix={false}>
            &lt;AxisEditor />
        &lt;/group> : null}

        {selected ? &lt;VisButton position={[0, -0.5 * VIS_PIECE_HEIGHT - DISTANCE_TO_BOX, 0]} callback={async () => {
            setLocked(!locked);
            await deselectMovables();
            setSelected(true);
        }} active={locked} title="No Grouping" /> : null}

        {selected ? &lt;SpeechToVisPiece position={[-0.5 * VIS_PIECE_WIDTH, -0.5 * VIS_PIECE_HEIGHT - DISTANCE_TO_BOX, 0]} /> : null}

        {selected ? &lt;group onClick={async () => {
            const visGroupUUID = await createMovable('VisGroup', {
                pieces: [conceptUUID],
                position: transform.position,
                rotation: transform.rotation
            });

            setGroup(visGroupUUID);
        }}>
            &lt;Icon theme={'piece'} model={groupIcon} themesOverride={visThemes} scale={[0.07, 0.07, 0.035]}
                position={[0.5 * VIS_PIECE_WIDTH + 0.01, -0.5 * VIS_PIECE_HEIGHT - DISTANCE_TO_BOX - 0.02, 0]} />
            &lt;mesh geometry={new RoundedBoxGeometry(1.02 * 0.035, 1.02 * 0.035, 0.001, 10)} material={frameMaterial} position={[0.5 * VIS_PIECE_WIDTH + 0.01, -0.5 * VIS_PIECE_HEIGHT - DISTANCE_TO_BOX - 0.0017, -0.001]} />
        &lt;/group> : null}

        {dropHighlight ? &lt;Sphere position={[0, 0, 0]} args={[0.05, 16, 16]} material={visMaterials['selectedPrimary']} autoUpdateMatrix={false} /> : null}
    &lt;/Movable> : null;
}

export function Main() {
    const [conceptType] = useProperty('concept::name');
    return conceptType === 'VisPiece' ? &lt;VisPiece /> : null;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="vis-group" name="Vis-Group Component">import React from 'react';
let { useState, useEffect, useRef, useMemo } = React;
import { MeshStandardMaterial, Vector3 } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useThree } from '@react-three/fiber';
import { Sphere, Line, useGLTF } from '@react-three/drei';
import { Root, Container, Text as UIText } from "@react-three/uikit";
import { Varv, useProperty } from '#VarvReact';

import { Movable } from '#Spatialstrates .movable';
import { Text } from '#Spatialstrates .text';
import { deselectMovables } from '#Spatialstrates .movable-helpers';
import { getDeviceFromInputEvent } from '#Spatialstrates .device-helpers';
import { useGlobalEvents } from '#Spatialstrates .global-events';
import { getCurrentSpaceUUID } from '#Spatialstrates .projection-helpers';
import { moveMovableToNewSpace } from '#Container .container-helpers';
import { Icon } from '#Icon .default';

import { composeSpecFromGroup, isPieceOverwritten } from '#VisModule .vis-composer';
import { getVisComponentById } from '#VisModule .vis-component-manager';
import { VisButton, VisToggle, visThemes, visMaterials, useIsVisible, SpeechToVisGroup, TranscribeIcon, frameGeometry, frameMaterial, metalnessValue, roughnessValue, getPieceTheme, onDragEndGroupingCallback, onDraggingUpdateGroupingHighlight, onDragEndResetGroupingHighlight, onDraggingUpdateProximityAuthoring, useUpdateProximityAuthoringOnSpaceChange } from '#VisPiece .vis-helpers';
import { Visualization } from '#Visualization .default';



const CONCEPT_TYPE_PIECE = 'VisPiece';
const CONCEPT_TYPE_GROUP = 'VisGroup';

const DISTANCE_TO_BOX = 0.045;


/* Group View with helpers for the grid */

const SHELF_WIDTH = 0.4;
const SHELF_HEIGHT = 0.4;
const SHELF_BOARD_THICKNESS = 0.005;
const SHELF_DEPTH = 0.05;

function VisPieceDummyTitle({ setTitle, setOverwritten, groupUUID, updateOverwritten, setUpdateOverwritten }) {
    const [path] = useProperty('path');
    const [content] = useProperty('content');
    const [pieceUUID] = useProperty('concept::uuid');

    useEffect(() => {
        if (!groupUUID) return;
        if (!pieceUUID) return;
        const asyncFunc = async () => {
            const overwritten = await isPieceOverwritten(groupUUID, pieceUUID);
            setOverwritten(overwritten);
        };
        asyncFunc();
    }, [pieceUUID, groupUUID, updateOverwritten]);

    // useEffect(() => {
    //     setTitle(`${path}:${content}`);
    // }, [path, content]);

    useEffect(() => {
        let contentTitle = content || '';

        if (path === 'data.fragment') {
            const component = getVisComponentById(content);
            if (component) {
                contentTitle = component.name;
            }
        }

        setTitle(`${path}:${contentTitle}`);
    }, [path, content]);

    useEffect(() => {
        setUpdateOverwritten(updateOverwritten + 1);
    }, [path]);
}

function VisGroupDummyTitle({ setTitle, setOverwritten }) {
    const [name] = useProperty('name');

    useEffect(() => {
        setTitle(name || 'New Group');
    }, [name]);
}

const disableButtonMaterial = new MeshStandardMaterial({ color: 'hsl(200, 0%, 70%)', metalness: metalnessValue, roughness: roughnessValue });
const disableButtonMaterialHovered = new MeshStandardMaterial({ color: 'hsl(200, 0%, 80%)', metalness: metalnessValue, roughness: roughnessValue });



useGLTF.preload('components_snippets.glb');
useGLTF.preload('components_specs.glb');

function VisMovableDummy({ position, updateOverwritten, setUpdateOverwritten, groupSelected }) {
    const visPieceIcon = useGLTF('components_snippets.glb');
    const visGroupIcon = useGLTF('components_specs.glb');
    const [conceptUUID] = useProperty('concept::uuid');
    const [conceptType] = useProperty('concept::name');
    const [disabled, setDisabled] = useProperty('disabled');
    const [groupUUID, setGroup] = useProperty('group');

    const [overwritten, setOverwritten] = useState(false);
    const [title, setTitle] = useState('...');
    const meshRef = useRef();
    const iconModel = useMemo(() => conceptType == 'VisPiece' ? visPieceIcon : visGroupIcon, [conceptType]);
    const { triggerEvent } = useGlobalEvents();
    const { camera } = useThree();

    const selectStartHandler = async (device, e) => {
        if (e) e.stopPropagation();

        const visPieceConcept = VarvEngine.getConceptFromType('VisPiece');
        const visGroupConcept = VarvEngine.getConceptFromType('VisGroup');

        const groupPieces = await visGroupConcept.getPropertyValue(groupUUID, 'pieces');
        await visGroupConcept.setPropertyValue(groupUUID, 'pieces', groupPieces.filter(piece => piece !== conceptUUID));

        // TODO: Cleanup group or not?

        await visPieceConcept.setPropertyValue(conceptUUID, 'position', [meshRef.current.matrixWorld.elements[12], meshRef.current.matrixWorld.elements[13], meshRef.current.matrixWorld.elements[14]]);
        await visPieceConcept.setPropertyValue(conceptUUID, 'rotation', [camera.rotation.x, camera.rotation.y, camera.rotation.z]);

        setGroup('');
        await moveMovableToNewSpace(conceptUUID, await getCurrentSpaceUUID());

        setTimeout(() => {
            triggerEvent('initiate-drag', { target: conceptUUID, e: e });
        }, 100); // HACK: This is a bit brittle
    };

    useEffect(() => {
        setUpdateOverwritten(updateOverwritten + 1);
    }, [disabled]);

    const [hovered, setHovered] = useState(false);
    const hoverCallback = () => {
        setHovered(true);
    };
    const blurCallback = () => {
        setHovered(false);
    };

    const icon = useMemo(() => &lt;Icon theme={getPieceTheme(title) + (hovered ? ':hovered' : '')} model={iconModel} themesOverride={visThemes} />, [conceptType, hovered, title]);

    return &lt;>
        {conceptType == CONCEPT_TYPE_PIECE ? &lt;VisPieceDummyTitle setTitle={setTitle} setOverwritten={setOverwritten} groupUUID={groupUUID} updateOverwritten={updateOverwritten} setUpdateOverwritten={setUpdateOverwritten} /> : null}
        {conceptType == CONCEPT_TYPE_GROUP ? &lt;VisGroupDummyTitle setTitle={setTitle} setOverwritten={setOverwritten} /> : null}

        &lt;group position={position}>
            &lt;group onPointerOver={hoverCallback}
                onPointerOut={blurCallback}
                onPointerDown={(e) => {
                    const device = getDeviceFromInputEvent(e);
                    selectStartHandler(device, e);
                }}
                ref={meshRef} position={[-0.4 * SHELF_WIDTH, 0, 0]} scale={0.25}
                autoUpdateMatrix={false}>
                {icon}
            &lt;/group>

            &lt;Text position={[-0.325 * SHELF_WIDTH, 0, 0]}
                autoUpdateMatrix={false}
                textAlign="left"
                anchorX="left"
                anchorY="middle"
                color={disabled ? 'red' : overwritten ? '#555' : 'white'}
                outlineWidth="5%"
                outlineColor="black"
                fontSize={0.0175}>
                {groupSelected ? (title.length > 27 ? title.slice(0, 27) + '...' : title) : (title.length > 32 ? title.slice(0, 32) + '...' : title)}
            &lt;/Text>

            {groupSelected ? &lt;VisToggle value={disabled} invert={true} setValue={setDisabled} position={[0.39 * SHELF_WIDTH, 0, 0]} scale={0.48} materialPrimary={disableButtonMaterial} materialHovered={disableButtonMaterialHovered} outlineColor="red" /> : null}

            {/* {groupSelected ? &lt;VisButton active={disabled} position={[0.4 * SHELF_WIDTH, 0, 0]} scale={0.4} callback={() => {
                setDisabled(!disabled);
            }} materialPrimary={disableButtonMaterial} materialHovered={disableButtonMaterialHovered} outlineColor="red" /> : null} */}
        &lt;/group>
    &lt;/>;
}

const MAX_PIECES = 8;
const PIECES_SPACE_USED = 0.275;
function VisGroupViewPieces({ position }) {
    const [pieces] = useProperty('pieces');
    const [proximityAuthoring] = useProperty('proximityAuthoring');
    const [proximityPieces] = useProperty('proximityPieces');
    const [name, setName] = useProperty('name');
    const [selected] = useProperty('selected');
    const [paginationStartIndex, setPaginationStartIndex] = useProperty('paginationStartIndex');

    const [updateOverwritten, setUpdateOverwritten] = useState(1);

    const showPagination = useMemo(() => pieces && pieces.length > MAX_PIECES, [pieces]);

    useEffect(() => {
        setUpdateOverwritten(updateOverwritten + 1);
    }, [pieces, proximityPieces, proximityAuthoring]);

    useEffect(() => {
        if (!pieces) return;
        if (paginationStartIndex >= pieces.length - 1) {
            setPaginationStartIndex(Math.max(0, pieces.length - MAX_PIECES));
        }
    }, [pieces]);

    const piecesToRender = useMemo(() => {
        if (!pieces) return [];
        const piecesCopy = [...pieces];
        if (piecesCopy.length &lt;= MAX_PIECES) {
            return piecesCopy;
        } else {
            return piecesCopy.reverse().slice(paginationStartIndex, paginationStartIndex + MAX_PIECES).reverse();
        }
    }, [pieces, paginationStartIndex]);

    return &lt;group position={position}>
        &lt;Text position={[0.067, 0.5 * SHELF_HEIGHT - 0.015, 0]}
            autoUpdateMatrix={false}
            maxWidth={SHELF_WIDTH}
            textAlign="left"
            anchorX="left"
            anchorY="top"
            color="white"
            outlineWidth="5%"
            outlineColor="black"
            fontSize={0.025}>
            {name ? (name.length > 23 ? name.slice(0, 23) + '...' : name) : 'New Group'}
        &lt;/Text>
        {selected ? &lt;TranscribeIcon position={[0.040, 0.5 * SHELF_HEIGHT - 0.03, 0]} scale={0.7} setValue={setName} /> : null}

        {piecesToRender?.map((piece, index) => {
            const length = Math.min(piecesToRender.length, MAX_PIECES);
            return &lt;Varv target={piece} key={index}>
                &lt;VisMovableDummy
                    position={[
                        0.5 * SHELF_WIDTH,
                        - (length * (PIECES_SPACE_USED / MAX_PIECES)) + 0.295 * SHELF_HEIGHT + (index + 1) * (PIECES_SPACE_USED / MAX_PIECES),
                        0
                    ]}
                    updateOverwritten={updateOverwritten}
                    setUpdateOverwritten={setUpdateOverwritten}
                    groupSelected={selected} />
            &lt;/Varv>;
        })}

        {showPagination ? &lt;>
            &lt;VisButton position={[0.05, -(SHELF_HEIGHT - 0.23), 0]} scale={0.7} callback={() => {
                setPaginationStartIndex(Math.max(0, paginationStartIndex - MAX_PIECES + 1));
            }} title="Previous" />
            &lt;Text position={[0.5 * SHELF_WIDTH, -(SHELF_HEIGHT - 0.24), 0]}
                autoUpdateMatrix={false}
                textAlign="center"
                anchorX="center"
                anchorY="center"
                color="white"
                outlineWidth="5%"
                outlineColor="black"
                fontSize={0.0175}>
                {paginationStartIndex + 1}{Math.min(pieces.length, paginationStartIndex + MAX_PIECES)} of {pieces.length}
            &lt;/Text>
            &lt;VisButton position={[SHELF_WIDTH - 0.05, -(SHELF_HEIGHT - 0.23), 0]} scale={0.7} callback={() => {
                setPaginationStartIndex(Math.min(pieces.length - MAX_PIECES, paginationStartIndex + MAX_PIECES - 1));
            }} title="Next" />
        &lt;/> : null}
    &lt;/group>;
}



/* Spec and Visualization Views */

function SpecComposerPieceUpdater({ updateSpec }) {
    const [path] = useProperty('path');
    const [content] = useProperty('content');
    const [disabled] = useProperty('disabled');
    const [position] = useProperty('position');

    useEffect(() => {
        updateSpec();
    }, [path, content, disabled, position]);
}

function SpecComposerGroupUpdater({ updateSpec }) {
    // const [proximityAuthoring] = useProperty('proximityAuthoring');
    // const [proximityPieces] = useProperty('proximityPieces');

    // useEffect(() => {
    //     if (proximityAuthoring) {
    //         updateSpec();
    //     }
    // }, [proximityPieces]);

    const [position] = useProperty('position');

    useEffect(() => {
        updateSpec();
    }, [position]);

    return &lt;>
        &lt;Varv property="pieces">
            &lt;SpecComposerUpdater updateSpec={updateSpec} />
        &lt;/Varv>
        {/* {proximityAuthoring ? &lt;Varv property="proximityPieces">
            &lt;SpecComposerUpdater updateSpec={updateSpec} />
        &lt;/Varv> : null} */}
    &lt;/>;
}

// Update the spec when a piece or group is updated
function SpecComposerUpdater({ updateSpec }) {
    const [conceptUUID] = useProperty('concept::uuid');
    const [conceptType] = useProperty('concept::name');
    const [disabled] = useProperty('disabled');

    useEffect(() => {
        updateSpec();
    }, [disabled]);

    const pieceUpdater = useMemo(() => conceptType == CONCEPT_TYPE_PIECE ? &lt;SpecComposerPieceUpdater updateSpec={updateSpec} /> : null, [conceptType]);
    const groupUpdater = useMemo(() => conceptType == CONCEPT_TYPE_GROUP ? &lt;SpecComposerGroupUpdater updateSpec={updateSpec} /> : null, [conceptType]);

    const updater = useMemo(() => conceptUUID ? &lt;Varv target={conceptUUID}>
        {pieceUpdater}
        {groupUpdater}
    &lt;/Varv> : null, [conceptUUID]);

    return updater;
}

// Utility function to compose a spec from a group
export function SpecComposer({ setComposedSpec }) {
    const [conceptUUID] = useProperty('concept::uuid');
    const [proximityAuthoring] = useProperty('proximityAuthoring');
    const [proximityPieces] = useProperty('proximityPieces');

    const throttleTimeout = useRef();
    const updateSpec = () => {
        if (throttleTimeout.current) {
            clearTimeout(throttleTimeout.current);
        }
        const timeout = setTimeout(async () => {
            try {
                const spec = await composeSpecFromGroup(conceptUUID, proximityAuthoring);
                setComposedSpec(spec);
            } catch (e) {
                console.error('Error composing spec:', e);
            }
        }, 100);
        throttleTimeout.current = timeout;
    };

    useEffect(() => {
        updateSpec();
    }, [proximityAuthoring, proximityPieces]);

    return &lt;>
        &lt;Varv property="pieces">
            &lt;SpecComposerUpdater updateSpec={updateSpec} />
        &lt;/Varv>
        &lt;Varv property="proximityPieces">
            &lt;SpecComposerUpdater updateSpec={updateSpec} />
        &lt;/Varv>
    &lt;/>;
}

function VisGroupViewSpec({ position }) {
    const [composedSpec, setComposedSpec] = useState({});
    const composer = useMemo(() => &lt;SpecComposer setComposedSpec={setComposedSpec} />, []);
    const cardRef = useRef();

    return &lt;>
        {composer}
        &lt;mesh geometry={frameGeometry}
            material={frameMaterial}
            scale={[0.25, 0.25, 1]}
            position={[position[0] - 0.125, position[1] - 0.125, -0.0026]}
            autoUpdateMatrix={false}>
        &lt;/mesh>
        &lt;group position={[position[0], position[1], 0]} autoUpdateMatrix={false}>
            &lt;Root anchorX="right" anchorY="top" flexDirection="column" pixelSize={0.0005} padding={15}>
                &lt;Container borderRadius={16} gap={16} width={470} height={470} overflow="scroll" flexDirection="column" ref={cardRef}>
                    &lt;UIText fontFamily="inter" textAlign="left" color="white" fontSize={16}>{composedSpec ? JSON.stringify(composedSpec, null, 3).replace(/^/gm, '|  ') : ''}&lt;/UIText>
                &lt;/Container>
            &lt;/Root>
        &lt;/group>
    &lt;/>;
}

function VisGroupViewVisualization({ position }) {
    const [composedSpec, setComposedSpec] = useState({});
    const composer = useMemo(() => &lt;SpecComposer setComposedSpec={setComposedSpec} />, []);
    const [finalSpec, setFinalSpec] = useState({});

    const updateFragmentData = () => {
        const spec = structuredClone(composedSpec);

        const component = getVisComponentById(composedSpec.data.fragment);
        if (component) {
            delete spec.data.fragment;
            spec.data.values = component.getContentAsJSON();
        } else {
            spec.data.error = 'Could not find component for fragment: ' + composedSpec.data.fragment;
        }

        setFinalSpec(spec);
    };

    useEffect(() => {
        if (composedSpec?.data?.fragment) {
            const component = getVisComponentById(composedSpec.data.fragment);
            component?.addContentChangedListener(updateFragmentData);

            updateFragmentData();

            return () => {
                component?.removeContentChangedListener(updateFragmentData);
            };
        } else {
            setFinalSpec(composedSpec);
        }
    }, [composedSpec]);

    return &lt;>
        {composer}
        &lt;group position={position} autoUpdateMatrix={false}>
            &lt;Visualization mergedSpec={finalSpec} />
        &lt;/group>
    &lt;/>;
}



/* Proximity Authoring */

const PROXIMITY_PIECE = 0.1;
const PROXIMITY_GROUP = 0.28;
const PROXIMITY_LOCKED_GROUP = 0.2;
function VisGroupConnector({ sourcePosition, sourceLocked }) {
    const color = useMemo(() => visThemes['piece']?.line || 'black', []);
    const [group] = useProperty('group');
    const [targetPosition] = useProperty('position');
    const [conceptType] = useProperty('concept::name');
    const [locked] = useProperty('locked');

    const targetPositionCorrected = useMemo(() => {
        if (!targetPosition) return;
        if (!sourcePosition) return;
        const targetPositionVector = new Vector3(...targetPosition);
        targetPositionVector.add(new Vector3(...sourcePosition).sub(targetPositionVector).normalize().multiplyScalar(conceptType == 'VisPiece' ? PROXIMITY_PIECE : locked ? PROXIMITY_LOCKED_GROUP : PROXIMITY_GROUP));
        return targetPositionVector;
    }, [targetPosition, locked, sourcePosition]);

    const sourcePositionCorrected = useMemo(() => {
        if (!targetPosition) return;
        if (!sourcePosition) return;
        const sourcePositionVector = new Vector3(...sourcePosition);
        sourcePositionVector.add(new Vector3(...targetPosition).sub(sourcePositionVector).normalize().multiplyScalar(sourceLocked ? PROXIMITY_LOCKED_GROUP : PROXIMITY_GROUP));
        return sourcePositionVector;
    }, [sourcePosition, sourceLocked, targetPosition]);

    return !group && sourcePositionCorrected && targetPositionCorrected ? &lt;Line
        points={[...sourcePositionCorrected.toArray(), ...targetPositionCorrected.toArray()]}
        color={color}
        lineWidth={2}
    /> : null;
}

function VisGroupConnectors() {
    const [sourcePosition] = useProperty('position');
    const [locked] = useProperty('locked');

    return &lt;Varv property="proximityPieces">
        &lt;VisGroupConnector sourcePosition={sourcePosition} sourceLocked={locked} />
    &lt;/Varv>;
}



/* VisGroup Component */

function HandleIcon({ model, theme = '', themesOverride = '' }) {
    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');
    return &lt;Icon theme={theme + (selected ? ':selected' : '') + (hovered ? ':hovered' : '')} model={model} themesOverride={themesOverride} />
}

useGLTF.preload('bookshelf.glb');

function VisGroup() {
    const bookshelfIcon = useGLTF('bookshelf.glb');
    const lockedGroupIcon = useGLTF('components_specs.glb');
    const visible = useIsVisible();
    const [pieces] = useProperty('pieces');

    const [showVisualization, setShowVisualization] = useProperty('showVisualization');
    const [showSpec, setShowSpec] = useProperty('showSpec');

    const [proximityAuthoring, setProximityAuthoring] = useProperty('proximityAuthoring');
    const [locked, setLocked] = useProperty('locked');

    const [selected, setSelected] = useProperty('selected');
    const [dropHighlight] = useProperty('dropHighlight');
    const [name] = useProperty('name');
    const [conceptUUID] = useProperty('concept::uuid');

    const handlePieces = useMemo(() => !locked ? &lt;>
        &lt;group scale={[2 * SHELF_WIDTH, 2 * SHELF_HEIGHT, 0.2]}
            position={[0, -0.5 * SHELF_HEIGHT - SHELF_BOARD_THICKNESS, 0]}
            autoUpdateMatrix={false}>
            &lt;HandleIcon theme="piece" model={bookshelfIcon} themesOverride={visThemes} />
        &lt;/group>
        &lt;mesh geometry={new RoundedBoxGeometry(1.02 * SHELF_WIDTH, 1.02 * SHELF_HEIGHT, SHELF_BOARD_THICKNESS, 10)} material={frameMaterial} position={[0, 0, -0.7 * SHELF_DEPTH * 0.2]} />
    &lt;/> : &lt;group scale={3}>
        &lt;HandleIcon theme="piece" model={lockedGroupIcon} themesOverride={visThemes} scale={2} autoUpdateMatrix={false} />
    &lt;/group>, [locked]);

    // Clean up pieces when the group is deleted
    useEffect(() => {
        const callback = (context) => {
            setTimeout(async () => {
                if (context.target === conceptUUID) {
                    for (let piece of pieces) {
                        await VarvEngine.getConceptFromUUID(piece).delete(piece);
                    }
                }
            }, 100);
        };

        const registeredCallback = VarvEngine.registerEventCallback('disappeared', callback);
        return () => { registeredCallback.delete(); };
    }, [conceptUUID, pieces]);

    useUpdateProximityAuthoringOnSpaceChange();

    return visible ? &lt;>
        {proximityAuthoring ? &lt;VisGroupConnectors positionAdjustment={locked ? [0, 0, 0] : [0.5 * SHELF_WIDTH + DISTANCE_TO_BOX, 0, 0]} /> : null}

        &lt;Movable handle={handlePieces}
            onDragEnd={async () => {
                await onDragEndResetGroupingHighlight();
                await onDraggingUpdateProximityAuthoring(conceptUUID);
                await onDragEndGroupingCallback(conceptUUID);
            }}
            onDragging={async () => {
                await onDraggingUpdateGroupingHighlight(conceptUUID);
                await onDraggingUpdateProximityAuthoring(conceptUUID);
            }}>
            {!locked ? &lt;VisGroupViewPieces position={[-0.5 * SHELF_WIDTH, 0, 0]} /> : null}

            {locked ? &lt;Text position={[0, 0.5 * SHELF_HEIGHT + 1.5 * DISTANCE_TO_BOX, 0]}
                autoUpdateMatrix={false}
                textAlign="center"
                anchorX="center"
                anchorY="center"
                color="black"
                outlineWidth="5%"
                outlineColor="white"
                fontSize={0.04}>
                {name ? name : 'New Group'}
            &lt;/Text> : null}

            {(selected || showVisualization) && !locked ? &lt;VisButton active={showVisualization} position={[0, 0.5 * SHELF_HEIGHT + DISTANCE_TO_BOX, 0]} callback={async () => {
                setShowVisualization(!showVisualization);
                await deselectMovables();
                setSelected(true);
            }} title="Visualization" /> : null}
            {showVisualization ? &lt;>
                &lt;VisGroupViewVisualization position={[-((0.5 * 0.25) + 0.375), 0.5 * SHELF_HEIGHT + 0.09, 0]} />
            &lt;/> : null}

            {(selected || showSpec) && !locked ? &lt;VisButton active={showSpec} position={[-(0.5 * SHELF_WIDTH + DISTANCE_TO_BOX), 0, 0]} rotation={[0, 0, -Math.PI / 2]} callback={async () => {
                setShowSpec(!showSpec);
                await deselectMovables();
                setSelected(true);
            }} title="Spec" /> : null}
            {showSpec ? &lt;VisGroupViewSpec position={[- (0.5 * SHELF_WIDTH + (1.9 * DISTANCE_TO_BOX)), 0.5 * 0.25, 0]} /> : null}

            {(selected || proximityAuthoring) && !locked ? &lt;VisButton active={proximityAuthoring} position={[0.5 * SHELF_WIDTH + DISTANCE_TO_BOX, 0, 0]} rotation={[0, 0, Math.PI / 2]} callback={async () => {
                setProximityAuthoring(!proximityAuthoring);
                await onDraggingUpdateProximityAuthoring(conceptUUID);
                await deselectMovables();
                setSelected(true);
            }} title="Proximity Authoring" /> : null}

            {selected || locked ? &lt;VisButton active={locked} position={[0 * SHELF_WIDTH, -0.5 * SHELF_HEIGHT - DISTANCE_TO_BOX, 0]} callback={async () => {
                setLocked(!locked);
                await deselectMovables();
                setSelected(true);
            }} title="Lock Group" /> : null}

            {selected && !proximityAuthoring && !locked ? &lt;SpeechToVisGroup position={[-0.4 * SHELF_WIDTH, -0.5 * SHELF_HEIGHT - DISTANCE_TO_BOX, 0]} /> : null}

            {dropHighlight ? &lt;Sphere position={[0, 0, 0]} args={[0.05, 16, 16]} material={visMaterials['selectedPrimary']} autoUpdateMatrix={false} /> : null}
        &lt;/Movable>
    &lt;/> : null;
}

export function Main() {
    const [conceptType] = useProperty('concept::name');
    return conceptType === 'VisGroup' ? &lt;VisGroup /> : null;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Vis-Piece Shape" class="dynamic-shape-component">import React from 'react';
const { useState, useEffect, useRef, useMemo, useCallback } = React;
import { HTMLContainer, stopEventPropagation } from 'tldraw';
import { useProperty } from '#VarvReact';

import { useGlobalEvents } from '#Spatialstrates .global-events';
import { MovableShapeUtil, MovableVarvScope } from '#Spatialstrates .movable-shape';
import { CANVAS_SCALE } from '#Spatialstrates .projection-helpers';
import { deselectMovables } from '#Spatialstrates .movable-helpers';

import { getOptionsForPath } from '#VisModule .vis-helpers';
import { getVisComponentById } from '#VisModule .vis-component-manager';
import { EnumEditor, NumberEditor, BooleanEditor, ColorEditor, FieldEditor, DatasetEditor, AxisEditor } from '#VisPiece .vis-editors-canvas';
import { visThemes, useIsVisible, SpeechToVisPiece2D, getPieceTheme, onDragEndGroupingCallback, onDragEndResetGroupingHighlight, onDraggingUpdateProximityAuthoring, useUpdateProximityAuthoringOnSpaceChange } from '#VisPiece .vis-helpers';




function DatasetDisplay() {
    const [path] = useProperty('path');
    const [content] = useProperty('content');
    const [text, setText] = useState('');

    const updatePreview = useCallback((dataset) => {
        setText(JSON.stringify(dataset.slice(0, 5), null, 3));
    }, [setText]);

    useEffect(() => {
        if (!path || !content || !path.startsWith('data')) {
            setText('');
            return;
        }

        if (path === 'data.fragment') {
            const component = getVisComponentById(content);
            if (component) {
                const dataset = component.getContentAsJSON();
                if (Array.isArray(dataset)) {
                    updatePreview(dataset);
                } else {
                    setText('');
                }
            } else {
                setText('');
            }
        } else if (path === 'data.url') {
            setText('Loading...');
            fetch(content)
                .then(response => response.json())
                .then(dataset => {
                    updatePreview(dataset);
                })
                .catch(() => {
                    setText('Error loading dataset from URL: ' + content);
                });
        } else if (path === 'data.values') {
            updatePreview(JSON.parse(content));
        }
    }, [path, content]);

    return &lt;div className="dataset-display" onPointerDown={stopEventPropagation} onScroll={stopEventPropagation} style={{
        width: `${CANVAS_SCALE * 0.25}px`,
        height: `${CANVAS_SCALE * 0.25}px`
    }}>{text}&lt;/div>;
}

function ValueEditor() {
    const [path] = useProperty('path');
    const [editor, setEditor] = useState();

    useEffect(() => {
        if (!path) {
            setEditor(null);
            return;
        }

        const asyncCallback = async () => {
            const newOptions = await getOptionsForPath(path);
            switch (newOptions?.type) {
                case 'enum':
                    setEditor(&lt;EnumEditor options={newOptions} />);
                    break;
                case 'number':
                    setEditor(&lt;NumberEditor options={newOptions} />);
                    break;
                case 'boolean':
                    setEditor(&lt;BooleanEditor options={newOptions} />);
                    break;
                case 'color':
                    setEditor(&lt;ColorEditor options={newOptions} />);
                    break;
                case 'field':
                    setEditor(&lt;FieldEditor options={newOptions} />);
                    break;
                case 'dataset':
                    setEditor(&lt;DatasetEditor options={newOptions} />);
                    break;
                default:
                    setEditor(null);
            }
        };
        asyncCallback();
    }, [path]);

    return editor;
}



function VisPieceShape({ shape, isEditing }) {
    const [conceptUUID] = useProperty('concept::uuid');
    const [path, setPath] = useProperty('path');
    const [content, setContent] = useProperty('content');
    const [locked, setLocked] = useProperty('locked');
    const [showDataset, setShowDataset] = useProperty('showDataset');
    const [selected, setSelected] = useProperty('selected');
    // TODO Add drop highlight
    const [dropHighlight] = useProperty('dropHighlight');

    const visible = useIsVisible();
    const theme = useMemo(() => getPieceTheme(path), [path]);

    const [editMode, setEditMode] = useProperty('editMode');
    const [hideEditor, setHideEditor] = useState();
    useEffect(() => {
        if (!path) {
            setHideEditor(true);
            return;
        }

        const asyncCallback = async () => {
            const newOptions = await getOptionsForPath(path);
            if (!newOptions) {
                setHideEditor(true);
            } else {
                setHideEditor(false);
            }
        };
        asyncCallback();
    }, [path]);

    const [editModeAxis, setEditModeAxis] = useProperty('editModeAxis');
    const [axisEditable, setAxisEditable] = useState(false);
    useEffect(() => {
        if (!path) return;
        setAxisEditable(path.startsWith('encoding.'));
    }, [path]);

    const { subscribeEvent } = useGlobalEvents();

    useEffect(() => {
        const unsubscribe = subscribeEvent('drag-end', async (data) => {
            if (data.target != conceptUUID) return;

            await onDragEndResetGroupingHighlight();
            await onDraggingUpdateProximityAuthoring(conceptUUID);
            await onDragEndGroupingCallback(conceptUUID);
        });

        return () => unsubscribe();
    }, [subscribeEvent, conceptUUID]);

    useUpdateProximityAuthoringOnSpaceChange();

    // TODO: Add onDragging
    // }} onDragging={async () => {
    //     await onDraggingUpdateGroupingHighlight(conceptUUID);
    //     await onDraggingUpdateProximityAuthoring(conceptUUID);
    // }}

    const pathRef = useRef(null);
    const contentRef = useRef(null);
    const pathCursorRef = useRef(0);
    const contentCursorRef = useRef(0);

    useEffect(() => {
        if (pathRef.current) {
            pathRef.current.selectionStart = pathCursorRef.current;
            pathRef.current.selectionEnd = pathCursorRef.current;
        }
    }, [path]);

    useEffect(() => {
        if (contentRef.current) {
            contentRef.current.selectionStart = contentCursorRef.current;
            contentRef.current.selectionEnd = contentCursorRef.current;
        }
    }, [content]);

    return visible ? &lt;HTMLContainer className={`vis-piece-shape theme-${theme || 'non'}`} style={{
        transform: 'translate(-50%, -50%)',
        width: shape.props.w + 'px',
        height: shape.props.h + 'px',
        backgroundColor: visThemes[theme].primary,
        borderColor: visThemes[theme].secondary,
        pointerEvents: 'all'
    }}>
        {isEditing ? &lt;>
            &lt;textarea
                ref={pathRef}
                className="path" value={path}
                onChange={(e) => {
                    pathCursorRef.current = e.target.selectionStart;
                    setPath(e.target.value);
                }}
                onPointerDown={stopEventPropagation}
                onPointerMove={stopEventPropagation}
            />
            &lt;textarea
                ref={contentRef}
                className="content" value={content}
                onChange={(e) => {
                    contentCursorRef.current = e.target.selectionStart;
                    setContent(e.target.value);
                }}
                onPointerDown={stopEventPropagation}
                onPointerMove={stopEventPropagation}
            />
        &lt;/> : &lt;>
            &lt;div className="path" title={path}>{path}&lt;/div>
            &lt;div className="content" title={content}>{content}&lt;/div>
        &lt;/>}


        {path?.startsWith('data') && (selected || showDataset) ? &lt;div className={`dataset-button button ${showDataset ? 'active' : ''}`}
            onPointerDown={async (e) => {
                stopEventPropagation(e);
                setShowDataset(!showDataset);
                await deselectMovables();
                setSelected(true);
            }}>Show Dataset&lt;/div> : null}
        {path?.startsWith('data') && showDataset ? &lt;DatasetDisplay /> : null}

        {selected ? &lt;div className={`lock-button button ${locked ? 'active' : ''}`} onPointerDown={async (e) => {
            stopEventPropagation(e);
            setLocked(!locked);
            await deselectMovables();
            setSelected(true);
        }}>No Grouping&lt;/div> : null}

        {(selected || editModeAxis) && axisEditable ? &lt;div className={`edit-axis-button button ${editModeAxis ? 'active' : ''}`}
            onPointerDown={async (e) => {
                stopEventPropagation(e);
                setEditModeAxis(!editModeAxis);
                await deselectMovables();
                setSelected(true);
            }}>Edit Axis&lt;/div> : null}
        {editModeAxis ? &lt;AxisEditor /> : null}

        {(selected || editMode) && !hideEditor ? &lt;div className={`edit-value-button button ${editMode ? 'active' : ''}`}
            onPointerDown={async (e) => {
                stopEventPropagation(e);
                setEditMode(!editMode);
                await deselectMovables();
                setSelected(true);
            }}>Edit Value&lt;/div> : null}
        {editMode ? &lt;ValueEditor /> : null}

        {selected ? &lt;SpeechToVisPiece2D /> : null}
    &lt;/HTMLContainer> : null;
}

class VisPieceShapeUtil extends MovableShapeUtil {
    static type = 'VisPiece';

    getDefaultProps() {
        return Object.assign(super.getDefaultProps(), {
            w: CANVAS_SCALE * 0.125,
            h: CANVAS_SCALE * 0.125
        });
    }

    canEdit = () => true;

    component(shape) {
        const isEditing = this.editor.getEditingShapeId() === shape.id;

        return &lt;MovableVarvScope shape={shape}>
            &lt;VisPieceShape shape={shape} isEditing={isEditing} />
        &lt;/MovableVarvScope>;
    }
}

export const Main = VisPieceShapeUtil;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Vis-Group Shape" class="dynamic-shape-component">import React from 'react';
const { useState, useEffect, useRef, useMemo } = React;
import { useEditor, HTMLContainer, stopEventPropagation } from 'tldraw';
import { Varv, useProperty } from '#VarvReact';

import { useGlobalEvents } from '#Spatialstrates .global-events';
import { getCurrentSpaceUUID, CANVAS_SCALE } from '#Spatialstrates .projection-helpers';
import { MovableShapeUtil, MovableVarvScope } from '#Spatialstrates .movable-shape';
import { deselectMovables } from '#Spatialstrates .movable-helpers';
import { moveMovableToNewSpace } from '#Container .container-helpers';

import { isPieceOverwritten } from '#VisModule .vis-composer';
import { getVisComponentById } from '#VisModule .vis-component-manager';
import { visThemes, useIsVisible, SpeechToVisGroup2D, getPieceTheme, onDragEndGroupingCallback, onDragEndResetGroupingHighlight, onDraggingUpdateProximityAuthoring, useUpdateProximityAuthoringOnSpaceChange } from '#VisPiece .vis-helpers';
import { SpecComposer } from '#VisPiece .vis-group';
import { VegaLite2DVisualizationCanvas } from '#Visualization .vega-lite-2d-canvas';




const CONCEPT_TYPE_PIECE = 'VisPiece';
const CONCEPT_TYPE_GROUP = 'VisGroup';

function VisGroupConnector({ sourceConceptUUID }) {
    const [pieceConceptUUID] = useProperty('concept::uuid');
    const editor = useEditor();

    useEffect(() => {
        if (!editor) return;
        if (!sourceConceptUUID) return;
        if (!pieceConceptUUID) return;

        const sourceShapeId = `shape:${sourceConceptUUID}`;
        const targetShapeId = `shape:${pieceConceptUUID}`;
        const newShapeId = `shape:${sourceConceptUUID}:${pieceConceptUUID}`;
        const sourceBindingId = `binding:source:${sourceConceptUUID}:${pieceConceptUUID}`;
        const targetBindingId = `binding:target:${sourceConceptUUID}:${pieceConceptUUID}`;

        if (!editor.getShape(sourceShapeId)) return;
        if (!editor.getShape(targetShapeId)) return;

        editor.createShape({
            type: 'arrow',
            id: newShapeId,
            isLocked: true,
            props: {
                color: 'yellow',
                arrowheadStart: 'none',
                arrowheadEnd: 'none'
            }
        });
        editor.createBinding({
            type: 'arrow',
            id: sourceBindingId,
            fromId: newShapeId,
            toId: sourceShapeId,
            props: {
                terminal: 'start'
            }
        });
        editor.createBinding({
            type: 'arrow',
            id: targetBindingId,
            fromId: newShapeId,
            toId: targetShapeId,
            props: {
                terminal: 'end'
            }
        });

        return () => {
            editor.deleteBinding(targetBindingId);
            editor.deleteBinding(sourceBindingId);
            editor.updateShape({
                id: newShapeId,
                isLocked: false
            });
            editor.deleteShape(newShapeId);
        }
    }, [editor, sourceConceptUUID, pieceConceptUUID]);
}

function VisualizationDisplay() {
    const [composedSpec, setComposedSpec] = useState({});
    const composer = useMemo(() => &lt;SpecComposer setComposedSpec={setComposedSpec} />, []);
    const [finalSpec, setFinalSpec] = useState({});

    const updateFragmentData = () => {
        const spec = structuredClone(composedSpec);

        const component = getVisComponentById(composedSpec.data.fragment);
        if (component) {
            delete spec.data.fragment;
            spec.data.values = component.getContentAsJSON();
        } else {
            spec.data.error = 'Could not find component for fragment: ' + composedSpec.data.fragment;
        }

        setFinalSpec(spec);
    };

    useEffect(() => {
        if (composedSpec?.data?.fragment) {
            const component = getVisComponentById(composedSpec.data.fragment);
            component?.addContentChangedListener(updateFragmentData);

            updateFragmentData();

            return () => {
                component?.removeContentChangedListener(updateFragmentData);
            };
        } else {
            setFinalSpec(composedSpec);
        }
    }, [composedSpec]);

    return &lt;>
        {composer}
        &lt;div className="visualization-display" style={{
            width: `${CANVAS_SCALE * 0.5}px`,
            height: `${CANVAS_SCALE * 0.5}px`
        }}>
            &lt;VegaLite2DVisualizationCanvas mergedSpec={finalSpec} />
        &lt;/div>
    &lt;/>;
}

function SpecDisplay() {
    const [composedSpec, setComposedSpec] = useState({});
    const composer = useMemo(() => &lt;SpecComposer setComposedSpec={setComposedSpec} />, []);

    return &lt;>
        {composer}
        &lt;div className="spec-display" style={{
            width: `${CANVAS_SCALE * 0.25}px`,
            height: `${CANVAS_SCALE * 0.25}px`
        }}>
            {composedSpec ? JSON.stringify(composedSpec, null, 3) : ''}
        &lt;/div>
    &lt;/>;
}

function VisPieceDummyTitle({ setTheme, setTitle, setOverwritten, groupUUID, updateOverwritten, setUpdateOverwritten }) {
    const [path] = useProperty('path');
    const [content] = useProperty('content');
    const [pieceUUID] = useProperty('concept::uuid');
    const theme = useMemo(() => getPieceTheme(path), [path]);

    useEffect(() => {
        setTheme(theme);
    }, [theme]);

    useEffect(() => {
        if (!groupUUID) return;
        if (!pieceUUID) return;
        const asyncFunc = async () => {
            const overwritten = await isPieceOverwritten(groupUUID, pieceUUID);
            setOverwritten(overwritten);
        };
        asyncFunc();
    }, [pieceUUID, groupUUID, updateOverwritten]);

    useEffect(() => {
        let contentTitle = content || '';

        if (path === 'data.fragment') {
            const component = getVisComponentById(content);
            if (component) {
                contentTitle = component.name;
            }
        }

        setTitle(`${path}:${contentTitle}`);
    }, [path, content]);

    useEffect(() => {
        setUpdateOverwritten(updateOverwritten + 1);
    }, [path]);
}

function VisGroupDummyTitle({ setTitle, setOverwritten }) {
    const [name] = useProperty('name');

    useEffect(() => {
        setTitle(name || 'New Group');
    }, [name]);
}

function VisMovableDummy({ groupPosition, updateOverwritten, setUpdateOverwritten, groupSelected }) {
    const [conceptUUID] = useProperty('concept::uuid');
    const [conceptType] = useProperty('concept::name');
    const [disabled, setDisabled] = useProperty('disabled');
    const [groupUUID, setGroup] = useProperty('group');
    const [position, setPosition] = useProperty('position');
    const [theme, setTheme] = useState('bookshelf');

    const [overwritten, setOverwritten] = useState(false);
    const [title, setTitle] = useState('...');

    const selectStartHandler = async (e) => {
        stopEventPropagation(e);

        const visGroupConcept = VarvEngine.getConceptFromType('VisGroup');

        const groupPieces = await visGroupConcept.getPropertyValue(groupUUID, 'pieces');
        await visGroupConcept.setPropertyValue(groupUUID, 'pieces', groupPieces.filter(piece => piece !== conceptUUID));

        if (groupPosition) setPosition(groupPosition);
        setGroup('');
        await moveMovableToNewSpace(conceptUUID, await getCurrentSpaceUUID());
    };

    useEffect(() => {
        setUpdateOverwritten(updateOverwritten + 1);
    }, [disabled]);

    return &lt;div className={`vis-piece-dummy ${overwritten ? 'overwritten' : ''} ${disabled ? 'disabled' : ''}`}>
        {conceptType == CONCEPT_TYPE_PIECE ? &lt;VisPieceDummyTitle setTheme={setTheme} setTitle={setTitle} setOverwritten={setOverwritten} groupUUID={groupUUID} updateOverwritten={updateOverwritten} setUpdateOverwritten={setUpdateOverwritten} /> : null}
        {conceptType == CONCEPT_TYPE_GROUP ? &lt;VisGroupDummyTitle setTitle={setTitle} setOverwritten={setOverwritten} /> : null}

        &lt;div className={`vis-piece-dummy-icon theme-${theme || 'non'}`}
            onPointerDown={selectStartHandler}
            style={{
                backgroundColor: visThemes[theme].primary,
                borderColor: visThemes[theme].secondary,
            }} />

        &lt;div className="vis-piece-dummy-title">
            {title}
        &lt;/div>

        {groupSelected ? &lt;div className="dummy-disable-toggle"
            onPointerDown={(e) => {
                e.stopPropagation();
                setDisabled(!disabled);
            }}
        /> : null}
    &lt;/div >;
}

const MAX_PIECES = 8;
function VisGroupViewPieces({ isEditing }) {
    const [pieces] = useProperty('pieces');
    const [proximityAuthoring] = useProperty('proximityAuthoring');
    const [proximityPieces] = useProperty('proximityPieces');
    const [name, setName] = useProperty('name');
    const [selected] = useProperty('selected');
    const [paginationStartIndex, setPaginationStartIndex] = useProperty('paginationStartIndex');
    const [position] = useProperty('position');

    const inputRef = useRef(null);
    const cursorRef = useRef(0);
    useEffect(() => {
        if (inputRef.current) {
            inputRef.current.selectionStart = cursorRef.current;
            inputRef.current.selectionEnd = cursorRef.current;
        }
    }, [name]);

    const [updateOverwritten, setUpdateOverwritten] = useState(1);

    const showPagination = useMemo(() => pieces && pieces.length > MAX_PIECES, [pieces]);

    useEffect(() => {
        setUpdateOverwritten(updateOverwritten + 1);
    }, [pieces, proximityPieces, proximityAuthoring]);

    useEffect(() => {
        if (!pieces) return;
        if (paginationStartIndex >= pieces.length - 1) {
            setPaginationStartIndex(Math.max(0, pieces.length - MAX_PIECES));
        }
    }, [pieces]);

    const piecesToRender = useMemo(() => {
        if (!pieces) return [];
        const piecesCopy = [...pieces];
        if (piecesCopy.length &lt;= MAX_PIECES) {
            return piecesCopy;
        } else {
            return piecesCopy.reverse().slice(paginationStartIndex, paginationStartIndex + MAX_PIECES).reverse();
        }
    }, [pieces, paginationStartIndex]);

    return &lt;>
        &lt;div className="group-title">
            &lt;div className="group-title-icon" />
            {isEditing ? &lt;input ref={inputRef} type="text" value={name}
                onChange={(e) => {
                    cursorRef.current = e.target.selectionStart;
                    setName(e.target.value);
                }}
                onPointerDown={stopEventPropagation}
                onPointerMove={stopEventPropagation}
            /> : &lt;div className="group-name">
                {name || 'New Group'}
            &lt;/div>}
        &lt;/div>

        &lt;div className="pieces-list">
            {piecesToRender?.map((piece, index) => {
                return &lt;Varv target={piece} key={index}>
                    &lt;VisMovableDummy
                        groupPosition={position}
                        updateOverwritten={updateOverwritten}
                        setUpdateOverwritten={setUpdateOverwritten}
                        groupSelected={selected} />
                &lt;/Varv>;
            })}
        &lt;/div>

        {showPagination ? &lt;div className="group-pagination">
            &lt;div className="button" onPointerDown={(e) => {
                stopEventPropagation(e);
                setPaginationStartIndex(Math.max(0, paginationStartIndex - MAX_PIECES + 1));
            }}>Previous&lt;/div>
            &lt;div className="pagination-text">
                {paginationStartIndex + 1}{Math.min(pieces.length, paginationStartIndex + MAX_PIECES)} of {pieces.length}
            &lt;/div>
            &lt;div className="button" onPointerDown={(e) => {
                stopEventPropagation(e);
                setPaginationStartIndex(Math.min(pieces.length - MAX_PIECES, paginationStartIndex + MAX_PIECES - 1));
            }}>Next&lt;/div>
        &lt;/div> : null}
    &lt;/>;
}



function VisGroupShape({ shape, isEditing }) {
    const [conceptUUID] = useProperty('concept::uuid');
    const visible = useIsVisible();
    const [pieces] = useProperty('pieces');
    const [locked, setLocked] = useProperty('locked');
    const [selected, setSelected] = useProperty('selected');

    const [name] = useProperty('name');
    const [showVisualization, setShowVisualization] = useProperty('showVisualization');
    const [showSpec, setShowSpec] = useProperty('showSpec');
    const [proximityAuthoring, setProximityAuthoring] = useProperty('proximityAuthoring');

    // Clean up pieces when the group is deleted
    useEffect(() => {
        const callback = (context) => {
            setTimeout(async () => {
                if (context.target === conceptUUID) {
                    for (let piece of pieces) {
                        await VarvEngine.getConceptFromUUID(piece).delete(piece);
                    }
                }
            }, 100);
        };

        const registeredCallback = VarvEngine.registerEventCallback('disappeared', callback);
        return () => { registeredCallback.delete(); };
    }, [conceptUUID, pieces]);


    const { subscribeEvent } = useGlobalEvents();
    useEffect(() => {
        const unsubscribe = subscribeEvent('drag-end', async (data) => {
            if (data.target != conceptUUID) return;

            await onDragEndResetGroupingHighlight();
            await onDraggingUpdateProximityAuthoring(conceptUUID);
            await onDragEndGroupingCallback(conceptUUID);
        });

        return () => unsubscribe();
    }, [subscribeEvent, conceptUUID]);

    useUpdateProximityAuthoringOnSpaceChange();

    // TODO: Add onDragging
    // onDragging={async () => {
    //     await onDraggingUpdateGroupingHighlight(conceptUUID);
    //     await onDraggingUpdateProximityAuthoring(conceptUUID);
    // }}

    return visible ? &lt;HTMLContainer className={`vis-group-shape ${locked ? 'locked' : ''}`} style={{
        transform: 'translate(-50%, -50%)',
        width: shape.props.w + 'px',
        height: shape.props.h + 'px',
        pointerEvents: 'all'
    }}>
        {!locked ? &lt;VisGroupViewPieces isEditing={isEditing} /> : &lt;div className="group-name">{name}&lt;/div>}

        {(selected || showSpec) && !locked ? &lt;div className={`spec-button button ${showSpec ? 'active' : ''}`}
            onPointerDown={async (e) => {
                stopEventPropagation(e);
                setShowSpec(!showSpec);
                await deselectMovables();
                setSelected(true);
            }}>Show Spec&lt;/div> : null}
        {showSpec ? &lt;SpecDisplay /> : null}

        {(selected || showVisualization) && !locked ? &lt;div className={`visualization-button button ${showVisualization ? 'active' : ''}`}
            onPointerDown={async (e) => {
                stopEventPropagation(e);
                setShowVisualization(!showVisualization);
                await deselectMovables();
                setSelected(true);
            }}>Show Visualization&lt;/div> : null}
        {showVisualization ? &lt;VisualizationDisplay /> : null}

        {(selected && !locked) || proximityAuthoring ? &lt;div className={`proximity-authoring-button button ${proximityAuthoring ? 'active' : ''}`} onPointerDown={async (e) => {
            stopEventPropagation(e);
            setProximityAuthoring(!proximityAuthoring);
            await deselectMovables();
            setSelected(true);
        }}>Proximity Authoring&lt;/div> : null}
        {proximityAuthoring ? &lt;Varv property="proximityPieces">
            &lt;VisGroupConnector sourceConceptUUID={conceptUUID} />
        &lt;/Varv> : null}

        {selected || locked ? &lt;div className={`lock-button button ${locked ? 'active' : ''}`} onPointerDown={async (e) => {
            stopEventPropagation(e);
            setLocked(!locked);
            await deselectMovables();
            setSelected(true);
        }}>Lock Group&lt;/div> : null}

        {selected && !proximityAuthoring && !locked ? &lt;SpeechToVisGroup2D /> : null}
    &lt;/HTMLContainer> : null;
}

class VisGroupShapeUtil extends MovableShapeUtil {
    static type = 'VisGroup';

    getDefaultProps() {
        return Object.assign(super.getDefaultProps(), {
            w: CANVAS_SCALE * 0.4,
            h: CANVAS_SCALE * 0.4
        });
    }

    canEdit = () => true;

    component(shape) {
        const isEditing = this.editor.getEditingShapeId() === shape.id;

        return &lt;MovableVarvScope shape={shape}>
            &lt;VisGroupShape shape={shape} isEditing={isEditing} />
        &lt;/MovableVarvScope>;
    }
}

export const Main = VisGroupShapeUtil;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="vis-editors-scene" name="Vis-Editors Scene">import React from 'react';
let { useState, useEffect, useMemo } = React;
import { SphereGeometry, MeshStandardMaterial } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useProperty } from '#VarvReact';

import { Text } from '#Spatialstrates .text';
import { findAllFields } from '#VisModule .vis-composer';
import { getDatasetComponents } from '#VisModule .vis-component-manager';
import { VisButton, frameMaterial, frameMaterialDisabled, metalnessValue, roughnessValue } from '#VisPiece .vis-helpers';



const VEGA_LITE_COLORS = [
    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
    '#8c564b', '#e377c2', '#000000', '#bcbd22', '#17becf'
];
const VEGA_LITE_COLORS_HOVER = [
    '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5',
    '#c49c94', '#f7b6d2', '#222222', '#dbdb8d', '#9edae5'
];

let vegaLiteColorMaterials = {};
if (window.vegaLiteColorMaterials) {
    vegaLiteColorMaterials = window.vegaLiteColorMaterials;
} else {
    VEGA_LITE_COLORS.forEach((color, index) => {
        const material = new MeshStandardMaterial({
            color: color,
            metalness: metalnessValue,
            roughness: roughnessValue
        });
        vegaLiteColorMaterials[color] = material;

        const hoverMaterial = new MeshStandardMaterial({
            color: VEGA_LITE_COLORS_HOVER[index],
            metalness: metalnessValue,
            roughness: roughnessValue
        });
        vegaLiteColorMaterials[color + ':hover'] = hoverMaterial;
    });
    window.vegaLiteColorMaterials = vegaLiteColorMaterials;
}

export function EnumEditor({ options }) {
    const [content, setContent] = useProperty('content');

    return &lt;>
        {options.enum.map((option, index) => {
            const x = index % 5;
            const y = Math.floor(index / 5);
            const offset = Math.floor(options.enum.length / 5) * 0.025;
            return &lt;VisButton
                key={index}
                position={[0.09 * x, offset - 0.05 * y, 0]}
                active={content == option}
                callback={() => {
                    setContent(option);
                }}
                title={option}
            />;
        })}
    &lt;/>;
}

const sliderButtonGeometry = new SphereGeometry(0.5, 16, 16);
const sliderGeometry = new RoundedBoxGeometry(0.3, 0.01, 0.01, 1);
export function NumberEditor({ options }) {
    const [content, setContent] = useProperty('content');
    const [value, setValue] = useState(0);

    const normalize = (value) => {
        // normalize value using options.min and options.max
        const min = options.min || 0;
        const max = options.max || 1;
        return Math.min(1, Math.max(0, (value - min) / (max - min)));
    }

    useEffect(() => {
        const normalizedValue = normalize(content);
        setValue(normalizedValue);
    }, [content]);

    const updateValue = (newValue) => {
        const sanitizedValue = Math.min(1, Math.max(0, newValue));
        const min = options.min || 0;
        const max = options.max || 1;
        const value = min + sanitizedValue * (max - min);
        const roundedValue = Math.round(value * 100) / 100;
        setContent(roundedValue);
    };

    return &lt;>
        &lt;VisButton position={[0, 0, 0]} callback={() => updateValue(value - 0.1)} title="-" fontSizeMultiplicator={3} />
        &lt;VisButton position={[0.4, 0, 0]} callback={() => updateValue(value + 0.1)} title="+" fontSizeMultiplicator={3} />

        &lt;mesh geometry={sliderGeometry}
            material={frameMaterial}
            autoUpdateMatrix={false}
            position={[0.15 + 0.05, 0, 0]}>
        &lt;/mesh>
        &lt;mesh geometry={sliderButtonGeometry}
            material={frameMaterial}
            autoUpdateMatrix={false}
            position={[value * 0.3 + 0.05, 0, 0]}
            scale={[0.03, 0.03, 0.03]}>
        &lt;/mesh>
        &lt;Text
            position={[value * 0.3 + 0.05, 0.02, 0]}
            autoUpdateMatrix={false}
            textAlign="center"
            anchorX="center"
            anchorY="bottom"
            color="black"
            outlineWidth="5%"
            outlineColor="white"
            fontSize={0.01}>
            {content}
        &lt;/Text>
    &lt;/>;
}

const booleanToggleGeometry = new RoundedBoxGeometry(0.03, 0.03, 0.01);
export function BooleanEditor() {
    const [content, setContent] = useProperty('content');

    return &lt;>
        &lt;VisButton callback={() => {
            setContent(content == 'true' ? 'false' : 'true');
        }} active={content == 'true'} />
        &lt;mesh geometry={booleanToggleGeometry}
            material={content == 'true' ? frameMaterial : frameMaterialDisabled}
            autoUpdateMatrix={false}
            position={[content == 'true' ? 0.02 : -0.022, 0, 0.005]}>
            &lt;Text
                position={[0, 0.012, 0.0075]}
                autoUpdateMatrix={false}
                textAlign="center"
                anchorX="center"
                anchorY="center"
                color="white"
                fontSize={0.02}>
                {content == 'true' ? 'I' : 'O'}
            &lt;/Text>
        &lt;/mesh>
    &lt;/>;
}

export function ColorEditor() {
    const [content, setContent] = useProperty('content');

    return &lt;>
        {VEGA_LITE_COLORS.map((color, index) => {
            const x = index % 5;
            const y = Math.floor(index / 5);
            return &lt;VisButton
                key={index}
                position={[0.09 * x, 0.025 - 0.05 * y, 0]}
                active={content == color}
                callback={() => {
                    setContent(color);
                }}
                materialPrimary={vegaLiteColorMaterials[color]}
                materialHovered={vegaLiteColorMaterials[color + ':hover']}
            />;
        })}
    &lt;/>;

};

export function FieldEditor() {
    const [enumOptions, setEnumOptions] = useState({ type: 'enum', enum: [] });

    useEffect(() => {
        const asyncCallback = async () => {
            const fields = await findAllFields();
            setEnumOptions({
                type: 'enum',
                enum: fields
            });
        };
        asyncCallback();
    }, []);

    return &lt;EnumEditor options={enumOptions} type="fieldEditor" />;
}

export function DatasetEditor() {
    const [content, setContent] = useProperty('content');
    const datasets = useMemo(() => getDatasetComponents(), []);

    return &lt;>
        {datasets.map((dataset, index) => {
            const x = index % 5;
            const y = Math.floor(index / 5);
            const offset = Math.floor(datasets.length / 5) * 0.025;
            return &lt;VisButton
                key={index}
                position={[0.09 * x, offset - 0.05 * y, 0]}
                active={content == dataset.id}
                callback={() => {
                    setContent(dataset.id);
                }}
                title={dataset.name}
            />;
        })}
    &lt;/>;

}


const axisOptions = ['color', 'z', 'y', 'x'];
export function AxisEditor() {
    const [path, setPath] = useProperty('path');
    const [axis, setAxis] = useState();

    useEffect(() => {
        if (!path) return;
        if (path.startsWith('encoding.x')) setAxis('x');
        if (path.startsWith('encoding.y')) setAxis('y');
        if (path.startsWith('encoding.z')) setAxis('z');
        if (path.startsWith('encoding.color')) setAxis('color');
        if (path.startsWith('encoding.size')) setAxis('size');
    }, [path]);

    const callback = (option) => {
        setAxis(option);
        const newPath = path.replace(/encoding\.(x|y|z|color|size)/, 'encoding.' + option);
        setPath(newPath);
    };

    return &lt;>
        {axisOptions.map((option, index) => {
            const x = index % 5;
            const y = Math.floor(index / 5);
            return &lt;VisButton
                key={index}
                position={[-0.09 * x, - 0.05 * y, 0]}
                active={axis == option}
                callback={() => callback(option)}
                title={option}
            />;
        })}
    &lt;/>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="vis-editors-canvas" name="Vis-Editors Canvas">import React from 'react';
let { useState, useEffect, useMemo } = React;
import { stopEventPropagation } from 'tldraw';
import { useProperty } from '#VarvReact';

import { findAllFields } from '#VisModule .vis-composer';
import { getDatasetComponents } from '#VisModule .vis-component-manager';



const VEGA_LITE_COLORS = [
    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
    '#8c564b', '#e377c2', '#000000', '#bcbd22', '#17becf'
];
const VEGA_LITE_COLORS_HOVER = [
    '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5',
    '#c49c94', '#f7b6d2', '#222222', '#dbdb8d', '#9edae5'
];

export function EnumEditor({ options }) {
    const [content, setContent] = useProperty('content');

    return &lt;>
        {options.enum.map((option, index) => {
            const x = index % 5;
            const y = Math.floor(index / 5);
            return &lt;div className={`button ${content == option ? 'active' : ''}`}
                key={index}
                style={{
                    right: "-52px",
                    top: "50%",
                    transform: `translate(50%, -50%) translate(${x * 105}%, ${y * 105}%) translateY(-${Math.floor((options.enum.length - 1) / 5) * 50}%)`
                }}
                onPointerDown={(e) => {
                    stopEventPropagation(e);
                    setContent(option);
                }}>{option}&lt;/div>;
        })}
    &lt;/>;
}

export function NumberEditor({ options }) {
    const [content, setContent] = useProperty('content');
    const [value, setValue] = useState(0);

    const normalize = (value) => {
        // normalize value using options.min and options.max
        const min = options.min || 0;
        const max = options.max || 1;
        return Math.min(1, Math.max(0, (value - min) / (max - min)));
    }

    useEffect(() => {
        const normalizedValue = normalize(content);
        setValue(normalizedValue);
    }, [content]);

    const updateValue = (newValue) => {
        const sanitizedValue = Math.min(1, Math.max(0, newValue));
        const min = options.min || 0;
        const max = options.max || 1;
        const value = min + sanitizedValue * (max - min);
        const roundedValue = Math.round(value * 100) / 100;
        setContent(roundedValue);
    };

    return &lt;>
        &lt;input className="button-slider" type="range" min="0" max="1" step="0.01" value={value}
            onChange={(e) => updateValue(parseFloat(e.target.value))}
            style={{
                right: "-96px",
                top: "50%",
                transform: `translate(50%, -50%)`
            }} />
    &lt;/>;
}

export function BooleanEditor() {
    const [content, setContent] = useProperty('content');

    return &lt;div className={`button ${content == 'true' ? 'active' : ''}`}
        style={{
            right: "-52px",
            top: "50%",
            transform: `translate(50%, -50%)`,
            backgroundColor: content == 'true' ? '' : '#aaa'
        }}
        onPointerDown={(e) => {
            stopEventPropagation(e);
            setContent(content == 'true' ? 'false' : 'true');
        }}>{content == 'true' ? 'True' : 'False'}&lt;/div>;
}

export function ColorEditor() {
    const [content, setContent] = useProperty('content');

    return &lt;>
        {VEGA_LITE_COLORS.map((color, index) => {
            const x = index % 5;
            const y = Math.floor(index / 5);
            return &lt;div className={`button ${content == color ? 'active' : ''}`}
                key={index}
                style={{
                    right: "-52px",
                    top: "50%",
                    transform: `translate(50%, -50%) translate(${x * 105}%, ${y * 105}%) translateY(-${Math.floor((VEGA_LITE_COLORS.length - 1) / 5) * 50}%)`,
                    backgroundColor: color
                }}
                onPointerDown={(e) => {
                    stopEventPropagation(e);
                    setContent(color);
                }}>&lt;/div>;
        })}
    &lt;/>;

};

export function FieldEditor() {
    const [enumOptions, setEnumOptions] = useState({ type: 'enum', enum: [] });

    useEffect(() => {
        const asyncCallback = async () => {
            const fields = await findAllFields();
            setEnumOptions({
                type: 'enum',
                enum: fields
            });
        };
        asyncCallback();
    }, []);

    return &lt;EnumEditor options={enumOptions} type="fieldEditor" />;
}

export function DatasetEditor() {
    const [content, setContent] = useProperty('content');

    const datasets = useMemo(() => getDatasetComponents(), []);

    return &lt;>
        {datasets.map((dataset, index) => {
            const x = index % 5;
            const y = Math.floor(index / 5);
            return &lt;div className={`button ${content == dataset.id ? 'active' : ''}`}
                key={index}
                style={{
                    right: "-52px",
                    top: "50%",
                    transform: `translate(50%, -50%) translate(${x * 105}%, ${y * 105}%) translateY(-${Math.floor((datasets.length - 1) / 5) * 50}%)`
                }}
                onPointerDown={(e) => {
                    stopEventPropagation(e);
                    setContent(dataset.id);
                }}>{dataset.name}&lt;/div>;
        })}
    &lt;/>;

}

const axisOptions = ['color', 'z', 'y', 'x'];
export function AxisEditor() {
    const [path, setPath] = useProperty('path');
    const [axis, setAxis] = useState();

    useEffect(() => {
        if (!path) return;
        if (path.startsWith('encoding.x')) setAxis('x');
        if (path.startsWith('encoding.y')) setAxis('y');
        if (path.startsWith('encoding.z')) setAxis('z');
        if (path.startsWith('encoding.color')) setAxis('color');
        if (path.startsWith('encoding.size')) setAxis('size');
    }, [path]);

    const callback = (option) => {
        setAxis(option);
        const newPath = path.replace(/encoding\.(x|y|z|color|size)/, 'encoding.' + option);
        setPath(newPath);
    };

    return &lt;>
        {axisOptions.map((option, index) => {
            const x = index % 5;
            const y = Math.floor(index / 5);
            return &lt;div className={`button ${axis == option ? 'active' : ''}`}
                key={index}
                style={{
                    left: "-52px",
                    top: "50%",
                    transform: `translate(-50%, -50%) translate(-${x * 105}%, ${y * 105}%)`
                }}
                onPointerDown={(e) => {
                    stopEventPropagation(e);
                    callback(option);
                }}>{option}&lt;/div>;
        })}
    &lt;/>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="vis-helpers" name="Vis-Helpers">import React from 'react';
let { useState, useEffect, useMemo } = React;
import { useGLTF, Outlines } from '@react-three/drei';
import { MeshStandardMaterial, Vector3, Vector2 } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useFrame } from '@react-three/fiber';
import { stopEventPropagation } from 'tldraw';
import { useProperty } from '#VarvReact';

import { Text } from '#Spatialstrates .text';
import { getSpaceManagerUUID, projectToCanvas } from '#Spatialstrates .projection-helpers';
import { createMovable } from '#Spatialstrates .movable-helpers';
import { moveMovableToNewSpace } from '#Container .container-helpers';
import { transcribeAudio, sendGPTPrompt, getGPTContent } from '#AIHelpers .default';
import { Icon, SELECTED_COLOR_PRIMARY, SELECTED_COLOR_SECONDARY, HOVERED_SELECTED_COLOR_PRIMARY, HOVERED_SELECTED_COLOR_SECONDARY } from '#Icon .default';

import { composeSpecFromGroup, decomposeSpec, integrateVisPiecesIntoGroup, findAllFields } from '#VisModule .vis-composer';
import { getVisComponentById } from '#VisModule .vis-component-manager';



export function useIsVisible() {
    const [group] = useProperty('group');
    const [visible, setVisible] = useState(false);

    useEffect(() => {
        setVisible(!(group && group != 'null'));
    }, [group]);

    return visible;
}

export const visThemes = {
    'bookshelf': { primary: 'hsl(200, 18%, 50%)', secondary: 'hsl(198, 16%, 84%)' },
    'bookshelf:hovered': { primary: 'hsl(200, 18%, 80%)', secondary: 'hsl(198, 16%, 84%)' },
    'bookshelf:selected': { primary: SELECTED_COLOR_PRIMARY, secondary: SELECTED_COLOR_SECONDARY },
    'bookshelf:selected:hovered': { primary: HOVERED_SELECTED_COLOR_PRIMARY, secondary: HOVERED_SELECTED_COLOR_SECONDARY },

    'visualization': { primary: 'hsl(262, 52%, 50%)', secondary: 'hsl(291, 96%, 62%)' },
    'visualization:hovered': { primary: 'hsl(262, 52%, 80%)', secondary: 'hsl(291, 96%, 82%)' },
    'visualization:selected': { primary: SELECTED_COLOR_PRIMARY, secondary: SELECTED_COLOR_SECONDARY },
    'visualization:selected:hovered': { primary: HOVERED_SELECTED_COLOR_PRIMARY, secondary: HOVERED_SELECTED_COLOR_SECONDARY },

    'vegaLite_2D': { primary: 'hsl(262, 52%, 50%)', secondary: 'hsl(291, 96%, 62%)' },
    'vegaLite_2D:hovered': { primary: 'hsl(262, 52%, 80%)', secondary: 'hsl(291, 96%, 82%)' },
    'vegaLite_25D': { primary: 'hsl(262, 52%, 50%)', secondary: 'hsl(291, 96%, 62%)' },
    'vegaLite_25D:hovered': { primary: 'hsl(262, 52%, 80%)', secondary: 'hsl(291, 96%, 82%)' },
    'optomancy': { primary: 'hsl(262, 52%, 50%)', secondary: 'hsl(291, 96%, 62%)' },
    'optomancy:hovered': { primary: 'hsl(262, 52%, 80%)', secondary: 'hsl(291, 96%, 82%)' },

    'spec': { primary: 'hsl(199, 100%, 50%)', secondary: 'hsl(198, 100%, 75%)', line: 'hsl(199, 100%, 50%)' },
    'spec:hovered': { primary: 'hsl(199, 100%, 80%)', secondary: 'hsl(198, 100%, 85%)' },
    'spec:selected': { primary: SELECTED_COLOR_PRIMARY, secondary: SELECTED_COLOR_SECONDARY },
    'spec:selected:hovered': { primary: HOVERED_SELECTED_COLOR_PRIMARY, secondary: HOVERED_SELECTED_COLOR_SECONDARY },
    'd3Spec': { primary: 'hsl(174, 65%, 50%)', secondary: 'hsl(166, 100%, 70%)', line: 'hsl(174, 65%, 50%)' },
    'd3Spec:hovered': { primary: 'hsl(174, 65%, 80%)', secondary: 'hsl(166, 100%, 80%)' },
    'd3Spec:selected': { primary: SELECTED_COLOR_PRIMARY, secondary: SELECTED_COLOR_SECONDARY },
    'd3Spec:selected:hovered': { primary: HOVERED_SELECTED_COLOR_PRIMARY, secondary: HOVERED_SELECTED_COLOR_SECONDARY },
    'dataset': { primary: 'hsl(88, 50%, 50%)', secondary: 'hsl(93, 100%, 50%)', line: 'hsl(88, 50%, 50%)' },
    'dataset:hovered': { primary: 'hsl(88, 50%, 80%)', secondary: 'hsl(93, 100%, 60%)' },
    'dataset:selected': { primary: SELECTED_COLOR_PRIMARY, secondary: SELECTED_COLOR_SECONDARY },
    'dataset:selected:hovered': { primary: HOVERED_SELECTED_COLOR_PRIMARY, secondary: HOVERED_SELECTED_COLOR_SECONDARY },
    'piece': { primary: 'hsl(45, 100%, 50%)', secondary: 'hsl(60, 100%, 50%)', line: 'hsl(45, 100%, 50%)' },
    'piece:hovered': { primary: 'hsl(45, 100%, 80%)', secondary: 'hsl(60, 100%, 60%)' },
    'piece:selected': { primary: SELECTED_COLOR_PRIMARY, secondary: SELECTED_COLOR_SECONDARY },
    'piece:selected:hovered': { primary: HOVERED_SELECTED_COLOR_PRIMARY, secondary: HOVERED_SELECTED_COLOR_SECONDARY }
};



export const metalnessValue = 0.5;
export const roughnessValue = 0.5;
export const visMaterials = {
    'bookshelf': new MeshStandardMaterial({ color: visThemes['bookshelf'].primary, metalness: metalnessValue, roughness: roughnessValue }),
    'bookshelf:hovered': new MeshStandardMaterial({ color: visThemes['bookshelf:hovered'].primary, metalness: metalnessValue, roughness: roughnessValue }),
    'visualizations': new MeshStandardMaterial({ color: visThemes['visualization'].primary, metalness: metalnessValue, roughness: roughnessValue }),
    'visualizations:hovered': new MeshStandardMaterial({ color: visThemes['visualization:hovered'].primary, metalness: metalnessValue, roughness: roughnessValue }),
    'spec': new MeshStandardMaterial({ color: visThemes['spec'].primary, metalness: metalnessValue, roughness: roughnessValue }),
    'spec:hovered': new MeshStandardMaterial({ color: visThemes['spec:hovered'].primary, metalness: metalnessValue, roughness: roughnessValue }),
    'd3Spec': new MeshStandardMaterial({ color: visThemes['d3Spec'].primary, metalness: metalnessValue, roughness: roughnessValue }),
    'd3Spec:hovered': new MeshStandardMaterial({ color: visThemes['d3Spec:hovered'].primary, metalness: metalnessValue, roughness: roughnessValue }),
    'dataset': new MeshStandardMaterial({ color: visThemes['dataset'].primary, metalness: metalnessValue, roughness: roughnessValue }),
    'dataset:hovered': new MeshStandardMaterial({ color: visThemes['dataset:hovered'].primary, metalness: metalnessValue, roughness: roughnessValue }),
    'piece': new MeshStandardMaterial({ color: visThemes['piece'].primary, metalness: metalnessValue, roughness: roughnessValue }),
    'piece:hovered': new MeshStandardMaterial({ color: visThemes['piece:hovered'].primary, metalness: metalnessValue, roughness: roughnessValue }),
    'piece:secondary': new MeshStandardMaterial({ color: visThemes['piece'].secondary, metalness: metalnessValue, roughness: roughnessValue }),
    'selectedPrimary': new MeshStandardMaterial({ color: SELECTED_COLOR_PRIMARY, metalness: metalnessValue, roughness: roughnessValue }),
    'selectedSecondary': new MeshStandardMaterial({ color: SELECTED_COLOR_SECONDARY, metalness: metalnessValue, roughness: roughnessValue })
};
export const frameGeometry = new RoundedBoxGeometry(1, 1, 0.005, 1);
export const frameMaterial = new MeshStandardMaterial({ color: 'hsl(200, 18%, 50%)', metalness: metalnessValue, roughness: roughnessValue });
export const frameMaterialDisabled = new MeshStandardMaterial({ color: 'hsl(200, 0%, 80%)', metalness: metalnessValue, roughness: roughnessValue });


export const getPieceTheme = (path) => {
    if (!path) return 'piece';
    if (path.startsWith('data')) {
        return 'dataset';
    } else if (path.startsWith('encoding')) {
        return 'visualization';
    } else if (path.startsWith('transform')) {
        return 'd3Spec';
    } else {
        return 'piece';
    }
};



export const visButtonGeometry = window.visButtonGeometry || new RoundedBoxGeometry(0.8, 0.4, 0.1);
window.visButtonGeometry = visButtonGeometry;
export function VisButton({ callback, position, rotation, scale, active, title, materialPrimary, materialHovered, outlineColor = '#4CAF50', fontSizeMultiplicator = 1 }) {
    const [hovered, setHovered] = useState(false);
    const hoverCallback = () => { setHovered(true); };
    const blurCallback = () => { setHovered(false); };

    const materialPrimaryInternal = useMemo(() => materialPrimary || visMaterials['spec'], [materialPrimary]);
    const materialHoveredInternal = useMemo(() => materialHovered || visMaterials['spec:hovered'], [materialHovered]);

    return &lt;group position={position} scale={scale} rotation={rotation} autoUpdateMatrix={false}>
        &lt;mesh geometry={visButtonGeometry}
            material={hovered ? materialHoveredInternal : materialPrimaryInternal}
            scale={[0.1, 0.1, 0.1]}
            autoUpdateMatrix={false}
            onPointerOver={hoverCallback}
            onPointerOut={blurCallback}
            onClick={() => callback()}>
            {active ? &lt;Outlines screenspace={true} thickness={0.05} color={outlineColor} opacity={0.8} transparent={true} /> : null}
        &lt;/mesh>
        {title ? &lt;Text position={[0, 0, 0.006]}
            autoUpdateMatrix={false}
            textAlign="center"
            anchorX="center"
            anchorY="middle"
            color="white"
            maxWidth={0.07}
            fontSize={fontSizeMultiplicator * 0.01}>
            {title.replace(/\b(\w{13})(?!\s|$)/g, '$1- ')}
        &lt;/Text> : null}
    &lt;/group>;
}

const booleanToggleGeometry = new RoundedBoxGeometry(0.03, 0.03, 0.01);
export function VisToggle({ value, setValue, invert, position, rotation, scale, callback }) {
    const actualValue = useMemo(() => invert ? !value : value, [value, invert]);
    return &lt;group position={position} rotation={rotation} scale={scale} autoUpdateMatrix={false}>
        &lt;VisButton callback={() => {
            setValue(!value);
            if (callback) callback(!value);
        }} />
        &lt;mesh geometry={booleanToggleGeometry}
            material={actualValue ? frameMaterial : frameMaterialDisabled}
            autoUpdateMatrix={false}
            position={[actualValue ? 0.02 : -0.022, 0, 0.005]}>
            &lt;Text
                position={[0, 0.012, 0.0075]}
                autoUpdateMatrix={false}
                textAlign="center"
                anchorX="center"
                anchorY="center"
                color="white"
                fontSize={0.02}>
                {actualValue ? 'I' : 'O'}
            &lt;/Text>
        &lt;/mesh>
    &lt;/group>;
}



/* LLM Speech-to-Vis Integration */

useGLTF.preload('microphone.glb');

function MicrophoneIcon({ callback, active }) {
    const microphoneIcon = useGLTF('microphone.glb');
    const [scale, setScale] = useState(new Vector3(0.5, 0.5, 0.5));

    useFrame((state, delta) => {
        const scaleSpeed = 3;
        const minScale = 0.4;
        const maxScale = 0.6;
        const targetScale = active ? minScale + (maxScale - minScale) * (Math.sin(state.clock.elapsedTime * 5) * 0.5 + 0.5) : 0.5;
        const newScale = scale.clone().lerp(new Vector3(targetScale, targetScale, targetScale), scaleSpeed * delta);
        setScale(newScale);
    });

    return &lt;Icon model={microphoneIcon} rotation={[0, -Math.PI, 0]} scale={scale} onClick={callback} />;
}

export function TranscribeIcon({ setValue, ...props }) {
    const [listening, setListening] = useState(false);

    const callback = async () => {
        setListening(true);
        let text = await transcribeAudio(5000, false, () => { setListening(false); });

        if (text[text.length - 1] === '.') {
            text = text.slice(0, -1);
        }
        text = text.replace(/\b\w/g, (char) => char.toUpperCase());

        setValue(text);
    };

    return &lt;group {...props} autoUpdateMatrix={false}>
        &lt;MicrophoneIcon callback={callback} active={listening} />
    &lt;/group>;
}

export function SpeechToVisPiece(props) {
    const [listening, setListening] = useState(false);
    const [path, setPath] = useProperty('path');
    const [content, setContent] = useProperty('content');

    const callback = async () => {
        setListening(true);
        const text = await transcribeAudio(5000, false, () => { setListening(false); });

        const fields = await findAllFields();

        const gptData = await sendGPTPrompt({
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: `You are an visualization assistant. You help users change their Vega-Lite specifications. You will receive a path to a key of a Vega-Lite property (e.g., 'mark.type') and its content (e.g., 'bar'). You change either the content or both the path and content according to the user request. If the content is normally in an array, like a 'transform', you have to wrap it in an array like this: transform: [{"filter": "datum.x > 5"}]. You always reply in the following JSON format: { "newPath": "your-new-path", "newContent": "your-new-content" }` },
                { role: 'user', content: `Here are the available fields: ${fields.join(', ')}` },
                { role: 'user', content: `My current path is "${path}" and content is "${content}".` },
                { role: 'user', content: text }
            ],
            temperature: 0.05,
            max_tokens: 1000,
            response_format: { 'type': 'json_object' }
        });

        const result = getGPTContent(gptData);

        try {
            const json = JSON.parse(result);
            if (json.hasOwnProperty('newPath')) setPath(json.newPath);
            if (json.hasOwnProperty('newContent')) {
                if (typeof json.newContent === 'object') {
                    setContent(JSON.stringify(json.newContent));
                } else {
                    setContent(json.newContent);
                }
            }
        } catch (e) {
            console.error('Error parsing GPT-4o response:', e);
        }
    };

    return &lt;group {...props} autoUpdateMatrix={false}>
        &lt;MicrophoneIcon callback={callback} active={listening} />
    &lt;/group>;
}

export function SpeechToVisGroup(props) {
    const [listening, setListening] = useState(false);
    const [conceptUUID] = useProperty('concept::uuid');

    const callback = async () => {
        setListening(true);
        const text = await transcribeAudio(5000, false, () => { setListening(false); });
        setListening(false);

        const spec = await composeSpecFromGroup(conceptUUID);

        let dataSchema = '';
        if (spec.hasOwnProperty('data')) {
            if (spec.data.hasOwnProperty('values')) {
                dataSchema = spec.data.values[0];
            } else if (spec.data.hasOwnProperty('url')) {
                const response = await fetch(spec.data.url);
                const values = await response.json();
                dataSchema = values[0];
            } else if (spec.data.hasOwnProperty('fragment')) {
                const fragment = spec.data.fragment;
                const component = getVisComponentById(fragment);
                if (component) {
                    dataSchema = component.getContentAsJSON()[0];
                }
            }
        }

        const gptData = await sendGPTPrompt({
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: `You are an visualization assistant. You help users change their Vega-Lite specifications. You will receive a Vega-Lite specification and change it according to the user request. You always reply in the following JSON format with the full Vega-Lite specification: { "newSpec": { "mark": "..." }}` },
                { role: 'user', content: `My current specification is "${JSON.stringify(spec)}".` },
                { role: "user", content: dataSchema ? `Here is an example datapoint of the data: ${JSON.stringify(dataSchema)}` : '' },
                { role: 'user', content: text }
            ],
            temperature: 0.05,
            max_tokens: 1000,
            response_format: { 'type': 'json_object' }
        });

        const result = getGPTContent(gptData);

        try {
            const json = JSON.parse(result);
            if (json.hasOwnProperty('newSpec')) {
                const newSpec = json.newSpec;
                const pieces = decomposeSpec(newSpec);
                await integrateVisPiecesIntoGroup(conceptUUID, pieces);
            }
        } catch (e) {
            console.error('Error parsing GPT-4o response:', e);
        }
    };

    return &lt;group {...props} autoUpdateMatrix={false}>
        &lt;MicrophoneIcon callback={callback} active={listening} />
    &lt;/group>;
}

export function SpeechToVisPiece2D(props) {
    const [listening, setListening] = useState(false);
    const [path, setPath] = useProperty('path');
    const [content, setContent] = useProperty('content');

    const callback = async (e) => {
        stopEventPropagation(e);
        setListening(true);
        const text = await transcribeAudio(5000, false, () => { setListening(false); });

        const fields = await findAllFields();

        const gptData = await sendGPTPrompt({
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: `You are an visualization assistant. You help users change their Vega-Lite specifications. You will receive a path to a key of a Vega-Lite property (e.g., 'mark.type') and its content (e.g., 'bar'). You change either the content or both the path and content according to the user request. If the content is normally in an array, like a 'transform', you have to wrap it in an array like this: transform: [{"filter": "datum.x > 5"}]. You always reply in the following JSON format: { "newPath": "your-new-path", "newContent": "your-new-content" }` },
                { role: 'user', content: `Here are the available fields: ${fields.join(', ')}` },
                { role: 'user', content: `My current path is "${path}" and content is "${content}".` },
                { role: 'user', content: text }
            ],
            temperature: 0.05,
            max_tokens: 1000,
            response_format: { 'type': 'json_object' }
        });

        const result = getGPTContent(gptData);

        try {
            const json = JSON.parse(result);
            if (json.hasOwnProperty('newPath')) setPath(json.newPath);
            if (json.hasOwnProperty('newContent')) {
                if (typeof json.newContent === 'object') {
                    setContent(JSON.stringify(json.newContent));
                } else {
                    setContent(json.newContent);
                }
            }
        } catch (e) {
            console.error('Error parsing GPT-4o response:', e);
        }
    };

    return &lt;div {...props} className={`speech-to-vis-piece-icon ${listening ? 'listening' : ''}`} onPointerDown={callback} />;
}

export function SpeechToVisGroup2D(props) {
    const [listening, setListening] = useState(false);
    const [conceptUUID] = useProperty('concept::uuid');

    const callback = async (e) => {
        stopEventPropagation(e);
        setListening(true);
        const text = await transcribeAudio(5000, false, () => { setListening(false); });
        setListening(false);

        const spec = await composeSpecFromGroup(conceptUUID);

        let dataSchema = '';
        if (spec.hasOwnProperty('data')) {
            if (spec.data.hasOwnProperty('values')) {
                dataSchema = spec.data.values[0];
            } else if (spec.data.hasOwnProperty('url')) {
                const response = await fetch(spec.data.url);
                const values = await response.json();
                dataSchema = values[0];
            } else if (spec.data.hasOwnProperty('fragment')) {
                const fragment = spec.data.fragment;
                const component = getVisComponentById(fragment);
                if (component) {
                    dataSchema = component.getContentAsJSON()[0];
                }
            }
        }

        const gptData = await sendGPTPrompt({
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: `You are an visualization assistant. You help users change their Vega-Lite specifications. You will receive a Vega-Lite specification and change it according to the user request. You always reply in the following JSON format with the full Vega-Lite specification: { "newSpec": { "mark": "..." }}` },
                { role: 'user', content: `My current specification is "${JSON.stringify(spec)}".` },
                { role: "user", content: dataSchema ? `Here is an example datapoint of the data: ${JSON.stringify(dataSchema)}` : '' },
                { role: 'user', content: text }
            ],
            temperature: 0.05,
            max_tokens: 1000,
            response_format: { 'type': 'json_object' }
        });

        const result = getGPTContent(gptData);

        try {
            const json = JSON.parse(result);
            if (json.hasOwnProperty('newSpec')) {
                const newSpec = json.newSpec;
                const pieces = decomposeSpec(newSpec);
                await integrateVisPiecesIntoGroup(conceptUUID, pieces);
            }
        } catch (e) {
            console.error('Error parsing GPT-4o response:', e);
        }
    };

    return &lt;div {...props} className={`speech-to-vis-group-icon ${listening ? 'listening' : ''}`} onPointerDown={callback} />;
}



const MAX_DISTANCE_GROUPING = 0.125;

const dragEndGroupingFilter = FilterAction.constructFilter({
    and: [
        {
            property: 'locked',
            equals: false
        },
        {
            property: 'group',
            equals: ''
        }
    ]
});
const is2D = async () => {
    const spaceManagerUUID = await getSpaceManagerUUID();
    const currentView = await VarvEngine.getConceptFromType('SpaceManager').getPropertyValue(spaceManagerUUID, 'currentView');

    return currentView === '2D';
};
const getPositionVector = async (uuid) => {
    // FIXME: This might be bad for performance:
    if (await is2D()) {
        const concept = await VarvEngine.getConceptFromUUID(uuid);
        const position = await concept.getPropertyValue(uuid, 'position');

        const spaceUUID = await concept.getPropertyValue(uuid, 'space');
        const projectionPlane = await VarvEngine.getConceptFromType('Space').getPropertyValue(spaceUUID, 'projectionPlane');
        const position2D = await projectToCanvas(position, projectionPlane);
        return new Vector2(...position2D);
    } else {
        const concept = await VarvEngine.getConceptFromUUID(uuid);
        const position = await concept.getPropertyValue(uuid, 'position');
        return new Vector3(...position);
    }
};
export const onDragEndGroupingCallback = async (ownUUID) => {
    const ownConcept = await VarvEngine.getConceptFromUUID(ownUUID);
    const ownPositionVector = await getPositionVector(ownUUID);

    const visMovableUUIDs = await VarvEngine.lookupInstances(['VisPiece', 'VisGroup'], dragEndGroupingFilter);
    const otherUUIDs = visMovableUUIDs.filter(uuid => uuid !== ownUUID);

    const otherPositions = await Promise.all(otherUUIDs.map(async (uuid) => {
        return {
            uuid: uuid,
            positionVector: await getPositionVector(uuid)
        };
    }));

    const movablesWithinDistance = otherPositions.map(otherPosition => {
        return { uuid: otherPosition.uuid, distance: ownPositionVector.distanceTo(otherPosition.positionVector) };
    }).filter(otherPosition => otherPosition.distance &lt; MAX_DISTANCE_GROUPING);

    if (movablesWithinDistance.length > 0) {
        const closestUUID = movablesWithinDistance.sort((a, b) => a.distance - b.distance)[0].uuid;
        const closestConcept = await VarvEngine.getConceptFromUUID(closestUUID);

        if (closestConcept.name == 'VisPiece') {
            const newVisGroupUUID = await createMovable('VisGroup', {
                pieces: [closestUUID, ownUUID],
                position: await closestConcept.getPropertyValue(closestUUID, 'position'),
                rotation: await closestConcept.getPropertyValue(closestUUID, 'rotation')
            });

            await closestConcept.setPropertyValue(closestUUID, 'group', newVisGroupUUID);
            await closestConcept.setPropertyValue(closestUUID, 'disabled', false);
            await moveMovableToNewSpace(closestUUID, '');

            await ownConcept.setPropertyValue(ownUUID, 'group', newVisGroupUUID);
        } else if (closestConcept.name == 'VisGroup') {
            await closestConcept.setPropertyValue(closestUUID, 'pieces', [...await closestConcept.getPropertyValue(closestUUID, 'pieces'), ownUUID]);
            await ownConcept.setPropertyValue(ownUUID, 'group', closestUUID);
        }

        await ownConcept.setPropertyValue(ownUUID, 'disabled', false);
        await moveMovableToNewSpace(ownUUID, '');
    }
};

const dragEndResetHighlightFilter = FilterAction.constructFilter({
    property: 'dropHighlight',
    equals: true
});
export const onDragEndResetGroupingHighlight = async () => {
    const visMovableUUIDs = await VarvEngine.lookupInstances(['VisPiece', 'VisGroup'], dragEndResetHighlightFilter);
    await Promise.all(visMovableUUIDs.map(uuid => {
        const concept = VarvEngine.getConceptFromUUID(uuid);
        concept.setPropertyValue(uuid, 'dropHighlight', false);
    }));
};

export const onDraggingUpdateGroupingHighlight = async (ownUUID) => {
    await onDragEndResetGroupingHighlight();
    const ownPositionVector = await getPositionVector(ownUUID);

    const visMovableUUIDs = await VarvEngine.lookupInstances(['VisPiece', 'VisGroup'], dragEndGroupingFilter);
    const otherUUIDs = visMovableUUIDs.filter(uuid => uuid !== ownUUID);

    const otherPositions = await Promise.all(otherUUIDs.map(async (uuid) => {
        return {
            uuid: uuid,
            positionVector: await getPositionVector(uuid)
        };
    }));

    const movablesWithinDistance = otherPositions.map(otherPosition => {
        return { uuid: otherPosition.uuid, distance: ownPositionVector.distanceTo(otherPosition.positionVector) };
    }).filter(otherPosition => otherPosition.distance &lt; MAX_DISTANCE_GROUPING);

    if (movablesWithinDistance.length > 0) {
        const closestUUID = movablesWithinDistance.sort((a, b) => a.distance - b.distance)[0].uuid;
        const closestConcept = await VarvEngine.getConceptFromUUID(closestUUID);

        await closestConcept.setPropertyValue(closestUUID, 'dropHighlight', true);
    }
};



const PROXIMITY_AUTHORING_DISTANCE = 0.75;

const updateProximityPiecesOfGroup = async (groupUUID) => {
    const groupConcept = await VarvEngine.getConceptFromType('VisGroup');
    const groupProximityAuthoring = await groupConcept.getPropertyValue(groupUUID, 'proximityAuthoring');

    if (!groupProximityAuthoring) {
        groupConcept.setPropertyValue(groupUUID, 'proximityPieces', []);
        return;
    }

    const ownPositionVector = await getPositionVector(groupUUID);

    const spaceOfGroup = await groupConcept.getPropertyValue(groupUUID, 'space');
    const visMovableUUIDs = await VarvEngine.lookupInstances(['VisPiece', 'VisGroup'], FilterAction.constructFilter({
        and: [
            {
                property: 'group',
                equals: ''
            },
            {
                property: 'space',
                equals: spaceOfGroup
            }
        ]
    }));
    const otherUUIDs = visMovableUUIDs.filter(uuid => uuid !== groupUUID);

    const otherPositions = await Promise.all(otherUUIDs.map(async (uuid) => {
        return {
            uuid: uuid,
            positionVector: await getPositionVector(uuid)
        };
    }));

    const movablesWithinDistance = otherPositions.map(otherPosition => {
        return { uuid: otherPosition.uuid, distance: ownPositionVector.distanceTo(otherPosition.positionVector) };
    }).filter(otherPosition => otherPosition.distance &lt; PROXIMITY_AUTHORING_DISTANCE);

    groupConcept.setPropertyValue(groupUUID, 'proximityPieces', movablesWithinDistance.map(movable => movable.uuid));
};

const checkIfMovableIsInProximity = async (groupUUID, movableUUID, movableSpace) => {
    const groupPositionVector = await getPositionVector(groupUUID);
    const movablePositionVector = await getPositionVector(movableUUID);

    const groupConcept = await VarvEngine.getConceptFromUUID(groupUUID);
    const groupSpace = await groupConcept.getPropertyValue(groupUUID, 'space');
    const groupProximityPieces = await groupConcept.getPropertyValue(groupUUID, 'proximityPieces');
    if (movableSpace != groupSpace
        || groupPositionVector.distanceTo(movablePositionVector) > PROXIMITY_AUTHORING_DISTANCE) {
        await groupConcept.setPropertyValue(groupUUID, 'proximityPieces', groupProximityPieces.filter(uuid => uuid !== movableUUID));
    } else if (!groupProximityPieces.includes(movableUUID)) {
        await groupConcept.setPropertyValue(groupUUID, 'proximityPieces', [...groupProximityPieces, movableUUID]);
    }
};

export const onDraggingUpdateProximityAuthoring = async (ownUUID) => {
    const ownConcept = await VarvEngine.getConceptFromUUID(ownUUID);

    // Check if own pieces need to be updated
    if (ownConcept.name == 'VisGroup') {
        await updateProximityPiecesOfGroup(ownUUID);
    }

    // Update other groups that have proximity authoring enabled
    const proximityAuthoringGroupUUIDs = await VarvEngine.lookupInstances(['VisGroup'], FilterAction.constructFilter({
        and: [
            {
                property: 'locked',
                equals: false
            },
            {
                property: 'group',
                equals: ''
            },
            {
                property: 'proximityAuthoring',
                equals: true
            }
        ]
    }));
    const ownSpace = await ownConcept.getPropertyValue(ownUUID, 'space');
    await Promise.all(proximityAuthoringGroupUUIDs.filter(uuid => uuid !== ownUUID).map(async (groupUUID) => {
        await checkIfMovableIsInProximity(groupUUID, ownUUID, ownSpace);
    }));
};

export function useUpdateProximityAuthoringOnSpaceChange() {
    const [conceptUUID] = useProperty('concept::uuid');
    const [space] = useProperty('space');

    useEffect(() => {
        if (!conceptUUID) return;
        onDraggingUpdateProximityAuthoring(conceptUUID);
    }, [conceptUUID, space]);
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Vis-Piece Styles" auto>@mixin heading-font {
    font-weight: 500;
    font-size: 13px;
    letter-spacing: 0.25px;
}

.vis-piece-shape,
.vis-group-shape {
    border-radius: 8px;

    .button {
        width: 40px;
        height: 18px;
        line-height: 8px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        position: absolute;
        @include heading-font;
        font-size: 4px;
        white-space: nowrap;
        color: #fff;
        background: hsl(212, 93%, 21%);
        border-radius: 4px;
        padding: 4px;
        cursor: pointer;
        text-align: center;
        gap: 4px;
        pointer-events: all;
        border: 1px solid hsl(203, 100%, 35%);

        &.active {
            border-color: #4CAF50;
        }

        &:hover {
            background: hsl(212, 93%, 25%);
        }
    }

    .dataset-display,
    .spec-display {
        font-size: 6px;
        font-family: monospace;
        text-overflow: ellipsis;
        overflow: auto;
        white-space: pre-wrap;
        pointer-events: all;

        padding: 6px;
        position: absolute;
        background: rgb(43, 64, 80);
        color: #fff;
        border-radius: 4px;
        user-select: text;
        cursor: text;
    }

    .speech-to-vis-piece-icon,
    .speech-to-vis-group-icon {
        width: 17px;
        height: 17px;
        background: #ccc;
        color: #000;
        border-radius: 2px;
        position: absolute;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 14px;
        pointer-events: all;

        &:hover {
            background: #ddd;
        }

        &:after {
            font-family: 'Material Icons';
            content: 'mic';
        }

        &.listening {
            background: #4CAF50;
            color: #fff;

            &:after {
                animation: pulse 1.5s infinite;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
            }
        }
    }

    .speech-to-vis-piece-icon {
        bottom: -8px;
        left: -8px;
        transform: translate(-100%, 100%);
    }

    .speech-to-vis-group-icon {
        bottom: -8px;
        left: 12px;
        transform: translate(-50%, 100%);
    }
}

.vis-piece-shape {
    background-color: #fff;
    border: 1.5px solid #000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 4px;
    padding: 4px;

    .button-slider {
        position: absolute;
        appearance: none;
        border-radius: 4px;
        background: hsl(212, 93%, 21%);
        width: 128px;
        height: 8px;
        margin: 0;

        &::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: hsl(203, 100%, 35%);
            cursor: pointer;
        }
    }

    .lock-button {
        bottom: -8px;
        left: 50%;
        transform: translate(-50%, 100%);
    }

    .dataset-button {
        top: -8px;
        left: 50%;
        transform: translate(-50%, -100%);
    }

    .edit-value-button {
        right: -8px;
        top: 50%;
        transform: translate(50%, -50%) rotate(-90deg) translate(0, 50%);
    }

    .edit-axis-button {
        left: -8px;
        top: 50%;
        transform: translate(-50%, -50%) rotate(90deg) translate(0, 50%);
    }

    .path,
    .content {
        font-family: monospace;
        text-overflow: ellipsis;
        overflow: hidden;
        font-size: 6px;
        width: 100%;
        text-align: center;
        resize: none;
        padding: 1px;
    }

    .dataset-display {
        top: -32px;
        left: 50%;
        transform: translate(-50%, -100%);
    }

    &.theme-dataset {
        color: #000;
    }

    &.theme-visualization {
        color: #fff;
    }

    &.theme-transform {
        color: #000;
    }

    &.theme-piece {
        color: #000;
    }
}

.vis-group-shape {
    background-color: rgb(58, 83, 103);
    border: 4px solid rgb(157, 107, 10);
    color: #fff;
    gap: 8px;
    padding: 8px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;

    &.locked {
        border-radius: 50%;
        border-color: transparent;
        background: transparent;

        &:before {
            font-family: 'Material Icons';
            color: rgb(157, 107, 10);
            content: 'description';
            text-align: center;
            font-size: 96px;
            line-height: 158px;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            border: 8px solid hsl(40, 88%, 33%);
            background-color: hsl(40, 88%, 60%);
        }

        .group-name {
            color: #000;
            font-size: 14px;
            position: absolute;
            top: -2px;
            left: 50%;
            transform: translate(-50%, -100%);
        }
    }

    .group-title {
        display: flex;
        flex-direction: row;
        gap: 4px;
        width: 100%;

        .group-title-icon {
            width: 16px;
            height: 16px;
        }

        .group-name {
            text-align: left;
            flex-grow: 1;
            font-size: 12px;
        }

        input {
            width: 100%;
            text-align: left;
            font-size: 10px;
            padding: 0;
        }
    }

    .visualization-display {
        background: #ddd;
        color: #000;
        position: absolute;
        padding: 4px;
        border-radius: 4px;
        top: -32px;
        left: 50%;
        transform: translate(-50%, -100%);
        overflow: hidden;

        .vega-embed {
            width: 100%;
            height: 100%;
            background-color: #fff;
            border-radius: 2.5px;
        }

        canvas {
            border-radius: 2.5px;
        }
    }

    .spec-display {
        left: -32px;
        top: 50%;
        transform: translate(-100%, -50%);
    }

    .lock-button {
        bottom: -8px;
        left: 50%;
        transform: translate(-50%, 100%);
    }

    .visualization-button {
        top: -8px;
        left: 50%;
        transform: translate(-50%, -100%);
    }

    .proximity-authoring-button {
        right: -8px;
        top: 50%;
        transform: translate(50%, -50%) rotate(-90deg) translate(0, 50%);
    }

    .spec-button {
        left: -8px;
        top: 50%;
        transform: translate(-50%, -50%) rotate(90deg) translate(0, 50%);
    }

    .pieces-list {
        display: flex;
        flex-direction: column-reverse;
        gap: 4px;
        overflow: auto;
        width: 100%;
        flex-grow: 1;
        justify-content: flex-end;

        .vis-piece-dummy {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 4px;

            .vis-piece-dummy-icon {
                width: 12px;
                height: 12px;
                border-radius: 2px;
                background: #fff;
                border: 1px solid #000;
            }

            .vis-piece-dummy-title {
                font-size: 7px;
                text-align: left;
                flex-grow: 1;
            }

            .dummy-disable-toggle {
                width: 24px;
                height: 12px;
                border-radius: 4px;
                border: 1px solid hsl(203, 100%, 35%);
                background: hsl(212, 93%, 21%);
                cursor: pointer;
                position: relative;
                transition: all 0.3s ease;

                &:before {
                    content: '';
                    position: absolute;
                    top: 1px;
                    left: calc(100% - 9px);
                    width: 8px;
                    height: 8px;
                    border-radius: 2.5px;
                    background: #ddd;
                    transition: all 0.3s ease;
                }
            }

            &.overwritten {
                .vis-piece-dummy-title {
                    color: #999;
                }
            }

            &.disabled {
                .vis-piece-dummy-title {
                    color: #f00;
                }

                .dummy-disable-toggle {
                    background: hsl(212, 93%, 15%);

                    &:before {
                        left: calc(100% - 9px);
                        background: #888;
                        left: 1px;
                    }
                }
            }
        }
    }

    .group-pagination {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        gap: 4px;
        width: 100%;

        .button {
            position: relative;
            font-size: 5px;
        }

        .pagination-text {
            font-size: 8px;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="VisShelf" id="VisShelf"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A bookshelf component to instantiate groups and pieces.",
    "dependencies": [
        "#Visualization",
        "#VisModule",
        "#Icon",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [
        "bookshelf.glb"
    ],
    "version": "0.2.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Vis-Shelf Concepts" auto> {
    "concepts": {
        "VisShelf": {
            "schema": {
                "type": { "string": {
                    "enums": [ "spec", "dataset", "piece" ],
                    "default": "spec"
                }}
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Vis-Shelf Component" class="default">import React from 'react';
const { useState, useEffect, useRef, useMemo, useCallback } = React;
import { Color, Object3D, Matrix4, MeshStandardMaterial, InstancedMesh } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useGLTF } from '@react-three/drei';
import { useProperty } from '#VarvReact';

import { useGlobalEvents } from '#Spatialstrates .global-events';
import { createMovable } from '#Spatialstrates .movable-helpers';
import { Movable } from '#Spatialstrates .movable';
import { Text } from '#Spatialstrates .text';
import { Icon } from '#Icon .default';

import {
    getSpecComponents,
    getDatasetComponents,
    addVisComponentAddedListener,
    removeVisComponentAddedListener,
    addVisComponentRemovedListener,
    removeVisComponentRemovedListener
} from '#VisModule .vis-component-manager';
import {
    getDefaultVisPiecesLibrary
} from '#VisModule .vis-helpers';
import {
    createVarvVisPieces,
    decomposeComponent
} from '#VisModule .vis-composer';
import { visThemes, visMaterials, getPieceTheme } from '#VisPiece .vis-helpers';

const DEBUG = false;



const defaultShelfMaterial = new MeshStandardMaterial({ metalness: 0.7, roughness: 0.3 });
const defaultGraphBoxGeometry = new RoundedBoxGeometry();
const defaultShelfBoxGeometry = new RoundedBoxGeometry(1, 1, 1, 10);
const defaultShelfColor = visThemes['bookshelf'].primary;

const SHELF_WIDTH = 0.5;
const SHELF_HEIGHT = 0.5;
const SHELF_BOARD_THICKNESS = 0.01;
const SHELF_DEPTH = 0.1;



const generateDummies = (columns, rows, shelfComponents, setTempTitle) => {
    const dummies = [];

    for (let i = 0; i &lt; shelfComponents.length; i++) {
        const component = shelfComponents[i];
        const x = i % columns;
        const y = Math.floor(i / columns);
        const scale = Math.min(1.2 / columns, 0.8);
        dummies.push(&lt;VisComponentDummy
            component={component}
            key={i}
            position={[(x + 0.5) * SHELF_WIDTH / columns, ((rows - y - 0.5) * SHELF_HEIGHT / rows) - 0.05 * scale, 0]}
            scale={[scale, scale, scale]}
            setTempTitle={setTempTitle}
        />);
    }

    return dummies;
};

useGLTF.preload('components_specs.glb');
useGLTF.preload('components_snippets.glb');

function VisComponentDummy({ component, position, scale, setTempTitle }) {
    const specIcon = useGLTF('components_specs.glb');
    const d3SpecIcon = useGLTF('components_snippets.glb');
    const datasetIcon = useGLTF('components_snippets.glb');
    const pieceIcon = useGLTF('components_snippets.glb');
    const visualizationIcon = useGLTF('components_snippets.glb');
    const [type, setType] = useState('');
    const iconModel = useMemo(() => {
        switch (type) {
            case 'spec': return specIcon;
            case 'd3Spec': return d3SpecIcon;
            case 'dataset': return datasetIcon;
            case 'piece': return pieceIcon;
            case 'visualization': return visualizationIcon;
            default: return null;
        }
    }, [type]);
    const [title, setTitle] = useState('');
    const meshRef = useRef();
    const visPieceConcept = VarvEngine.getConceptFromType('VisPiece');

    useEffect(() => {
        if (component.constructor.name === 'VisComponent') {
            setType(component.type);
            setTitle(component.name);
            component.addNameChangedListener(setTitle);
        } else if (component.constructor.name === 'VisPiece') {
            setType(getPieceTheme(component.path));
            setTitle(`${component.path}:${component.content}`);
        } else {
            setType('');
            setTitle('');
        }
        return () => {
            if (component.constructor.name === 'VisComponent') {
                component.removeNameChangedListener(setTitle);
            }
        }
    }, [component]);

    const { triggerEvent } = useGlobalEvents();

    const selectStartHandler = useCallback(async (e) => {
        if (e) e.stopPropagation();
        const position = [meshRef.current.matrixWorld.elements[12], meshRef.current.matrixWorld.elements[13], meshRef.current.matrixWorld.elements[14]];

        let newMovable;

        if (component.constructor.name === 'VisComponent') {
            const pieces = decomposeComponent(component);

            if (pieces.length === 1) {
                newMovable = await createMovable('VisPiece', {
                    path: pieces[0].path,
                    content: pieces[0].content,
                    position: position
                });
            } else {
                const pieceUUIDs = await createVarvVisPieces(pieces);

                newMovable = await createMovable('VisGroup', {
                    name: component.name,
                    pieces: pieceUUIDs,
                    position: position
                });

                for (let pieceUUID of pieceUUIDs) {
                    visPieceConcept.setPropertyValue(pieceUUID, 'group', newMovable);
                }
            }
        } else if (component.constructor.name === 'VisPiece') {
            newMovable = await createMovable('VisPiece', {
                path: component.path,
                content: component.content,
                position: position
            });
        } else {
            console.error('Unknown component type');
        }

        setTimeout(() => {
            triggerEvent('initiate-drag', { target: newMovable, e: e });
        }, 100); // HACK: This is a bit brittle
    }, [triggerEvent, component]);

    const [hovered, setHovered] = useState(false);
    const hoverCallback = () => {
        setTempTitle(title);
        setHovered(true);
    };
    const blurCallback = () => {
        setTempTitle('');
        setHovered(false);
    };

    const icon = useMemo(() => &lt;Icon theme={type + (hovered ? ':hovered' : '')} model={iconModel} themesOverride={visThemes} />, [type, hovered]);

    return &lt;group position={position} scale={scale} autoUpdateMatrix={false}>
        &lt;group ref={meshRef}
            autoUpdateMatrix={false}
            onPointerOver={hoverCallback}
            onPointerOut={blurCallback}
            onPointerDown={selectStartHandler}>
            {icon}
        &lt;/group>
        &lt;Text position={[0, 0.1, 0]} autoUpdateMatrix={false}
            textAlign="center"
            anchorX="center"
            anchorY="middle"
            color="white"
            fontSize={0.03}>
            {title.length > 15 ? title.slice(0, 15) + '...' : title}
        &lt;/Text>
    &lt;/group>;
}

function ShelfTypeSelector({ shelfType, position }) {
    const [type, setType] = useProperty('type');

    const [hovered, setHovered] = useState(false);
    const hoverCallback = () => {
        setHovered(true);
    };
    const blurCallback = () => {
        setHovered(false);
    };

    return &lt;mesh geometry={defaultGraphBoxGeometry}
        material={hovered ? visMaterials[shelfType + ':hovered'] : visMaterials[shelfType]}
        scale={type == shelfType ? [0.06, 0.06, 0.06] : [0.05, 0.05, 0.05]}
        position={position}
        onPointerOver={hoverCallback}
        onPointerOut={blurCallback}
        onClick={() => setType(shelfType)}>
    &lt;/mesh>;
}

function HandleIcon({ model, theme = '', themesOverride = '' }) {
    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');
    return &lt;Icon theme={theme + (selected ? ':selected' : '') + (hovered ? ':hovered' : '')} model={model} themesOverride={themesOverride} />
}

useGLTF.preload('bookshelf.glb');

const matrixProvider = new Object3D();
function VisShelf() {
    const bookshelfIcon = useGLTF('bookshelf.glb');
    const [type] = useProperty('type');
    const [dummies, setDummies] = useState([]);

    const [tempTitle, setTempTitle] = useState('');

    const maxMeshes = 50;
    const boxRefs = useMemo(() => {
        const instancer = new InstancedMesh(defaultShelfBoxGeometry, defaultShelfMaterial, maxMeshes);
        // Clean up matrices to avoid flicker on initial grow
        const m = new Matrix4();
        m.set(0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0);
        for (let i = 0; i &lt; maxMeshes; i++) {
            instancer.setMatrixAt(i, m);
        }
        return instancer;
    }, []);

    const updateShelves = (columns, rows) => {
        if (!boxRefs) return;
        let count = 0;
        for (let i = 1; i &lt; columns; i++) {
            matrixProvider.position.set(i * SHELF_WIDTH / columns, 0.5 * SHELF_HEIGHT - 0.5 * SHELF_BOARD_THICKNESS, 0);
            matrixProvider.scale.set(SHELF_BOARD_THICKNESS, SHELF_HEIGHT + SHELF_BOARD_THICKNESS, SHELF_DEPTH * 0.95);
            matrixProvider.updateMatrix();
            boxRefs.setMatrixAt(count, matrixProvider.matrix)
            boxRefs.setColorAt(count, new Color(defaultShelfColor));
            count++;
        };
        for (let i = 1; i &lt; rows; i++) {
            matrixProvider.position.set(0.5 * SHELF_WIDTH, i * SHELF_HEIGHT / rows, 0);
            matrixProvider.scale.set(SHELF_WIDTH + SHELF_BOARD_THICKNESS, SHELF_BOARD_THICKNESS, SHELF_DEPTH * 0.9);
            matrixProvider.updateMatrix();
            boxRefs.setMatrixAt(count, matrixProvider.matrix)
            boxRefs.setColorAt(count, new Color(defaultShelfColor));
            count++;
        };

        boxRefs.instanceMatrix.needsUpdate = true;
        if (boxRefs.instanceColor) boxRefs.instanceColor.needsUpdate = true;
        boxRefs.count = count;
    };

    const updateShelfComponents = () => {
        let shelfComponents = [];
        switch (type) {
            case 'spec':
                shelfComponents = getSpecComponents();
                break;
            case 'dataset':
                shelfComponents = getDatasetComponents();
                break;
            case 'piece':
                shelfComponents = getDefaultVisPiecesLibrary();
                break;
            default:
                if (DEBUG) console.log('Unknown VisShelf type: ' + type);
        }

        const rows = Math.max(Math.ceil(Math.sqrt(shelfComponents.length)), 2);
        const columns = Math.max(Math.ceil(shelfComponents.length / rows), 2);
        updateShelves(columns, rows);
        setDummies(generateDummies(columns, rows, shelfComponents, setTempTitle));
    };

    useEffect(() => {
        updateShelfComponents();

        addVisComponentAddedListener(updateShelfComponents);
        addVisComponentRemovedListener(updateShelfComponents);
        return () => {
            removeVisComponentAddedListener(updateShelfComponents);
            removeVisComponentRemovedListener(updateShelfComponents);
        };
    }, [type]);

    const handle = useMemo(() => &lt;group position={[0, -0.5 * SHELF_HEIGHT, 0]}>
        &lt;HandleIcon theme="bookshelf" model={bookshelfIcon} themesOverride={visThemes} />
        &lt;mesh geometry={new RoundedBoxGeometry(1.02 * SHELF_WIDTH, 1.02 * SHELF_HEIGHT, SHELF_BOARD_THICKNESS, 10)} material={visMaterials['bookshelf:hovered']} position={[0, 0.52 * SHELF_HEIGHT, -0.45 * SHELF_DEPTH]} />
    &lt;/group>, []);

    const title = useMemo(() => {
        switch (type) {
            case 'spec': return 'Specs';
            case 'dataset': return 'Datasets';
            case 'piece': return 'Pieces';
            default: return 'Unknown';
        }
    }, [type]);

    return &lt;Movable handle={handle}>
        &lt;group position={[-0.5 * SHELF_WIDTH, (SHELF_BOARD_THICKNESS * 1.5) - (0.5 * SHELF_HEIGHT), 0]}>
            &lt;Text position={[0.5 * SHELF_WIDTH, SHELF_HEIGHT + 0.1, 0]}
                autoUpdateMatrix={false}
                maxWidth={SHELF_WIDTH}
                textAlign="center"
                anchorX="center"
                anchorY="bottom"
                color="black"
                outlineWidth="5%"
                outlineColor="white"
                fontSize={0.03}>
                {tempTitle ? tempTitle : title}
            &lt;/Text>

            &lt;ShelfTypeSelector shelfType='spec' position={[0.25 * SHELF_WIDTH, SHELF_HEIGHT + 0.05, 0]} />
            &lt;ShelfTypeSelector shelfType='dataset' position={[0.5 * SHELF_WIDTH, SHELF_HEIGHT + 0.05, 0]} />
            &lt;ShelfTypeSelector shelfType='piece' position={[0.75 * SHELF_WIDTH, SHELF_HEIGHT + 0.05, 0]} />

            &lt;primitive object={boxRefs} />
            {dummies}
        &lt;/group>
    &lt;/Movable>;
}

export function Main() {
    const [conceptType] = useProperty('concept::name');
    return conceptType === 'VisShelf' ? &lt;VisShelf /> : null;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Vis-Shelf Shape" class="dynamic-shape-component">import React from 'react';
const { useState, useEffect, useMemo, useCallback } = React;
import { HTMLContainer, stopEventPropagation } from 'tldraw';
import { useProperty } from '#VarvReact';

import { useGlobalEvents } from '#Spatialstrates .global-events';
import { MovableShapeUtil, MovableVarvScope } from '#Spatialstrates .movable-shape';
import { createMovable } from '#Spatialstrates .movable-helpers';
import { CANVAS_SCALE } from '#Spatialstrates .projection-helpers';

import { getDefaultVisPiecesLibrary } from '#VisModule .vis-helpers';
import { createVarvVisPieces, decomposeComponent } from '#VisModule .vis-composer';
import {
    getSpecComponents,
    getDatasetComponents,
    addVisComponentAddedListener,
    removeVisComponentAddedListener,
    addVisComponentRemovedListener,
    removeVisComponentRemovedListener
} from '#VisModule .vis-component-manager';
import { visThemes, getPieceTheme } from '#VisPiece .vis-helpers';



const DEBUG = false;

const generateDummies = (shelfComponents, setTempTitle) => {
    const dummies = [];

    for (let i = 0; i &lt; shelfComponents.length; i++) {
        const component = shelfComponents[i];
        dummies.push(&lt;VisComponentDummy
            component={component}
            key={i}
            setTempTitle={setTempTitle}
        />);
    }

    return dummies;
};

function VisComponentDummy({ component, setTempTitle }) {
    const [type, setType] = useState('');
    const [title, setTitle] = useState('');
    const [position] = useProperty('position');
    const visPieceConcept = VarvEngine.getConceptFromType('VisPiece');

    useEffect(() => {
        if (component.constructor.name === 'VisComponent') {
            setType(component.type);
            setTitle(component.name);
            component.addNameChangedListener(setTitle);
        } else if (component.constructor.name === 'VisPiece') {
            setType(getPieceTheme(component.path));
            setTitle(`${component.path}:${component.content}`);
        } else {
            setType('');
            setTitle('');
        }
        return () => {
            if (component.constructor.name === 'VisComponent') {
                component.removeNameChangedListener(setTitle);
            }
        }
    }, [component]);

    const { triggerEvent } = useGlobalEvents();

    const selectStartHandler = useCallback(async (e) => {
        stopEventPropagation(e);

        let newMovable;

        if (component.constructor.name === 'VisComponent') {
            const pieces = decomposeComponent(component);

            if (pieces.length === 1) {
                newMovable = await createMovable('VisPiece', {
                    path: pieces[0].path,
                    content: pieces[0].content,
                    position: position
                });
            } else {
                const pieceUUIDs = await createVarvVisPieces(pieces);

                newMovable = await createMovable('VisGroup', {
                    name: component.name,
                    pieces: pieceUUIDs,
                    position: position
                });

                for (let pieceUUID of pieceUUIDs) {
                    visPieceConcept.setPropertyValue(pieceUUID, 'group', newMovable);
                }
            }
        } else if (component.constructor.name === 'VisPiece') {
            newMovable = await createMovable('VisPiece', {
                path: component.path,
                content: component.content,
                position: position
            });
        } else {
            console.error('Unknown component type');
        }
    }, [triggerEvent, component, position]);

    const hoverCallback = (e) => {
        setTempTitle(title);
    };
    const blurCallback = (e) => {
        setTempTitle('');
    };

    return &lt;div className={`vis-component-dummy ${type}`}
        onPointerOver={hoverCallback}
        onPointerOut={blurCallback}
        onPointerDown={selectStartHandler}
        style={{
            backgroundColor: visThemes[type]?.primary,
            borderColor: visThemes[type]?.secondary,
            pointerEvents: 'all'
        }}>
        {title}
    &lt;/div>;
}

function ShelfTypeSelector({ shelfType }) {
    const [type, setType] = useProperty('type');

    return &lt;div className={`shelf-type-selector ${shelfType} ${type === shelfType ? 'active' : ''}`}
        onPointerDown={(e) => {
            stopEventPropagation(e);
            setType(shelfType);
        }}
        style={{
            backgroundColor: visThemes[shelfType].primary
        }} />
}

function VisShelfShape({ shape }) {
    const [type] = useProperty('type');
    const [dummies, setDummies] = useState([]);
    const [tempTitle, setTempTitle] = useState('');
    const [rows, setRows] = useState(2);
    const [columns, setColumns] = useState(2);

    const updateShelfComponents = () => {
        let shelfComponents = [];
        switch (type) {
            case 'spec':
                shelfComponents = getSpecComponents();
                break;
            case 'dataset':
                shelfComponents = getDatasetComponents();
                break;
            case 'piece':
                shelfComponents = getDefaultVisPiecesLibrary();
                break;
            default:
                if (DEBUG) console.log('Unknown VisShelf type: ' + type);
        }

        const newRows = Math.max(Math.ceil(Math.sqrt(shelfComponents.length)), 2);
        setRows(newRows);
        setColumns(Math.max(Math.ceil(shelfComponents.length / newRows), 2));

        setDummies(generateDummies(shelfComponents, setTempTitle));
    };

    useEffect(() => {
        updateShelfComponents();

        addVisComponentAddedListener(updateShelfComponents);
        addVisComponentRemovedListener(updateShelfComponents);
        return () => {
            removeVisComponentAddedListener(updateShelfComponents);
            removeVisComponentRemovedListener(updateShelfComponents);
        };
    }, [type]);

    const title = useMemo(() => {
        switch (type) {
            case 'spec': return 'Specs';
            case 'dataset': return 'Datasets';
            case 'piece': return 'Pieces';
            default: return 'Unknown';
        }
    }, [type]);

    return &lt;HTMLContainer className="vis-shelf-shape" style={{
        transform: 'translate(-50%, -50%)',
        width: shape.props.w + 'px',
        height: shape.props.h + 'px',
        pointerEvents: 'all'
    }}>
        &lt;div className="title">{tempTitle ? tempTitle : title}&lt;/div>
        &lt;div className="shelf-type-selectors">
            &lt;ShelfTypeSelector shelfType="spec" />
            &lt;ShelfTypeSelector shelfType="dataset" />
            &lt;ShelfTypeSelector shelfType="piece" />
        &lt;/div>
        &lt;div className="shelf" style={{
            gridTemplateColumns: `repeat(${columns}, 1fr)`,
            gridTemplateRows: `repeat(${rows}, 1fr)`
        }}>
            {dummies}
        &lt;/div>
    &lt;/HTMLContainer>;
}

class VisShelfShapeUtil extends MovableShapeUtil {
    static type = 'VisShelf';

    getDefaultProps() {
        return Object.assign(super.getDefaultProps(), {
            w: CANVAS_SCALE * 0.5,
            h: CANVAS_SCALE * 0.5
        });
    }

    component(shape) {
        return &lt;MovableVarvScope shape={shape}>
            &lt;VisShelfShape shape={shape} />
        &lt;/MovableVarvScope>;
    }
}

export const Main = VisShelfShapeUtil;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Vis-Shelf Menu" auto>import React from 'react';

import { createMovable } from '#Spatialstrates .movable-helpers';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { addControllerSubMenu, addItemToControllerSubMenu, ControllerMenuTitle, ControllerMenuSpacer, ControllerMenuButton } from '#ControllerMenu .default';



addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'add-vis-shelf', &lt;MenuButton onClick={() => createMovable('VisShelf')}>New Bookshelf&lt;/MenuButton>, 300);
addItemToSubMenu('movables', 'spacer-items', &lt;MenuSpacer />, 400);

addControllerSubMenu('movables', 100, false);
addItemToControllerSubMenu('movables', 'title', &lt;ControllerMenuTitle title="Menu" />, 0);
addItemToControllerSubMenu('movables', 'add-vis-shelf', &lt;ControllerMenuButton onClick={() => createMovable('VisShelf')}>New Bookshelf&lt;/ControllerMenuButton>, 300);
addItemToControllerSubMenu('movables', 'spacer-items', &lt;ControllerMenuSpacer />, 400);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Vis-Shelf Styles" auto>@mixin heading-font {
    font-weight: 500;
    font-size: 13px;
    letter-spacing: 0.25px;
}

.vis-shelf-shape {
    border-radius: 8px;
    background-color: hsl(200, 18%, 75%);
    border: 4px solid hsl(200, 18%, 50%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 4px;
    padding: 4px;

    .title {
        color: #000;
        position: absolute;
        top: -40px;
        left: 50%;
        transform: translate(-50%, -100%);
        font-size: 16px;
        font-weight: 500;
        width: 100%;
        text-align: center;
    }

    .shelf-type-selectors {
        position: absolute;
        top: -8px;
        left: 50%;
        transform: translate(-50%, -100%);
        display: flex;
        gap: 32px;
        flex-direction: row;
        height: 28px;
        align-items: center;

        .shelf-type-selector {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            pointer-events: all;

            &.active {
                width: 28px;
                height: 28px;
            }
        }
    }

    .shelf {
        display: grid;
        width: 100%;
        height: 100%;
        gap: 4px;

        .vis-component-dummy {
            font-family: monospace;
            color: #fff;
            border-radius: 4px;
            border: 1.5px solid #000;
            padding: 4px;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            overflow: hidden;
            text-align: center;
            font-size: 6px;
            overflow-wrap: anywhere;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER></CODE-FOLDER><CODE-FOLDER id="vis-component-container" name="Vis-Components" class><CODE-FOLDER name="Specs" id class="spec-container"></CODE-FOLDER><CODE-FOLDER name="Datasets" id class="dataset-container">
    </CODE-FOLDER></CODE-FOLDER>





</body></html>
