<!doctype html>
<html data-protected="all"><head><SCRIPT id="WPMv2-script" type="text/javascript">/**
 * WPMv2 - Webstrate Package Manager
 *
 * Copyright 2019 Rolf Bagge, Janus Bager Kristensen,
 * CAVI - Center for Advanced Visualisation and Interaction,
 * Aarhus University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

/* global Promise, webstrate, eval */

//Encapsulate WPMv2, so we can decide which methods are public
((window) => {

    const WPM_ALIASES = "WPM.repoAliases";

    let runningRequiresPromiseMap = [];

    let allInstalledCallbacksStack = [];

    const requireQueue = [];

    /**
     * WebstratePackageManager version 2
     *
     * It is used to install WPM packages into webstrates.
     *
     * <pre><code>WPMv2.require([
     *      {package: "somePackageName", repository: "/somewebstraterepo"},
     *      {package: "someOtherPackageName", repository: "/somewebstraterepo"}
     * ]).then(()=>{
     *     //Packages are now installed
     * });
     * </code></pre>
     * @hideconstructor
     */
    class WPMv2 {
        static async bootstrap(packageDom, options, requireToken, triggerOnPackageInstalled = false) {
            let wpmPackage = WPMv2.getWPMPackageFromDOM(packageDom);
            let promises = [];

            /**
             * @class WPMInterface
             * @classdesc
             * Internal WPM interface that is provided for every package that is installed via WPMv2. Is accessed as just wpm, when inside package code.
             * @hideconstructor
             * @memberof WPMv2
             */
            let wpmInterface = {};

            /**
             * Reads metadata from the given package. If no packagename is given, metadata from the current package is read.
             *
             * @example
             * let metadata = wpm.readMetadata();
             *
             * @param {string} [packageName] - The package to read metadata from
             * @returns {json}
             * @memberof WPMv2.WPMInterface
             * @name readMetadata
             * @method
             */
            wpmInterface.readMetadata = (packageName = null) => {
                if (packageName == null) {
                    packageName = packageDom.getAttribute("id");
                }

                return WPMv2.readMetadata(packageName);
            };

            /**
             * Registers a callback to be called when this package is installed.
             *
             * @example
             * wpm.onInstalled(()=>{
             *     //Package is now installed
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onInstalled
             * @method
             */
            wpmInterface.onInstalled = (callback) => {
                packageDom.addEventListener("wpm.packageInstalled", callback, {"once": true});
            };

            /**
             * Registers a callback to be called when all packages are installed. (When installing multiple packages at the same time.)
             *
             * @example
             * wpm.onAllInstalled(()=>{
             *     //All packages are installed
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onAllInstalled
             * @method
             */
            wpmInterface.onAllInstalled = (callback) => {
                //Retrieve from stack
                let allInstalledCallbacks = allInstalledCallbacksStack[allInstalledCallbacksStack.length-1];
                if (allInstalledCallbacks){
                    allInstalledCallbacks.push(callback);
                } else {
                    // STUB: Remove FIXME if ok
                    console.log("FIXME: WPMv2 - No allInstalledCallbacks in allInstalledCallbacksStack, assuming no more packages? Is this ok?");
                    // Immediately call the callback since no more packages are left
                    callback();
                }

            };

            /**
             * Registers a callback to be called when this package is removed.
             *
             * @example
             * wpm.onRemoved(({detail: packageName})=>{
             *     //Package is removed, packageName is provided for ease of access, will be same as the package this callback was registered from.
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onRemoved
             * @method
             */
            wpmInterface.onRemoved = (callback) => {
                packageDom.addEventListener("wpm.packageRemoved", callback, {"once": true});
            };

            /**
             * Registers a callback to be called when any package is removed.
             *
             * @example
             * wpm.onRemovedAny(({detail: packageName})=>{
             *      //Package with name "packageName" has been removed
             * });
             *
             * @param {method} callback
             * @memberof WPMv2.WPMInterface
             * @name onRemovedAny
             * @method
             */
            wpmInterface.onRemovedAny = (callback) => {
                document.addEventListener("wpm.packageRemovedAny", callback);
            };

            wpmInterface.require = async (packageRequests, extraOptions) => {
                let convertedPackages = [];

                if (packageRequests != null) {
                    if (!Array.isArray(packageRequests)) {
                        packageRequests = [packageRequests];
                    }

                    for (let packageRequest of packageRequests) {
                        if (typeof packageRequest === "string") {
                            //Shorthand for requiring dependency, lookup in our descriptor
                            let packageName = packageRequest;
                            let repo = wpmPackage.optionalDependencyMap.get(packageName);

                            convertedPackages.push({
                                package: packageName,
                                repository: repo
                            });
                        } else {
                            convertedPackages.push(packageRequest);
                        }
                    }
                } else {
                    //packages == null, means require all dependencies!
                    wpmPackage.optionalDependencyMap.forEach((repo, packageName) => {
                        convertedPackages.push({
                            package: packageName,
                            repository: repo
                        });
                    });
                }

                const combinedOptions = Object.assign({}, options, extraOptions);

                promises.push(WPMv2.require(convertedPackages, combinedOptions, requireToken));

                return Promise.all(promises);
            };

            async function loadExternalCSS(response) {
                let styleContent = await response.text();

                //Attempt linking stylesheets instead of inlining them
                let style = document.createElement("style");

                let transient = document.createElement("transient");
                transient.appendChild(style);

                //Disable sourcemap

                styleContent = styleContent.replace(/\/\*#\s*sourceMappingURL=\S+\s*\*\//, "");
                //styleContent = styleContent.replace(/\/\/#\s*sourceMappingURL=\S+/, "");

                style.innerHTML = styleContent;

                document.head.append(transient);
            }

            async function loadExternalJS(response) {
                let scriptContent = await response.text();

                //Hack to make requirejs work, and be able to hide it
                const origDefine = window.define;
                if (window.define != null) {
                    window.define = undefined;
                }

                //Disable sourcemap
                //scriptContent = scriptContent.replace(/\/\*#\s*sourceMappingURL=\S+\s*\*\//, "");
                scriptContent = scriptContent.replace(/\/\/# sourceMappingURL=\S+/, "");

                eval.call(null, scriptContent);

                //Restore previous define, if this script did not set define
                if (window.define == null && origDefine != null) {
                    window.define = origDefine;
                }
            }

            /**
             * Fetches and evaluates external javascript, or loads css.
             *
             * The server response header Content-Type will be used to determine if its a JS or CSS.
             *
             * @example
             * await wpm.requireExternal("https://some.site.com/someScript.js");
             * //someScript.js has now been parsed and evaluated
             *
             * @param {string|string[]} urls - The URLs to the wanted JS, CSS
             * @returns {Promise<void>} - Resolves when all scripts/styles are fetched and evaluated/loaded
             * @memberof WPMv2.WPMInterface
             * @name requireExternal
             * @method
             */
            wpmInterface.requireExternal = async (urls) => {
                if(!(urls instanceof Array)) {
                    urls = [urls];
                }

                for(let url of urls) {

                    let promise = new Promise(async (resolve, reject)=>{
                        try {
                            let response = await fetch(url, {credentials: 'same-origin'});

                            let contentType = response.headers.get("Content-Type").trim();
                            let indexOfSemicolon = contentType.indexOf(";");
                            if (indexOfSemicolon !== -1) {
                                contentType = contentType.substring(0, indexOfSemicolon).trim();
                            }

                            switch (contentType) {
                                case "text/css": {
                                    await loadExternalCSS(response);
                                    break;
                                }
                                case "text/javascript":
                                case "application/javascript":
                                case "application/x-javascript": {
                                    await loadExternalJS(response);
                                    break;
                                }
                                default:
                                    console.warn("Unhandled contentType:", contentType, url);
                                    console.warn("Loading unknown as JS for know. please report...")
                                    await loadExternalJS(response);
                            }
                            resolve();
                        } catch(e) {
                            reject("Unable to fetch: "+url);
                        }
                    });

                    //promises.push(promise);

                    await promise;
                }
            };

            let scripts = packageDom.querySelectorAll("script[type='disabled']");

            for (let i = 0; i < scripts.length; i++) {
                let script = scripts[i];

                let scriptContent = "";

                if (script.src != null && script.src.length > 0) {
                    let response = await fetch(script.src, {credentials: 'same-origin'});
                    scriptContent = await response.text();
                } else {
                    scriptContent = script.innerText;
                }

                scriptContent = 'try{'+scriptContent+'} catch (ex){console.error("Bootstrap runtime error in '+packageDom.getAttribute("id").replaceAll("'","")+':", ex);}';

                const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;

                try {
                    let functionArgs = [];
                    functionArgs.push("wpm");

                    let functionArgValues = [];
                    functionArgValues.push(wpmInterface);

                    if(options.context != null) {
                        const contextKeys = Object.keys(options.context);
                        functionArgs.push(...contextKeys);

                        const contextValues = Object.values(options.context);
                        functionArgValues.push(...contextValues);
                    }

                    let wpmEval = new AsyncFunction(...functionArgs, scriptContent);
                    await wpmEval(...functionArgValues);
                } catch (e) {
                    console.error("Bootstrap parse error in " + packageDom.getAttribute("id"), e);
                }
            }

            await Promise.all(promises);

            if (triggerOnPackageInstalled) {
                packageDom.dispatchEvent(new CustomEvent("wpm.packageInstalled"));
            }
        }

        /**
         * Installs all packages at the given repository into the current page
         *
         * @example
         * WPMv2.requireAll("https://some.site.com/myRepo");
         *
         * @param {string} repository - The repository to lookup packages from
         * @param {WPMv2~PackageOptions} options - options to use for overriding packages options, also applies for dependencies
         * @returns {Promise<void>} - Resolved when packages are installed
         */
        static async requireAll(repository, options = {}) {
            let packages = [];

            let wpmPackages = await WPMv2.getPackagesFromRepository(repository);

            wpmPackages.forEach((pkg) => {
                if(options.blacklist != null && options.blacklist instanceof Array && options.blacklist.includes(pkg.name)) {
                    //Skip this package
                    return;
                }

                let pkgOptions = {
                    repository: pkg.repository,
                    package: pkg.name
                };
                packages.push(pkgOptions);
            });

            return WPMv2.require(packages, options);
        }

        /**
         * @typedef {Object} WPMv2~PackageOptions
         * @property {string} [repository] - The repository to lookup the package inside. If left unset, the current page is used.
         * @property {HTMLElement|string} [appendTarget] - The dom node to append to. If a string, will be looked up by document.querySelector(appendTarget). Defaults to a transient div inside document.head
         * @property {('append'|'before'|'after'|'prepend')} [appendMethod] - How to append to the appendTarget. Defaults to 'append'.
         */

        /**
         * @typedef {Object} WPMv2~PackageJson
         * @property {string} package - The name of the package
         * @property {string} [repository] - The repository to lookup the package inside. If left unset, the current page is used.
         * @property {HTMLElement|string} [appendTarget] - The dom node to append to. If a string, will be looked up by document.querySelector(appendTarget). Defaults to a transient div inside document.head
         * @property {('append'|'before'|'after'|'prepend')} [appendMethod] - How to append to the appendTarget. Defaults to 'append'.
         */

        /**
         *
         * @param {WPMv2.WPMPackage[]}packages
         * @returns {Promise<void>}
         */
        static async findCompletePackageTreeSorted(packages = [], defaultOptions, overrideOptions = {}) {
            const numPackages = packages.length;

            if (!Array.isArray(packages)) {
                packages = [packages];
            }

            let alreadySorting = [];
            let convertedPackages = [];

            async function addRepo(repoUrl, options) {
                if(overrideOptions.repository != null) {
                    console.warn("Adding a full repository, does not atm support overriding options for repository...");
                }

                try {
                    let packages = await WPMv2.getPackagesFromRepository(repoUrl);
                    for(let pkg of packages) {
                        if(options != null) {
                            pkg.updateFromOptions(options);
                        }
                        await addPackage(pkg);
                    }
                } catch (ex){
                    console.error("WPMv2 very important error: Could not resolve repository. This will probably cause the site to fail horribly! ", repoUrl, ex);
                }
            }

            async function addPackage(wpmPackage) {
                //Check if package is in local dom
                let localPackageDom = document.querySelector(".packages .package#" + wpmPackage.name + ", wpm-package#" + wpmPackage.name);
                let repoOverride = wpmPackage.repository;
                if(localPackageDom != null) {
                    //Local package exists, override repository with local ? This breaks dependencies that are "same repository", since they now lookup on the local repository.
                    //Not setting local repository, makes the update from dom, happen on the non embedded version, which is also wrong?
                    //wpmPackage.repository = WPMv2.getLocalRepositoryURL();
                    repoOverride = WPMv2.getLocalRepositoryURL();
                }

                let name = WPMv2.getName(wpmPackage);
                if(!alreadySorting.includes(name)){
                    alreadySorting.push(name);
                    try {
                        wpmPackage = await WPMv2.getLatestPackageFromPackage(wpmPackage, repoOverride);
                        let dependencies = await WPMv2.findAllDependencies(wpmPackage, Object.assign({}, overrideOptions));

                        for(let dependency of dependencies) {
                            await addPackage(dependency);
                        }
                        convertedPackages.push(wpmPackage);
                    } catch (ex){
                        console.error("WPMv2 very important error: Could not resolve package. This will probably cause the site to fail horribly! ", wpmPackage, ex);
                    }
                }
            }

            // Resolve all the packages
            await Promise.all(packages.map(async (pkg)=>{
                let wpmPackage = null;
                if (pkg instanceof WPMPackage) {
                    //Already a WPMPackage
                    wpmPackage = pkg;
                    wpmPackage.updateFromOptions(overrideOptions);
                } else if(typeof pkg === "string") {
                    if(pkg.startsWith("http") || (pkg.startsWith("/") && pkg.indexOf(" ") === 0)) {
                        //Full repository, http(s)://myrepourl or /my-relative-url
                        await addRepo(pkg);
                        return;
                    } else {
                        //Single package, name or including repository
                        let split = pkg.split(" ");

                        if(split.length === 1) {
                            //Single local package
                            let options = Object.assign({}, defaultOptions, {
                                "package": split[0]
                            }, overrideOptions);
                            wpmPackage = new WPMPackage(options.package, options.repository);
                            wpmPackage.updateFromOptions(options);
                        } else if(split.length === 2) {
                            //Single package from given repository
                            let options = Object.assign({}, defaultOptions, {
                                "package": split[1].replace("#", ""),
                                "repository": split[0]
                            }, overrideOptions);
                            wpmPackage = new WPMPackage(options.package, options.repository);
                            wpmPackage.updateFromOptions(options);
                        } else {
                            console.warn("Unable to parse package from string:", pkg);
                        }
                    }
                } else {
                    if(pkg.repository != null && pkg.package != null) {
                        //Full package, add
                        let options = Object.assign({}, defaultOptions, pkg, overrideOptions);
                        wpmPackage = new WPMPackage(options.package, options.repository);
                        wpmPackage.updateFromOptions(options);
                    } else if(pkg.repository != null) {
                        //Full repo, add all
                        await addRepo(pkg.repository, pkg);
                        return;
                    }
                }

                if(wpmPackage != null) {
                    await addPackage(wpmPackage);
                } else {
                    console.log("Was null:", pkg);
                }
            }));

            const sortedPackages = [];
            let lastLength = convertedPackages.length;
            while(convertedPackages.length > 0) {
                let packagesWithDependenciesInstalled = convertedPackages.filter((pkg)=>{
                    let ready = true;

                    for(let dep of pkg.dependencyMap) {
                        //If any dependency is not sorted to be installed yet, this is not ready
                        if(!WPMv2.hasPackage(sortedPackages, {"package": dep[0]})) {
                            ready = false;
                            break;
                        }
                    }
                    for(let dep of pkg.optionalDependencyMap) {
                        //If not already sorted to be installed, and among packages to install, this is not ready yet
                        if(!WPMv2.hasPackage(sortedPackages, {"package": dep[0]}) && WPMv2.hasPackage(convertedPackages, {"package": dep[0]})) {
                            ready = false;
                            break;
                        }
                    }

                    return ready;
                });

                packagesWithDependenciesInstalled.forEach((pkg)=>{
                    sortedPackages.push(pkg);
                    convertedPackages.splice(convertedPackages.indexOf(pkg), 1);
                });

                if(convertedPackages.length === lastLength) {
                    console.warn("Not able to add any more packages:", convertedPackages);
                    break;
                }
                lastLength = convertedPackages.length;
            }

            return sortedPackages;
        }

        /**
         * Finds all dependencies of a package
         * @param pkg
         * @returns {Promise<WPMv2.WPMPackage[]>}
         * @private
         */
        static async findAllDependencies(pkg, overrideOptions = {}) {
            let dependencies = [];

            for(let dependencyEntry of pkg.dependencyMap) {
                let dependency = new WPMPackage(dependencyEntry[0], dependencyEntry[1]);
                dependency.updateFromOptions(overrideOptions);
                dependencies.push(dependency);
            }

            return dependencies;
        }

        /**
         * Checks if the given array, contains the given package
         * @private
         */
        static hasPackage(packages, searchPackage) {
            return packages.find((pkg)=>{
                let pkgName = WPMv2.getName(pkg);
                let searchPackageName = WPMv2.getName(searchPackage);

                if(pkgName == null || searchPackageName == null) {
                    console.warn("Unable to compare as one was null");
                    return false;
                }

                return pkgName === searchPackageName;
            }) != null;
        }

        static getName(searchPackage){
            if(searchPackage instanceof WPMPackage) {
                return searchPackage.name;
            } else if(searchPackage.package != null) {
                return searchPackage.package;
            } else {
                console.warn("Unable to infer package name from:", searchPackage);
                return null;
            }
        }

        /**
         * Installs the given packages into the current document
         *
         * Override options set in overrideOptions, override the options given in packages.
         *
         * @example
         * WPMv2.require([{package: "myPackage", repository: "myRepositoryUrl"}]);
         *
         * @param {WPMv2.WPMPackage[]|WPMv2.WPMPackage|WPMv2~PackageJson[]|WPMv2~PackageJson} packages - the packages to install
         * @param {WPMv2~PackageOptions} overrideOptions - options to use for overriding packages options, also applies for dependencies
         * @returns {Promise<void>} - Resolves when the packages are done installing
         */
        static async require(packages = [], overrideOptions = {}, givenRequireToken = null) {
            const defaultOptions = {
                repository: WPMv2.getLocalRepositoryURL(),
                appendMethod: "append",
                appendTarget: null,
                bootstrap: true
            };

            //Make sure we dont override package
            if(overrideOptions.hasOwnProperty("package")) {
                console.warn("Overriding package...", overrideOptions);
                delete overrideOptions.package;
            }

            const completePackageTreeSorted = await WPMv2.findCompletePackageTreeSorted(packages, defaultOptions, overrideOptions);

            if (packages.length === 0) {
                return;
            }

            let requireToken = givenRequireToken;

            let timerId = [...Array(10)].map(_ => (Math.random() * 36 | 0).toString(36)).join``;
            let requireTimerId = "Require time [" +timerId +"]";

            if (givenRequireToken == null) {
                allInstalledCallbacksStack.push([]);
                requireToken = {};
                console.time(requireTimerId);
            }

            // Schedule all the package promises in parallel, but keep track of package inter-dependencies too
            let packagePromiseMap = new Map();

            //Save the currently running require
            runningRequiresPromiseMap.push(packagePromiseMap);

            for (let pkg of completePackageTreeSorted) {
                // At this point, since the tree is sorted, a dependency is either hard and supposed to be in the tree or soft and maybe in the tree (if not, then not installed)
                // If the depedency is hard and not in the tree then a missing package error has already happened and we are going by best-effort anyways, so ignore this case.

                //Check for another require already promising to install this package
                let foundPromise = null;
                for(let promiseMap of runningRequiresPromiseMap) {
                    if(promiseMap.has(pkg.name)) {
                        //Use other require promise, to tell us when package is installed
                        foundPromise = promiseMap.get(pkg.name);
                        break;
                    }
                }

                if(foundPromise != null) {
                    packagePromiseMap.set(pkg.name, foundPromise);
                } else {

                    packagePromiseMap.set(pkg.name, async function multithreadedFetchPackage() {
                        // Lookup all hard and optional dependencies and wait for them before starting ours
                        await Promise.all([...pkg.dependencyMap.keys(), ...pkg.optionalDependencyMap.keys()].map((dependency) => {
                            return packagePromiseMap.get(dependency);
                        }));

                        // Install this package
                        let options = Object.assign({}, defaultOptions, pkg.getPackageOptions(), overrideOptions);

                        //Check if package is in dom
                        let packageDom = document.querySelector(".packages .package#" + pkg.name + ", wpm-package#" + pkg.name);

                        let alreadyInstalled = false;

                        let wpmPackage = null;

                        let needsAppending = false;

                        if (packageDom == null) {
                            //We need to fetch and install package to dom
                            let fetchedPackageDom = await WPMv2.getPackageDOM(pkg.repository, pkg.name);

                            //Rewrite packageDom to a wpm-package
                            packageDom = document.createElement("wpm-package");

                            for (let index = fetchedPackageDom.attributes.length - 1; index > -1; --index) {
                                let attribute = fetchedPackageDom.attributes[index];
                                packageDom.setAttribute(attribute.name, attribute.value);
                            }

                            // Instead of display:none, hide it otherwise due to Chrome bug for SVGs
                            packageDom.style.width = 0;
                            packageDom.style.height = 0;
                            packageDom.style.position = "absolute";
                            packageDom.style.visibility = "hidden";

                            Array.from(fetchedPackageDom.children).forEach((child) => {
                                packageDom.appendChild(child);
                            });

                            WPMv2.stripProtection(packageDom);

                            wpmPackage = WPMv2.getWPMPackageFromDOM(packageDom);

                            needsAppending = true;
                        } else {
                            wpmPackage = WPMv2.getWPMPackageFromDOM(packageDom);
                            alreadyInstalled = true;
                        }

                        //Install into page
                        if (needsAppending) {
                            let appendTarget = options.appendTarget;

                            if (typeof appendTarget === "string") {
                                appendTarget = document.querySelector(appendTarget);
                            }

                            if (appendTarget == null) {
                                appendTarget = document.createElement("div");
                                appendTarget.setAttribute("transient-element", "");
                                appendTarget.setAttribute("transient-wpmid", packageDom.id);
                                document.head.appendChild(appendTarget);
                            }

                            switch (options.appendMethod.toLowerCase()) {
                                case "before":
                                    appendTarget.parentNode.insertBefore(packageDom, appendTarget);
                                    break;

                                case "after":
                                    appendTarget.parentNode.insertBefore(packageDom, appendTarget.nextSibling);
                                    break;
                                case "prepend":
                                    appendTarget.prepend(packageDom);
                                    break;

                                case "append":
                                default:
                                    appendTarget.append(packageDom);
                            }

                            // POST all assets to the target
                            if (wpmPackage.assets.length > 0) {
                                let repoAssetsUrl = WPMv2.lookupRepoAlias(wpmPackage.repository);
                                let repoAssets = await WPMv2.fetchAssets(repoAssetsUrl);

                                let localAssetsUrl = location.pathname + "?assets&latest";
                                let localAssets = await WPMv2.fetchAssets(localAssetsUrl);

                                let formData = new FormData();
                                let assetPromises = [];
                                wpmPackage.assets.forEach(function (asset) {
                                    //If we already have same filehash of this asset, skip
                                    let localAsset = localAssets.get(asset);
                                    let repoAsset = repoAssets.get(asset);

                                    if (localAsset != null && repoAsset != null && localAsset.fileHash === repoAsset.fileHash) {
                                        return;
                                    }

                                    assetPromises.push(new Promise(async function (resolve, reject) {
                                        let blob = await WPMv2.fetchAsset(repoAssetsUrl, asset);

                                        // Fetch it and append to POST
                                        formData.append("file", blob, asset);
                                        resolve();
                                    }));
                                });

                                if (assetPromises.length > 0) {
                                    await Promise.all(assetPromises);

                                    await fetch(location.pathname, {
                                        body: formData,
                                        credentials: 'same-origin',
                                        method: "post"
                                    });
                                }
                            }
                        }

                        //Check if package is live
                        if (packageDom.getAttribute("transient-wpm-live") == null) {
                            if(pkg.bootstrap) {
                                //Make package live
                                await WPMv2.bootstrap(packageDom, overrideOptions, requireToken, !alreadyInstalled);

                                packageDom.setAttribute("transient-wpm-live", "");
                            } else {
                                //Ignore
                            }
                        } else {
                            //Already live
                        }
                    }());
                }
            }

            // Wait for all packages to finish installation
            await Promise.all(Array.from(packagePromiseMap.values()));

            //Splice the finished require away
            runningRequiresPromiseMap.splice(runningRequiresPromiseMap.indexOf(packagePromiseMap), 1);

            //Only the first outer call to require, has givenAllInstalledCallbacks set to null
            if (givenRequireToken === null) {
                let allInstalledCallbacks = allInstalledCallbacksStack.pop();
                console.timeEnd(requireTimerId);

                let allInstalledTimerId = "All Installed [" + timerId + "]";

                console.time(allInstalledTimerId);
                for(let allInstalledCallback of allInstalledCallbacks) {
                    await allInstalledCallback();
                }
                console.timeEnd(allInstalledTimerId);
            }
        }

        /**
         * Get the package data based on the package DOM node
         *
         * @param {Node} packageDOM the package dom node
         * @returns {WPMPackage} the package
         * @ignore
         */
        static getWPMPackageFromDOM(packageDOM) {
            try {
                let name = packageDOM.getAttribute("id");

                let descriptorDom = packageDOM.querySelector("script[type='descriptor'], wpm-descriptor");

                if (descriptorDom !== null) {
                    try {
                        let packageJson = JSON.parse(descriptorDom.textContent);
                        let repository = packageDOM.getAttribute("data-repository");

                        if(repository == null) {
                            repository = WPMv2.getLocalRepositoryURL();
                        }

                        return new WPMPackage(name, repository, packageJson);
                    } catch (e){
                        console.error("Erroneous package descriptor", e, descriptorDom.textContent, packageDOM);
                    }
                } else {
                    console.error("Missing package descriptor: ", packageDOM);
                }
            } catch (e) {
                console.error(e);
            }
        }

        static getLocalRepositoryURL() {
            return location.origin + location.pathname + "?raw";
        }

        /**
         * Retrieve the package dom from a repository
         *
         * @param {String} repository the repository to retrieve from
         * @param {String} packageName the package to retrieve
         * @returns {Node} the package dom node
         * @ignore
         */
        static async getPackageDOM(repository, packageName) {
            let dom = null;

            if(repository == this.getLocalRepositoryURL()) {
                dom = document.querySelector("html");
            } else {
                dom = await WPMv2.fetchDom(repository);
            }

            let packageDOMSource = dom.querySelector(".packages .package#" + packageName + ", wpm-package#" + packageName);
            if (packageDOMSource === null) {
                throw new Error("Invalid package '" + packageName + "' specified, no such package in repository '" + repository + "'");
            }

            let packageDOM = packageDOMSource.cloneNode(true);
            if(!packageDOM.hasAttribute("data-repository")) {
                packageDOM.setAttribute("data-repository", repository);
            }

            return packageDOM;
        }

        /**
         * Get an array of all packages that is currently installed in the dom
         *
         * @example
         * let installedPackages = WPMv2.getCurrentlyInstalledPackages();
         *
         * @returns {WPMv2.WPMPackage[]}
         */
        static getCurrentlyInstalledPackages() {
            let packages = [];

            document.querySelectorAll(".packages .package, wpm-package").forEach(function (v) {
                packages.push(WPMv2.getWPMPackageFromDOM(v));
            });

            return packages;
        }

        /**
         * Retrieve the latest package data from the original repository this package is from
         *
         * @example
         * WPMv2.getCurrentlyInstalledPackages().forEach((pkg)=>{
         *     let package = WPMv2.getLatestPackageFromPackage(pkg);
         *     //package now holds the latest data retrieved from the original repo it was installed from: like version, dependencies, changelog etc.
         * });
         *
         * @param {WPMv2.WPMPackage} p - The package to update package data for
         * @returns {Promise<WPMv2.WPMPackage>}
         */
        static async getLatestPackageFromPackage(p, repoOverride=null) {
            let fetchRepository = p.repository;
            if(repoOverride != null) {
                fetchRepository = repoOverride;
            }
            let packageDOM = await WPMv2.getPackageDOM(fetchRepository, p.name);

            let updatedPackage = WPMv2.getWPMPackageFromDOM(packageDOM);

            updatedPackage.updateFromOptions(p.getPackageOptions());

            return updatedPackage;
        }

        /**
         * Find all packages at a repository
         *
         * @example
         * WPMv2.getPackagesFromRepository("some.site.com/myRepo").then((packages)=>{
         *     console.log("Packages at repo:");
         *     packages.forEach((pkg)=>{
         *         console.log(pkg);
         *     }):
         * });
         *
         * @param {String} repositoryUrl the repository to search
         * @returns {Promise<WPMv2.WPMPackage[]>} the packages found
         */
        static async getPackagesFromRepository(repositoryUrl) {
            let packages = [];

            let dom = await WPMv2.fetchDom(repositoryUrl);

            dom.querySelectorAll(".packages .package, wpm-package").forEach(function (v) {
                if(!v.hasAttribute("data-repository")) {
                    v.setAttribute("data-repository", repositoryUrl);
                }
                packages.push(WPMv2.getWPMPackageFromDOM(v));
            });

            return packages;
        }

        static readMetadata(packageName) {
            let packageDom = document.querySelector(".packages .package#" + packageName + ", wpm-package#" + packageName);

            if(packageDom != null) {
                let metadataDom = packageDom.querySelector("script[type='descriptor'], wpm-descriptor");

                if (metadataDom != null) {
                    return JSON.parse(metadataDom.textContent);
                }
            }
            return null;
        }

        static async fetchAsset(url, asset) {
            if(Array.isArray(url)) {
                for(let u of url) {
                    try {
                        let fetchedAsset = await WPMv2.fetchAsset(u, asset);
                        if(fetchedAsset != null) {
                            return fetchedAsset;
                        }
                    } catch(e) {
                        //Ignore
                    }
                }
            }

            let assetUrl = url.substring(0, url.indexOf("?"));
            if (!assetUrl.endsWith("/")) {
                assetUrl += "/";
            }

            assetUrl += asset;

            let response = await fetch(assetUrl, {credentials: 'same-origin'});
            let blob = await response.blob();

            return blob;
        }

        static async fetchAssets(url) {
            if(Array.isArray(url)) {
                for(let u of url) {
                    try {
                        let assets = await WPMv2.fetchAssets(u);
                        if (assets != null) {
                            return assets;
                        }
                    } catch(e) {
                        //Ignore ?
                    }
                }
            }

            if(!url.endsWith("?assets&latest")) {
                url = url.substring(0, url.indexOf("?")) + "?assets&latest";
            }

            if (WPMv2.assetsCache[url] != null) {
                if (Date.now() - WPMv2.assetsCache[url].timestamp < WPMv2.cacheTimeout) {
                    return WPMv2.assetsCache[url].assets;
                }
            }

            let response = await fetch(url, {credentials: 'same-origin'});

            let assetsJson = await response.json();

            let assetResult = new Map();

            assetsJson.forEach((asset)=>{
                let current = assetResult.get(asset.fileName);

                if(current == null || current.v < asset.v) {
                    assetResult.set(asset.fileName, asset);
                }
            });

            WPMv2.assetsCache[url] = {
                assets: assetResult,
                timestamp: Date.now()
            };

            return assetResult;
        }

        static lookupRepoAlias(alias) {
            let localStorageAliases = {};
            let sessionStorageAliases = {};
            try {
                localStorageAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
            } catch (ex){
                console.warn("Unparseable localStorage.repositoryAliases", ex);
            }
            try {
                sessionStorageAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
            } catch (ex){
                console.warn("Unparseable sessionStorage.repositoryAliases", ex);
            }

            if(localStorageAliases?.hasOwnProperty(alias)) {
                let result = localStorageAliases[alias];
                return result;
            } else if(sessionStorageAliases?.hasOwnProperty(alias)) {
                let result = sessionStorageAliases[alias];
                return result;
            } else {
                //Check if alias might be an url already?
                if(alias.startsWith("http") || alias.startsWith("/")) {
                    //Probabely an url
                    return alias;
                }
            }

            return ["/"+alias+"/?raw", "/"+alias+"/index.html"];
        }

        static async fetchDom(url) {
            //Lookup repos aliases
            url = WPMv2.lookupRepoAlias(url);

            if(Array.isArray(url)) {
                //Call again for each url in array
                for(let u of url) {
                    try {
                        let fetchedDom = await this.fetchDom(u);
                        if(fetchedDom != null) {
                            return fetchedDom;
                        }
                    } catch(e) {
                        //Ignore?
                        console.warn(e);
                    }
                }
            } else {
                if(url.endsWith("?raw") && !url.endsWith("/?raw")) {
                    url = url.substring(0, url.lastIndexOf("?raw")) + "/?raw";
                }

                // Check the cache for ongoing fetches for this URL
                let cachedDom = WPMv2.domCache.get(url);
                if (cachedDom != null) {
                    cachedDom = await cachedDom;
                    if (Date.now() - cachedDom.timestamp < WPMv2.cacheTimeout) {
                        return cachedDom.dom;
                    }
                }

                // No ongoing fetches, start one
                let fetcherPromise = (async function fetchDOMPromise(){
                    let response = await fetch(url, {credentials: 'same-origin'});
                    if(response != null) {
                        let documentText = await response.text();

                        let parsedDom = WPMv2.parser.parseFromString(documentText, "text/html");
                        if (parsedDom.readyState === "loading") {
                            await new Promise((resolve, reject) => {
                                parsedDom.addEventListener("DOMContentLoaded", () => {
                                    resolve();
                                });
                            });
                        }

                        return {
                            dom: parsedDom,
                            timestamp: Date.now()
                        };
                    }
                })();
                WPMv2.domCache.set(url, fetcherPromise);

                return (await fetcherPromise).dom;
            }

            console.error("Unable to fetchDOM from: ", url);
            return null;
        }

        /**
         * Strips all Webstrate protection from the given dom element and its children.
         *
         * @example
         * WPMv2.stripProtection(document.querySelector("#myElement"));
         *
         * @param {HTMLElement} html - The element to strip protection from
         */
        static stripProtection(html) {
            function stripAttributeProtection(elm) {
                if (!elm.__approvedAttributes) {
                    try {
                        elm.__approvedAttributes = new Set();
                    } catch (e) {
                    }
                }

                if (elm.attributes != null) {
                    for (let i = 0, atts = elm.attributes, n = atts.length; i < n; i++) {
                        elm.__approvedAttributes.add(atts[i].nodeName);
                    }
                }
            }

            if (html instanceof Array) {
                html.forEach((entry) => {
                    if (entry != null) {
                        WPMv2.stripProtection(entry);
                    }
                });
                return;
            }

            if (!html.__approved) {
                try {
                    html.__approved = true;
                } catch (e) {
                }
            }

            if (html.removeAttribute != null) {
                html.removeAttribute("unapproved");
            }

            stripAttributeProtection(html);

            if (html.childNodes != null) {
                Array.from(html.childNodes).forEach((child) => {
                    WPMv2.stripProtection(child);
                });
            } else if (html.children != null) {
                Array.from(html.children).forEach((child) => {
                    WPMv2.stripProtection(child);
                });
            }

            if (html.content != null) {
                WPMv2.stripProtection(html.content);
            }
        }

        /**
         * Updates the version of WPMv2 in the current page, with the version in the given url
         *
         * @example
         * await WPMv2.updateWPM("https://some.site.com/containsLatestWPMv2");
         * //WPMv2 is now updated
         *
         * @param {string} url - URL to the webstrate to update WPMv2 from
         * @returns {Promise<void>} - Resolves when WPMv2 is updated
         */
        static async updateWPM(url) {
            console.group("Updating WPM...");
            if(url == null) {
                console.log("No repository given for update, defaulting to \"/wpm/?raw\"");
                url = "/wpm/?raw";
            }

            console.log("Version before update:", window.WPMv2.version);

            let dom = await WPMv2.fetchDom(url);

            let newWpm = dom.querySelector("#WPMv2-script");

            let ourWpm = document.querySelector("#WPMv2-script");

            ourWpm.textContent = newWpm.textContent;

            if(ourWpm.hasAttribute("src")) {
                ourWpm.removeAttribute("src");
                console.warn("Removed src attribute on WPMScript, now inlined instead!");
            }
            eval.call(null, ourWpm.textContent);
            console.log("Version after update:", window.WPMv2.version);
            console.groupEnd();
        }

        /**
         * Installs WPMv2 into the given webstrate. Can be given as an iframe that already points to a transcluded webstrate, or the url to a webstrate.
         *
         * @example
         * await WPMv2.installWPMInto("https://some.site.com/myWebstrate");
         * //WPMv2 is now installed
         *
         * @param {HTMLIFrameElement|string} iframeOrUrl - The iframe or url that WPMv2 should be installed into
         * @returns {Promise<void>} - Resolves when WPMv2 is done installing.
         */
        static async installWPMInto(iframeOrUrl) {
            let iframe = null;
            let transient = null;

            if (typeof iframeOrUrl === "string") {
                iframe = document.createElement("iframe");
                iframe.src = iframeOrUrl;
                let promise = new Promise((resolve, reject) => {
                    iframe.webstrate.on("transcluded", function once() {
                        iframe.webstrate.off("transcluded", once);
                        resolve();
                    });
                });

                transient = document.createElement("transient");
                transient.append(iframe);
                document.body.append(transient);

                await promise;
            } else {
                //Attempt to unpack cQuery/jQuery objects
                if (iframeOrUrl[0] != null) {
                    iframeOrUrl = iframeOrUrl[0];
                }

                if (iframeOrUrl instanceof HTMLIFrameElement) {
                    iframe = iframeOrUrl;
                } else {
                    console.log("Unknown iframe/url: ", iframeOrUrl);
                    return;
                }
            }

            let targetHead = iframe.contentDocument.head;

            //Remove old WPMv2 if present
            let oldWpm = iframe.contentDocument.querySelector("#WPMv2-script");
            if (oldWpm != null) {
                oldWpm.parentNode.removeChild(oldWpm);
            }

            let clonedScript = document.querySelector("#WPMv2-script").cloneNode(true);

            if (clonedScript.src != null && clonedScript.src.length > 0) {
                let response = await fetch(clonedScript.src, {credentials: 'same-origin'});
                let scriptContent = await response.text();

                clonedScript.removeAttribute("src");
                clonedScript.textContent = scriptContent;
            }

            WPMv2.stripProtection(clonedScript);
            targetHead.insertBefore(clonedScript, targetHead.firstChild);

            iframe.contentWindow.eval.call(null, clonedScript.textContent);

            await iframe.contentWindow.webstrate.dataSaved();

            if (transient != null) {
                document.body.removeChild(transient);
            }
        }

        static notifyRemove(packageName, packageDom) {
            let event = new CustomEvent("wpm.packageRemoved", {detail: packageName});
            packageDom.dispatchEvent(event);

            let eventAny = new CustomEvent("wpm.packageRemovedAny", {detail: packageName});
            document.dispatchEvent(eventAny);
        }

        static getRegisteredRepositories(useLocalStorage) {
            let currentAliases = null;

            try {
                if(useLocalStorage) {
                    currentAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
                } else {
                    currentAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
                }
            } catch (ex){}
            if (currentAliases == null || typeof currentAliases !== "object"){
                currentAliases = {};
            }

            return currentAliases;
        }

        /**
         * Registers a repository alias
         * @param alias The alias to register
         * @param repository The repository to register the alias to
         * @param useLocalStorage If true, the registered alias is registered in localStorage, if not, in sessionStorage
         */
        static registerRepository(alias, repository, useLocalStorage = false) {
            let currentAliases = null;

            try {
                if(useLocalStorage) {
                    currentAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
                } else {
                    currentAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
                }
            } catch (ex){}
            if (currentAliases == null || typeof currentAliases !== "object"){
                currentAliases = {};
            }

            currentAliases[alias] = repository;

            if(useLocalStorage) {
                localStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            } else {
                sessionStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            }
        }

        /**
         * Unregisters a repository alias
         * @param alias The alias to unregister
         * @param useLocalStorage If true, the alias is removed from localStorage, if not, from sessionStorage
         */
        static unregisterRepository(alias, useLocalStorage = false) {
            let currentAliases = null;

            try {
                if(useLocalStorage) {
                    currentAliases = JSON.parse(localStorage.getItem(WPM_ALIASES));
                } else {
                    currentAliases = JSON.parse(sessionStorage.getItem(WPM_ALIASES));
                }
            } catch (ex){
                console.error(ex);
            }
            if (currentAliases == null || typeof currentAliases !== "object"){
                console.log(currentAliases);
                currentAliases = {};
            }

            delete currentAliases[alias];

            if(useLocalStorage) {
                localStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            } else {
                sessionStorage.setItem(WPM_ALIASES, JSON.stringify(currentAliases));
            }
        }

        /**
         * Clears all registered aliases from storage
         * @param useLocalStorage If true, clears from localStorage, if not, from sessionStorage
         */
        static clearRegisteredRepositories(useLocalStorage = false) {
            if(useLocalStorage) {
                localStorage.setItem(WPM_ALIASES, "{}");
            } else {
                sessionStorage.setItem(WPM_ALIASES, "{}");
            }
        }
    }

    WPMv2.domCache = new Map();
    WPMv2.assetsCache = {};
    WPMv2.parser = new DOMParser();
    WPMv2.cacheTimeout = 5000;

    /**
     * A WPM package
     * @memberof WPMv2
     */
    class WPMPackage {
        /**
         * Create a new WPMPackage
         * @param {string} name - The package name
         * @param {string} repository - The repository that the package should be fetched from
         * @param {json} [descriptorJson] - Package Descriptor
         */
        constructor(name, repository, descriptorJson = {}) {
            /**
             * The name of the package
             * @type {string}
             */
            this.name = name;
            /**
             * The repository the package is fetched from
             * @type {string}
             */
            this.repository = repository;

            /**
             * The version of the package
             * @type {number}
             */
            this.version = -1;
            /**
             * Package dependencies that will be installed when the package is installed
             * @type {string[]}
             */
            this.dependencies = [];
            /**
             * Optional Package dependencies
             * @type {string[]}
             */
            this.optionalDependencies = [];
            /**
             * Assets that the package uses, will be copied over to the webstrate where the package is installed
             * @type {Array.<string>}
             */
            this.assets = [];
            /**
             * A description of the package
             * @type {string}
             */
            this.description = "";
            /**
             * A human friendly name for the package
             * @type {string}
             */
            this.friendlyName = "";
            /**
             * Changelog, holding any changelog information for the package
             * @type {object}
             */
            this.changelog = {};
            /**
             * Link to documentation of the package if any exists
             * @type {string}
             */
            this.documentationLink = "";

            this.dependencyMap = new Map();
            this.optionalDependencyMap = new Map();

            this.appendMethod = "append";
            this.appendTarget = null;

            this.bootstrap = true;

            this.updateFromJson(descriptorJson);
        }

        updateFromOptions(options) {
            ["appendMethod", "appendTarget", "repository", "bootstrap"].forEach((optionProperty)=>{
                if(options.hasOwnProperty(optionProperty)) {
                    this[optionProperty] = options[optionProperty];
                }
            })
        }

        getPackageOptions() {
            let options = {};

            ["appendMethod", "appendTarget", "repository", "bootstrap"].forEach((optionProperty)=>{
                options[optionProperty] = this[optionProperty];
            });

            return options;
        }

        updateFromJson(packageJson) {
            let self = this;

            this.descriptor = packageJson;

            ["version", "friendlyName", "dependencies", "optionalDependencies", "description", "changelog", "documentationLink", "license"].forEach((packageProperty)=>{
                if (packageJson.hasOwnProperty(packageProperty)){
                    this[packageProperty] = packageJson[packageProperty];
                }
            });

            if (packageJson.hasOwnProperty("assets")) {
                packageJson.assets.forEach((asset) => {
                    if (asset.src != null) {
                        self.assets.push(asset.src);
                    } else {
                        self.assets.push(asset);
                    }
                });
            }

            this.dependencies.forEach((dep) => {
                let split = dep.split(" ");

                let repo = null;
                let packageName = null;

                if (split.length === 1) {
                    packageName = split[0].replace("#", "");
                    repo = this.repository;
                } else {
                    packageName = split[1].replace("#", "");
                    repo = split[0];
                }

                self.dependencyMap.set(packageName, repo);
            });

            this.optionalDependencies.forEach((dep) => {
                let split = dep.split(" ");

                let repo = null;
                let packageName = null;

                if (split.length === 1) {
                    packageName = split[0].replace("#", "");
                    repo = this.repository;
                } else {
                    packageName = split[1].replace("#", "");
                    repo = split[0];
                }

                self.optionalDependencyMap.set(packageName, repo);
            });
        }

        toString() {
            return this.name + "[" + this.version + "]";
        }
    }

    let removedObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            mutation.removedNodes.forEach((node) => {
                if (node.matches != null && node.matches(".packages .package, wpm-package")) {
                    WPMv2.notifyRemove(node.id, node);
                } else if (node.querySelectorAll != null) {
                    node.querySelectorAll(".packages .package, wpm-package").forEach((child) => {
                        WPMv2.notifyRemove(child.id, child);
                    });
                }
            });
        });
    });

    removedObserver.observe(document, {
        childList: true,
        attributes: false,
        subtree: true
    });

    //Setup attribute "transient-element" that marks a DOM element as transient
    if(typeof webstrate !== "undefined") {
        let oldIsTransientElement = webstrate.config.isTransientElement;
        webstrate.config.isTransientElement = (node) => {
            if (node.hasAttribute("transient-element")) {
                return true;
            }

            return oldIsTransientElement(node);
        };
    }

    //WPMv2 Interface to the world!
    window.WPMv2 = {
        require: WPMv2.require,
        requireAll: WPMv2.requireAll,
        installWPMInto: WPMv2.installWPMInto,
        stripProtection: WPMv2.stripProtection,
        updateWPM: WPMv2.updateWPM,
        getPackagesFromRepository: WPMv2.getPackagesFromRepository,
        getCurrentlyInstalledPackages: WPMv2.getCurrentlyInstalledPackages,
        getLatestPackageFromPackage: WPMv2.getLatestPackageFromPackage,
        registerRepository: WPMv2.registerRepository,
        unregisterRepository: WPMv2.unregisterRepository,
        clearRegisteredRepositories: WPMv2.clearRegisteredRepositories,
        getRegisteredRepositories: WPMv2.getRegisteredRepositories,
        getLocalRepositoryURL: WPMv2.getLocalRepositoryURL,
        version: 2.42,
        revision: "$Id: WPMv2.js 1023 2023-03-14 10:02:57Z au182811@uni.au.dk $",
        test: WPMv2
    };

    window.WPM = window.WPMv2;
    window.WPMPackage = WPMPackage;
})(window);

// Provide bootloader functionality
class WPMBoot {
    static loadedCallbacks = [];
    static isLoaded = false;

    static async wpmv2_bootloader(){
        document.querySelector("html").setAttribute("transient-wpm2-bootloader", "loading");

        let bootConfigElement = document.querySelector("head script[type='text/json+bootconfig']");
        if (!bootConfigElement){
            return;
        }

        let bootConfig = null;
        try {
            bootConfig = JSON.parse(bootConfigElement.textContent);
        } catch (ex){
            console.error("WPM bootloader cannot parse boot config", bootConfigElement.textContent, ex);
            return;
        }

        if (!bootConfig.require){
            console.warn("WPM bootloader did not find required 'require' section in boot config, ignoring");
            return;
        }

        if (!Array.isArray(bootConfig.require)){
            console.warn("WPM bootloader 'require' section in boot config is not an array, ignoring");
            return;
        }

        // Load all required packages with WPM
        for (let requireStep of bootConfig.require){
            if (!(requireStep.dependencies && Array.isArray(requireStep.dependencies))){
                console.warn("WPM bootloader skipping incorrect requirestep, dependency list is missing", requireStep);
                continue;
            }
            if (requireStep.repositories){
                if (typeof requireStep.repositories !== "object"){
                    console.warn("WPM bootloader skipping registration of repositories because requireStep.repositories isn't an object map of name->url", requireStep);
                } else {
                    for (const [key, value] of Object.entries(requireStep.repositories)) {
                        WPMv2.registerRepository(key, value);
                    }
                }
            }

            if (requireStep.options){
                await WPMv2.require(requireStep.dependencies, requireStep.options);
            } else {
                await WPMv2.require(requireStep.dependencies);
            }
        }

        // Fire loaded events
        document.querySelector("html").setAttribute("transient-wpm2-bootloader", "initializing");
        while (WPMBoot.loadedCallbacks.length>0){
            let callback = WPMBoot.loadedCallbacks.pop();
            try {
                await callback();
            } catch (ex){
                console.error("WPMv2 Bootloader exception in WPMBoot.onLoaded(...) callback", ex, callback);
            }
        }
        document.querySelector("html").setAttribute("transient-wpm2-bootloader", "loaded");
    }

    static async onLoaded(callback){
        if (WPMBoot.isLoaded){
            await callback();
        } else {
            WPMBoot.loadedCallbacks.push(callback);
        }
    }
}
window.WPMBoot = WPMBoot;

document.querySelector("html").setAttribute("transient-wpm2-bootloader", "waiting");
if(typeof webstrate  !== "undefined") {
    // Webstrate mode
    webstrate.on("loaded", async function wpmv2_bootloader_loader() {
        await WPMBoot.wpmv2_bootloader();
    });
} else {
    // Standalone mode
    document.addEventListener("DOMContentLoaded", async function(event) {
        await WPMBoot.wpmv2_bootloader();
    });
}
</SCRIPT>
        <title>New Spatialstrate</title>
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <script type="text/json+bootconfig">{
    "creator": "WPMPackageManager",
    "created": 1650368097912,
    "require": [
        {
            "repositories": {
                "codestrates-repos": "https://raw.githubusercontent.com/Webstrates/Codestrates-v2/master/codestrates.html",
                "webstrate-components-repos": "https://raw.githubusercontent.com/Webstrates/WebstrateComponents/master/components.html",
                "cauldron-repos": "https://raw.githubusercontent.com/Webstrates/Cauldron/master/cauldron.html",
                "wpm_js_libs": "https://raw.githubusercontent.com/Webstrates/WebstrateLibraryRepository/master/libraries.html",
                "varv-repos": "https://raw.githubusercontent.com/Webstrates/Varv/master/varv.html",
                "wpm-repos": "https://raw.githubusercontent.com/Webstrates/WPM/master/build.html",
                "spatialstrates-repos": "https://raw.githubusercontent.com/Webstrates/Spatialstrates/main/repository/spatialstrates.html"
            },
            "dependencies": [
                {
                    "package": "CauldronURLLauncher",
                    "repository": "cauldron-repos"
                },
                {
                    "package": "CauldronButtonLauncher",
                    "repository": "cauldron-repos"
                },
                {
                    "package": "fragment_js",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_html",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_json",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_wpm-descriptor",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_css",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_scss",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_js_babel",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "FragmentFilesystemSync",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "fragment_markdown",
                    "repository": "codestrates-repos"
                },
                {
                    "package": "varv",
                    "repository": "varv-repos"
                },
                {
                    "package": "WPM-loading-skin-simple",
                    "repository": "wpm-repos"
                },
                {
                    "package": "SpatialstratesBasicBundle",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "SpatialstratesAddOnsBundle",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "StreamingBundle",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "MovableBundle",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "ImportMapping",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "Spatialstrates",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "Icon",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "Text",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "Menu",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "ControllerMenu",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "BasicMenu",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "AIHelpers",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "SpatialstratesLogo",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "CalibrationPoint",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "UserManager",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "Avatar",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "StreamManager",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "ScreenStreamManager",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "VideoStreamManager",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "ScreenStream",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "AudioStreamManager",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "VideoStream",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "AudioStream",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "Movable",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "StickyNote",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "Image",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "Trashcan",
                    "repository": "spatialstrates-repos"
                },
                {
                    "package": "Screenshots",
                    "repository": "spatialstrates-repos"
                }
            ],
            "options": {}
        }
    ],
    "updated": 1730991525571,
    "knownRepositories": [
        "varv-repos",
        "wpm-repos",
        "spatialstrates-repos"
    ]
}</script>
        <WPM-PACKAGE data-repository="wpm-repos" id="WPM-loading-skin-simple" style="width: 0px; height: 0px; position: absolute; visibility: hidden;"><SCRIPT id="descriptor-script" type="descriptor">
{
    "description": "A simple loading skin for the bootloader to avoid seeing improperly rendered HTML while loading",
    "dependencies": [
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "0.4",
    "forceEmbedding": true
}

</SCRIPT><STYLE id="loading-style">
html:not([transient-wpm2-bootloader="loaded"]) > * {
  opacity: 0 !important; }

@keyframes wpm-bootloader-spin {
  from {
    transform: translate(-50%, -50%) rotate(0); }
  to {
    transform: translate(-50%, -50%) rotate(360deg); } }

@keyframes wpm-bootloader-done {
  0% {
    transform: translate(-50%, -50%);
    filter: blur(0.01em); }
  99% {
    transform: translate(-50%, -50%) scale(1.5);
    opacity: 0;
    filter: blur(2em); }
  100% {
    visibility: hidden;
    transform: translate(-50%, -50%) scale(1.5);
    opacity: 0;
    filter: blur(2em); } }

html[transient-wpm2-bootloader="waiting"]:before, html[transient-wpm2-bootloader="loading"]:before, html[transient-wpm2-bootloader="initializing"]:before, html[transient-wpm2-bootloader="loaded"]:before {
  animation: wpm-bootloader-spin 1s infinite linear both;
  content: "";
  position: fixed;
  left: 50%;
  top: 50%;
  width: 3em;
  height: 3em;
  background: #f6fbff;
  border-radius: 2em;
  border: 4px solid white;
  border-top-color: rgba(0, 102, 255, 0.589);
  border-bottom-color: rgba(11, 90, 21, 0.466);
  box-shadow: 0 0 2em rgba(49, 60, 162, 0.446);
  pointer-events: none;
  z-index: 9999; }

html[transient-wpm2-bootloader="waiting"][transient-wpm2-bootloader="loaded"]:before, html[transient-wpm2-bootloader="loading"][transient-wpm2-bootloader="loaded"]:before, html[transient-wpm2-bootloader="initializing"][transient-wpm2-bootloader="loaded"]:before, html[transient-wpm2-bootloader="loaded"][transient-wpm2-bootloader="loaded"]:before {
  animation: wpm-bootloader-done 1s ease-out both; }
</STYLE></WPM-PACKAGE></head>

        <body>
                <wpm-package id="WPM-dev" data-repository="wpm-repos">
                    <script id="descriptor-script" type="descriptor">
                    {
                        "dependencies": [
                        ],
                        "forceEmbedding": true
                    }

                    </script>

                </wpm-package>

            <VARV-DATA></VARV-DATA><VARV-SIGNALING></VARV-SIGNALING><SCREEN-SIGNALING></SCREEN-SIGNALING><VIDEO-SIGNALING></VIDEO-SIGNALING><AUDIO-SIGNALING></AUDIO-SIGNALING><CODE-FOLDER name="Bundles"><WPM-PACKAGE name="SpatialstratesBasicBundle" id="SpatialstratesBasicBundle"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A bundle with all basic Spatialstrates packages",
    "dependencies": [
        "#Spatialstrates",
        "#Menu",
        "#ControllerMenu",
        "#BasicMenu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="SpatialstratesAddOnsBundle" name="SpatialstratesAddOnsBundle"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A bundle with Spatialstrates add-ons",
    "dependencies": [
        "#SpatialstratesLogo",
        "#CalibrationPoint",
        "#UserManager",
        "#Avatar"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="StreamingBundle" name="StreamingBundle"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A bundle of packages for WebRTC streaming",
    "dependencies": [
        "#StreamManager",
        "#ScreenStreamManager",
        "#VideoStreamManager",
        "#AudioStreamManager",
        "#ScreenStream",
        "#VideoStream",
        "#AudioStream"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="MovableBundle" id="MovableBundle"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A bundle for the Movable mechanism and basic components",
    "dependencies": [
        "#Movable",
        "#StickyNote",
        "#Image",
        "#Trashcan",
        "#Screenshots"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Core"><WPM-PACKAGE id="ImportMapping" name="ImportMapping"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Import map for Spatialstrates",
    "dependencies": [],
    "assets": [
        "use-gesture-fix.zip"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><SCRIPT name="Import Mapping" type="importmap" class="import-map">{
    "imports": {
        "three": "https://esm.sh/*three@0.169.0?dev",
        "three/": "https://esm.sh/*three@0.169.0&dev/",
        "three-stdlib": "https://esm.sh/*three-stdlib@2.30.4?dev",
        "three-mesh-bvh": "https://esm.sh/*three-mesh-bvh@0.7.6?dev",

        "react": "https://esm.sh/*react@18.3.1?dev",
        "react/": "https://esm.sh/*react@18.3.1&dev/",
        "react-dom": "https://esm.sh/*react-dom@18.3.1?dev",
        "react-dom/": "https://esm.sh/*react-dom@18.3.1&dev/",
        "react-is": "https://esm.sh/*react-is@18.3.1?dev",
        "react-composer": "https://esm.sh/*react-composer@5.0.3?dev",
        "react-use-measure": "https://esm.sh/*react-use-measure@2.1.1?dev",
        "react-merge-refs": "https://esm.sh/*react-merge-refs@1.1.0?dev",
        "react-reconciler": "https://esm.sh/*react-reconciler@0.29.2?dev",
        "react-reconciler/": "https://esm.sh/*react-reconciler@0.29.2&dev/",
        "react-error-boundary": "https://esm.sh/*react-error-boundary@4.0.13?dev",

        "@react-three/fiber": "https://esm.sh/*@react-three/fiber@8.17.10?dev",
        "@react-three/drei": "https://esm.sh/*@react-three/drei@9.114.4?dev",
        "@react-three/xr": "https://esm.sh/*@react-three/xr@6.2.15?dev",
        "@pmndrs/xr": "https://esm.sh/*@pmndrs/xr@6.2.15?dev",
        "@pmndrs/xr/": "https://esm.sh/*@pmndrs/xr@6.2.15&dev/",
        "@pmndrs/pointer-events": "https://esm.sh/*@pmndrs/pointer-events@6.2.15?dev",

        "@iwer/devui": "https://esm.sh/*@iwer/devui@0.1.1?dev",

        "@react-three/uikit": "https://esm.sh/*@react-three/uikit@0.6.0?dev",
        "@react-three/uikit-apfel": "https://esm.sh/*@react-three/uikit-apfel@0.6.0?dev",
        "@react-three/uikit-lucide": "https://esm.sh/*@react-three/uikit-lucide@0.6.0?dev",
        "@pmndrs/uikit": "https://esm.sh/*@pmndrs/uikit@0.6.0?dev",
        "@pmndrs/uikit/": "https://esm.sh/*@pmndrs/uikit@0.6.0&dev/",

        "@react-spring/three": "https://esm.sh/*@react-spring/three@9.7.3?dev",
        "@react-spring/core": "https://esm.sh/*@react-spring/core@9.7.3?dev",
        "@react-spring/shared": "https://esm.sh/*@react-spring/shared@9.7.3?dev",
        "@react-spring/animated": "https://esm.sh/*@react-spring/animated@9.7.3?dev",
        "@react-spring/types": "https://esm.sh/*@react-spring/types@9.7.3?dev",
        "@react-spring/rafz": "https://esm.sh/*@react-spring/rafz@9.7.3?dev",

        "zustand": "https://esm.sh/*zustand@4.5.5?dev",
        "zustand/": "https://esm.sh/*zustand@4.5.5&dev/",

        "lodash": "https://esm.sh/*lodash@4.17.21?dev",
        "lodash.pick": "https://esm.sh/*lodash.pick@4.4.0?dev",
        "lodash.omit": "https://esm.sh/*lodash.omit@4.5.0?dev",
        "lodash.clamp": "https://esm.sh/*lodash.clamp@4.0.3?dev",
        "lodash.merge": "https://esm.sh/*lodash.merge@4.6.2?dev",
        "lodash.mergewith": "https://esm.sh/*lodash.mergewith@4.6.2?dev",

        "@babel/runtime/helpers/esm/extends": "https://esm.sh/*@babel/runtime@7.24.8/helpers/extends?dev",
        "@monogrid/gainmap-js": "https://esm.sh/*@monogrid/gainmap-js@3.0.5?dev",
        "@preact/signals-core": "https://esm.sh/*@preact/signals-core@1.6.1?dev",
        "bidi-js": "https://esm.sh/*bidi-js@1.0.3?dev",
        "camera-controls": "https://esm.sh/*camera-controls@2.8.5?dev",
        "debounce": "https://esm.sh/*debounce@2.1.0?dev",
        "detect-gpu": "https://esm.sh/*detect-gpu@5.0.40?dev",
        "fast-json-patch": "https://esm.sh/*fast-json-patch@3.1.1?dev",
        "fflate": "https://esm.sh/*fflate@0.8.2?dev",
        "inline-style-parser": "https://esm.sh/*inline-style-parser@0.2.3?dev",
        "its-fine": "https://esm.sh/*its-fine@1.2.5?dev",
        "json-stringify-pretty-compact": "https://esm.sh/*json-stringify-pretty-compact@4.0.0?dev",
        "maath": "https://esm.sh/*maath@0.10.8?dev",
        "meshline": "https://esm.sh/*meshline@3.1.6?dev",
        "node-html-parser": "https://esm.sh/node-html-parser@6.1.13?dev",
        "object-assign": "https://esm.sh/*object-assign@4.1.1?dev",
        "potpack": "https://esm.sh/*potpack@2.0.0?dev",
        "prettier/": "https://esm.sh/*prettier@3.3.2&dev/",
        "prop-types": "https://esm.sh/*prop-types@15.8.1?dev",
        "scheduler": "https://esm.sh/*scheduler@0.23.2?dev",
        "stats.js": "https://esm.sh/*stats.js@0.17.0?dev",
        "stats-gl": "https://esm.sh/*stats-gl@2.2.8?dev",
        "suspend-react": "https://esm.sh/*suspend-react@0.1.3?dev",
        "tunnel-rat": "https://esm.sh/*tunnel-rat@0.1.2?dev",
        "tw-to-css": "https://esm.sh/*tw-to-css@0.0.12?dev",
        "troika-three-text": "https://esm.sh/*troika-three-text@0.49.0?dev",
        "troika-three-utils": "https://esm.sh/*troika-three-utils@0.49.0?dev",
        "troika-worker-utils": "https://esm.sh/*troika-worker-utils@0.49.0?dev",
        "use-sync-external-store": "https://esm.sh/*use-sync-external-store@1.2.2?dev",
        "use-sync-external-store/": "https://esm.sh/*use-sync-external-store@1.2.2&dev/",
        "uuid": "https://esm.sh/*uuid@10.0.0?dev",
        "webgl-sdf-generator": "https://esm.sh/*webgl-sdf-generator@1.1.1?dev",
        "yoga-layout/": "https://esm.sh/*yoga-layout@3.0.4&dev/",

        "vega": "https://esm.sh/vega@5.30.0?dev",
        "vega-embed": "https://esm.sh/vega-embed@6.26.0?dev",
        "d3": "https://esm.sh/d3@7.9.0?dev",

        "@use-gesture/core": "./use-gesture-fix.zip/use-gesture-core.esm.js",
        "@use-gesture/core/actions": "./use-gesture-fix.zip/use-gesture-core-actions.esm.js",
        "@use-gesture/react": "https://esm.sh/*@use-gesture/react@10.3.1?dev&external=@use-gesture/core,@use-gesture/core/actions",
        "@use-gesture/core/types": "https://esm.sh/*@use-gesture/core@10.3.1/types?dev&external=@use-gesture/core,@use-gesture/core/actions",
        "@use-gesture/core/utils": "https://esm.sh/*@use-gesture/core@10.3.1/utils?dev&external=@use-gesture/core,@use-gesture/core/actions",
        "tldraw": "https://esm.sh/tldraw@2.3.0?dev&external=react,react-dom,@use-gesture/react,@use-gesture/core,@use-gesture/core/actions"
    }
}
</SCRIPT><CODE-FRAGMENT data-type="application/json" name="Import Mapping JSON Copy">{
    "imports": {
        "three": "https://esm.sh/*three@0.169.0?dev",
        "three/": "https://esm.sh/*three@0.169.0&dev/",
        "three-stdlib": "https://esm.sh/*three-stdlib@2.30.4?dev",
        "three-mesh-bvh": "https://esm.sh/*three-mesh-bvh@0.7.6?dev",

        "react": "https://esm.sh/*react@18.3.1?dev",
        "react/": "https://esm.sh/*react@18.3.1&dev/",
        "react-dom": "https://esm.sh/*react-dom@18.3.1?dev",
        "react-dom/": "https://esm.sh/*react-dom@18.3.1&dev/",
        "react-is": "https://esm.sh/*react-is@18.3.1?dev",
        "react-composer": "https://esm.sh/*react-composer@5.0.3?dev",
        "react-use-measure": "https://esm.sh/*react-use-measure@2.1.1?dev",
        "react-merge-refs": "https://esm.sh/*react-merge-refs@1.1.0?dev",
        "react-reconciler": "https://esm.sh/*react-reconciler@0.29.2?dev",
        "react-reconciler/": "https://esm.sh/*react-reconciler@0.29.2&dev/",
        "react-error-boundary": "https://esm.sh/*react-error-boundary@4.0.13?dev",

        "@react-three/fiber": "https://esm.sh/*@react-three/fiber@8.17.10?dev",
        "@react-three/drei": "https://esm.sh/*@react-three/drei@9.114.4?dev",
        "@react-three/xr": "https://esm.sh/*@react-three/xr@6.2.15?dev",
        "@pmndrs/xr": "https://esm.sh/*@pmndrs/xr@6.2.15?dev",
        "@pmndrs/xr/": "https://esm.sh/*@pmndrs/xr@6.2.15&dev/",
        "@pmndrs/pointer-events": "https://esm.sh/*@pmndrs/pointer-events@6.2.15?dev",

        "@iwer/devui": "https://esm.sh/*@iwer/devui@0.1.1?dev",

        "@react-three/uikit": "https://esm.sh/*@react-three/uikit@0.6.0?dev",
        "@react-three/uikit-apfel": "https://esm.sh/*@react-three/uikit-apfel@0.6.0?dev",
        "@react-three/uikit-lucide": "https://esm.sh/*@react-three/uikit-lucide@0.6.0?dev",
        "@pmndrs/uikit": "https://esm.sh/*@pmndrs/uikit@0.6.0?dev",
        "@pmndrs/uikit/": "https://esm.sh/*@pmndrs/uikit@0.6.0&dev/",

        "@react-spring/three": "https://esm.sh/*@react-spring/three@9.7.3?dev",
        "@react-spring/core": "https://esm.sh/*@react-spring/core@9.7.3?dev",
        "@react-spring/shared": "https://esm.sh/*@react-spring/shared@9.7.3?dev",
        "@react-spring/animated": "https://esm.sh/*@react-spring/animated@9.7.3?dev",
        "@react-spring/types": "https://esm.sh/*@react-spring/types@9.7.3?dev",
        "@react-spring/rafz": "https://esm.sh/*@react-spring/rafz@9.7.3?dev",

        "zustand": "https://esm.sh/*zustand@4.5.5?dev",
        "zustand/": "https://esm.sh/*zustand@4.5.5&dev/",

        "lodash": "https://esm.sh/*lodash@4.17.21?dev",
        "lodash.pick": "https://esm.sh/*lodash.pick@4.4.0?dev",
        "lodash.omit": "https://esm.sh/*lodash.omit@4.5.0?dev",
        "lodash.clamp": "https://esm.sh/*lodash.clamp@4.0.3?dev",
        "lodash.merge": "https://esm.sh/*lodash.merge@4.6.2?dev",
        "lodash.mergewith": "https://esm.sh/*lodash.mergewith@4.6.2?dev",

        "@babel/runtime/helpers/esm/extends": "https://esm.sh/*@babel/runtime@7.24.8/helpers/extends?dev",
        "@monogrid/gainmap-js": "https://esm.sh/*@monogrid/gainmap-js@3.0.5?dev",
        "@preact/signals-core": "https://esm.sh/*@preact/signals-core@1.6.1?dev",
        "bidi-js": "https://esm.sh/*bidi-js@1.0.3?dev",
        "camera-controls": "https://esm.sh/*camera-controls@2.8.5?dev",
        "debounce": "https://esm.sh/*debounce@2.1.0?dev",
        "detect-gpu": "https://esm.sh/*detect-gpu@5.0.40?dev",
        "fast-json-patch": "https://esm.sh/*fast-json-patch@3.1.1?dev",
        "fflate": "https://esm.sh/*fflate@0.8.2?dev",
        "inline-style-parser": "https://esm.sh/*inline-style-parser@0.2.3?dev",
        "its-fine": "https://esm.sh/*its-fine@1.2.5?dev",
        "json-stringify-pretty-compact": "https://esm.sh/*json-stringify-pretty-compact@4.0.0?dev",
        "maath": "https://esm.sh/*maath@0.10.8?dev",
        "meshline": "https://esm.sh/*meshline@3.1.6?dev",
        "node-html-parser": "https://esm.sh/node-html-parser@6.1.13?dev",
        "object-assign": "https://esm.sh/*object-assign@4.1.1?dev",
        "potpack": "https://esm.sh/*potpack@2.0.0?dev",
        "prettier/": "https://esm.sh/*prettier@3.3.2&dev/",
        "prop-types": "https://esm.sh/*prop-types@15.8.1?dev",
        "scheduler": "https://esm.sh/*scheduler@0.23.2?dev",
        "stats.js": "https://esm.sh/*stats.js@0.17.0?dev",
        "stats-gl": "https://esm.sh/*stats-gl@2.2.8?dev",
        "suspend-react": "https://esm.sh/*suspend-react@0.1.3?dev",
        "tunnel-rat": "https://esm.sh/*tunnel-rat@0.1.2?dev",
        "tw-to-css": "https://esm.sh/*tw-to-css@0.0.12?dev",
        "troika-three-text": "https://esm.sh/*troika-three-text@0.49.0?dev",
        "troika-three-utils": "https://esm.sh/*troika-three-utils@0.49.0?dev",
        "troika-worker-utils": "https://esm.sh/*troika-worker-utils@0.49.0?dev",
        "use-sync-external-store": "https://esm.sh/*use-sync-external-store@1.2.2?dev",
        "use-sync-external-store/": "https://esm.sh/*use-sync-external-store@1.2.2&dev/",
        "uuid": "https://esm.sh/*uuid@10.0.0?dev",
        "webgl-sdf-generator": "https://esm.sh/*webgl-sdf-generator@1.1.1?dev",
        "yoga-layout/": "https://esm.sh/*yoga-layout@3.0.4&dev/",

        "vega": "https://esm.sh/vega@5.30.0?dev",
        "vega-embed": "https://esm.sh/vega-embed@6.26.0?dev",
        "d3": "https://esm.sh/d3@7.9.0?dev",

        "@use-gesture/core": "./use-gesture-fix.zip/use-gesture-core.esm.js",
        "@use-gesture/core/actions": "./use-gesture-fix.zip/use-gesture-core-actions.esm.js",
        "@use-gesture/react": "https://esm.sh/*@use-gesture/react@10.3.1?dev&external=@use-gesture/core,@use-gesture/core/actions",
        "@use-gesture/core/types": "https://esm.sh/*@use-gesture/core@10.3.1/types?dev&external=@use-gesture/core,@use-gesture/core/actions",
        "@use-gesture/core/utils": "https://esm.sh/*@use-gesture/core@10.3.1/utils?dev&external=@use-gesture/core,@use-gesture/core/actions",
        "tldraw": "https://esm.sh/tldraw@2.3.0?dev&external=react,react-dom,@use-gesture/react,@use-gesture/core,@use-gesture/core/actions"
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="MyWebstrates Import Mapping" auto>if (webstrate.importMap) {
    const scriptElement = document.querySelector('#ImportMapping .import-map');
    webstrate.importMap.create();
    webstrate.importMap.content = JSON.parse(scriptElement.innerHTML)
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Spatialstrates" name="Spatialstrates"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "The Spatialstrates core package and implementation",
    "dependencies": [
        "varv-repos varv-react"
    ],
    "assets": [
        "inter-variable.zip"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT auto data-type="text/javascript+babel" name="React Reloader">import React from 'react';
import { createRoot } from 'react-dom/client';



// Automatically reload this view if certain other fragments change
const changeFragments = [
    '#Spatialstrates [data-type="text/javascript+babel"]'
];

// Start the app
async function render() {
    if (!window.cachedAppRoot) {
        let element = document.createElement('transient');
        element.id = 'app-root';
        document.body.appendChild(element);
        window.cachedAppRoot = createRoot(element);
    }

    let content = await Fragment.one("#Spatialstrates [name='App']").require();
    window.cachedAppRoot.render(React.createElement(content.App));
};

let reloadTimer = null;
const reload = () => {
    clearTimeout(reloadTimer);
    reloadTimer = setTimeout(async function reloadReact() {
        try {
            render();
        } catch (ex) {
            console.log(ex);
        }
    }, 1000);
};

changeFragments.forEach(frag => {
    let lookedUpFragments = Fragment.find(frag);
    lookedUpFragments.forEach((lookedUpFragment) => {
        lookedUpFragment.registerOnFragmentChangedHandler(() => {
            if (fragmentSelfReference.auto) {
                reload();
            }
        });
    });
});

if (VarvEngine) {
    VarvEngine.registerEventCallback('engineReloaded', () => {
        reload();
    });
}

reload();
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="App" class="component">import React from 'react';
const { useEffect } = React;
import { Canvas, useThree } from '@react-three/fiber';
import { XR, createXRStore, IfInSessionMode, useXRInputSourceState } from '@react-three/xr';
import { Stats, Environment } from '@react-three/drei';
import { BackSide } from 'three';

import { DynamicComponents } from '#Spatialstrates .dynamic-components';
import { CustomCamera } from '#Spatialstrates .camera';
import { GlobalEventProvider } from '#Spatialstrates .global-events';





if (!window.moduleDeviceManager) {
    window.moduleDeviceManager = {};
}

function Scene() {
    // The Quest renders in lower resolution by default, this increases the resolution
    // https://discourse.threejs.org/t/webxr-quality-problems/24603/2
    const { gl } = useThree();
    useEffect(() => {
        gl?.xr.setFramebufferScaleFactor(2.0);
    }, [gl]);

    // Used for access to the camera in non-React components
    const { camera } = useThree();
    const xrCamera = useThree((s) => s.gl.xr.getCamera());
    const controllerRight = useXRInputSourceState('controller', 'right');
    const controllerLeft = useXRInputSourceState('controller', 'left');
    const handRight = useXRInputSourceState('hand', 'right');
    const handLeft = useXRInputSourceState('hand', 'left');
    useEffect(() => {
        window.moduleDeviceManager.camera = camera;
    }, [camera]);
    useEffect(() => {
        window.moduleDeviceManager.xrCamera = xrCamera;
    }, [xrCamera]);
    useEffect(() => {
        window.moduleDeviceManager.controllerRight = controllerRight;
    }, [controllerRight]);
    useEffect(() => {
        window.moduleDeviceManager.controllerLeft = controllerLeft;
    }, [controllerLeft]);
    useEffect(() => {
        window.moduleDeviceManager.handRight = handRight;
    }, [handRight]);
    useEffect(() => {
        window.moduleDeviceManager.handLeft = handLeft;
    }, [handLeft]);

    return &lt;>
        &lt;IfInSessionMode deny={['immersive-ar']}>
            &lt;gridHelper />
            &lt;color attach="background" args={[0xE5E4E2]} />
            &lt;mesh scale={200}>
                &lt;sphereGeometry />
                &lt;meshStandardMaterial color="#E5E4E2" side={BackSide} transparent={true} opacity={0.4} />
            &lt;/mesh>
        &lt;/IfInSessionMode>

        &lt;IfInSessionMode deny={['immersive-ar', 'immersive-vr']}>
            &lt;CustomCamera />
            &lt;Stats className="spatial-strates-stats" />
        &lt;/IfInSessionMode>

        &lt;Environment preset="city" />
        &lt;DynamicComponents selector=".dynamic-scene-component" />
    &lt;/>;
}

// https://github.com/pmndrs/xr/blob/1793fe3a4ecf07a30ea98ff2585811d3100d6b51/packages/xr/src/init.ts#L54
const store = createXRStore({
    frameRate: 'low',
    handTracking: true,
    hitTest: true,
    depthSensing: true,
    domOverlay: document.querySelector('#app-root')
});
window.xrStore = store;


export function App() {
    return &lt;>
        &lt;div className="crosshair">&lt;/div>
        &lt;DynamicComponents selector=".dynamic-gui-component" />
        &lt;Canvas dpr={2}
        gl={{ preserveDrawingBuffer: true, localClippingEnabled: true }}
        mode="concurrent">
            &lt;XR store={store}>
                &lt;GlobalEventProvider>
                    &lt;Scene />
                &lt;/GlobalEventProvider>
            &lt;/XR>
        &lt;/Canvas>
    &lt;/>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/css" auto name="Inter Font">@font-face {
    font-family: "Inter";
    font-weight: 100 900;
    font-display: swap;
    font-style: normal;
    src: url("inter-variable.zip/inter-variable.woff2") format("woff2-variations"),
         url("inter-variable.zip/inter-variable.woff2") format("woff2");
    src: url("inter-variable.zip/inter-variable.woff2") format("woff2") tech("variations");
}

@font-face {
    font-family: "Inter";
    font-weight: 100 900;
    font-display: swap;
    font-style: italic;
    src: url("inter-variable.zip/inter-variable-Italic.woff2") format("woff2-variations"),
         url("inter-variable.zip/inter-variable-Italic.woff2") format("woff2");
    src: url("inter-variable.zip/inter-variable-Italic.woff2") format("woff2") tech("variations");
}
</CODE-FRAGMENT><CODE-FRAGMENT auto data-type="text/x-scss" name="Core Style">body {
    margin: 0;
    font-family: Inter, sans-serif;
    height: 100vh;
}

#cauldron-edit-button {
    z-index: 100001;
    user-select: none;
    cursor: pointer;

    border-radius: 4px;
    height: 24px;
    box-sizing: unset;
    line-height: 24px;
    font-family: 'Inter', sans-serif;
    padding: 0 8px;
    top: 12px !important;
    right: 12px !important;
    font-weight: 500;
    font-size: 13px;

    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60) !important;
    border: 1px solid #cccccc70;

    &:hover {
        background: rgba(255, 255, 255, .80) !important;
    }
}

.crosshair {
    display: none;
    position: absolute;
    left: 50%;
    top: 50%;
    background: #FF3D00;
    outline: 2px solid #E4E3DF;
    border: 2px solid #231F20;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
}

.spatial-strates-stats {
    top: 48px !important;
    right: 12px !important;
    left: auto !important;

    canvas {
        border-radius: 3px;
    }
}
</CODE-FRAGMENT><CODE-FOLDER id name="Core Components"><CODE-FRAGMENT data-type="text/javascript+babel" id name="Camera" class="component camera">import React from 'react';
const { useRef, useEffect } = React;
import { Vector3 } from 'three';
import { useFrame } from '@react-three/fiber';
import { PointerLockControls } from '@react-three/drei';



const SPEED = 1.4;



export function CustomCamera() {
    const controls = useRef();
    const crosshair = useRef(document.querySelector('.crosshair'));
    const moveDirection = useRef(new Vector3());

    useEffect(() => {
        window.moduleCameraControls = { controlsRef: controls };

        return () => {
            window.moduleCameraControls = {};
        };
    }, []);

    useEffect(() => {
        const handleKeyDown = (event) => {
            if (!controls.current.isLocked) return;
            switch (event.code) {
                case 'KeyW':
                    moveDirection.current.z = -1;
                    break;
                case 'KeyS':
                    moveDirection.current.z = 1;
                    break;
                case 'KeyA':
                    moveDirection.current.x = -1;
                    break;
                case 'KeyD':
                    moveDirection.current.x = 1;
                    break;
                case 'Space':
                    moveDirection.current.y = 1;
                    break;
                case 'ShiftLeft':
                    moveDirection.current.y = -1;
                    break;
                default:
                    break;
            }
        };

        const handleKeyUp = (event) => {
            switch (event.code) {
                case 'KeyW':
                case 'KeyS':
                    moveDirection.current.z = 0;
                    break;
                case 'KeyA':
                case 'KeyD':
                    moveDirection.current.x = 0;
                    break;
                case 'Space':
                case 'ShiftLeft':
                    moveDirection.current.y = 0;
                    break;
                default:
                    break;
            }
        };

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        controls.current.camera.position.set(0, 1.5, 1);

        return () => {
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
        };
    }, []);

    useFrame((state, delta) => {
        if (moveDirection.current.x != 0 || moveDirection.current.y != 0 || moveDirection.current.z != 0) {
            const timeBasedSpeed = SPEED * delta;
            controls.current.getObject().translateX(moveDirection.current.x * timeBasedSpeed);
            controls.current.getObject().translateY(moveDirection.current.y * timeBasedSpeed * 0.5);
            controls.current.getObject().translateZ(moveDirection.current.z * timeBasedSpeed);
        }
        controls.current.getObject().updateMatrix();
        controls.current.getObject().updateMatrixWorld();
    });

    const handleOnLock = (e) => { crosshair.current.style.display = 'block'; };
    const handleOnUnlock = (e) => { crosshair.current.style.display = 'none'; };

    return &lt;PointerLockControls ref={controls} selector={'.do-not-use'} onLock={handleOnLock} onUnlock={handleOnUnlock} />;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="module transform-helpers" name="Transform Helpers">import * as THREE from 'three';



export const devicePositionWithOffset = (device, offset = 0) => {
    let x = 0;
    let y = 0;
    let z = 0;

    if (device) {
        let position = device.position;

        // If the distance option is given we move the position in the direction the device is looking
        if (offset != 0) {
            const direction = new THREE.Vector3(0, 0, -1);
            direction.normalize();
            direction.applyQuaternion(device.quaternion);

            position = new THREE.Vector3();
            position.copy(device.position).add(direction.multiplyScalar(offset));
        }

        x = position.x;
        y = position.y;
        z = position.z;
    }

    return [x, y, z];
};

export const deviceRotation = (device) => {
    let x = 0;
    let y = 0;
    let z = 0;

    if (device) {
        x = device.rotation._x;
        y = device.rotation._y;
        z = device.rotation._z;
    }

    return [x, y, z];
};

export const getDeviceFromInputEvent = (e) => {
    let device;

    if (e.nativeEvent?.inputSource?.handedness) {
        if (e.nativeEvent?.inputSource?.hand === null) {
            device = e.nativeEvent.inputSource.handedness === 'right' ? window.moduleDeviceManager.controllerRight?.object : window.moduleDeviceManager.controllerLeft?.object;
        } else {
            device = e.nativeEvent.inputSource.handedness === 'right' ? window.moduleDeviceManager.handRight?.object : window.moduleDeviceManager.handLeft?.object;
        }
    } else {
        device = window.moduleDeviceManager.camera;
    }

    if (!device) {
        console.warn('No device found.');
        return;
    } else {
        return device;
    }
};
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="module global-events" name="Global Events">import React from 'react';
const { useRef, useContext, createContext, useCallback, useMemo } = React;



// Send messages between components
if (!window.GlobalEventContext) window.GlobalEventContext = createContext();

export const GlobalEventProvider = ({ children }) => {
    const eventsRef = useRef({});

    const triggerEvent = useCallback((eventName, data) => {
        if (eventsRef.current[eventName]) {
            eventsRef.current[eventName].forEach(callback => callback(data));
        }
    }, []);

    const subscribeEvent = useCallback((eventName, callback) => {
        if (!eventsRef.current[eventName]) {
            eventsRef.current[eventName] = [];
        }
        eventsRef.current[eventName].push(callback);

        // Return unsubscribe function
        return () => {
            eventsRef.current[eventName] = eventsRef.current[eventName].filter(cb => cb !== callback);
        };
    }, []);

    // Memoize context value to avoid unnecessary rerenders
    const value = useMemo(() => ({
        triggerEvent,
        subscribeEvent,
    }), [triggerEvent, subscribeEvent]);

    return (
        &lt;GlobalEventContext.Provider value={value}>
            {children}
        &lt;/GlobalEventContext.Provider>
    );
};


export const useGlobalEvents = () => useContext(GlobalEventContext);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" class="component dynamic-components" name="Dynamic Components">import React from 'react';
const { useEffect, useState, useRef } = React;
import { ErrorBoundary } from 'react-error-boundary';



function DynamicComponent({ fragment }) {
    const [component, setComponent] = useState(null);
    const boundaryRef = useRef(null);

    const updateComponent = async () => {
        if (!fragment) return;
        const module = await fragment.require();
        const Main = module['Main'];
        setComponent(&lt;Main />);
        boundaryRef.current?.resetErrorBoundary();
    };

    useEffect(() => {
        fragment?.registerOnFragmentChangedHandler(updateComponent);
        updateComponent();

        return () => {
            fragment?.unRegisterOnFragmentChangedHandler(updateComponent);
        };
    }, [fragment]);

    return &lt;ErrorBoundary ref={boundaryRef} fallback={null}>
        {component}
    &lt;/ErrorBoundary>;
};

// This is a component that dynamically loads components from fragments
export function DynamicComponents({ selector }) {
    const [output, setOutput] = useState([]);
    const fragmentsMap = useRef(new Map());

    useEffect(() => {
        if (!selector) return;
        const query = cQuery(document).liveQuery(selector, {
            added: async (fragmentElement) => {
                const fragment = Fragment.one(fragmentElement);
                if (!fragment) return;

                fragmentsMap.current.set(fragment.uuid, fragment);
                setOutput(Array.from(fragmentsMap.current.entries()));
            },
            removed: (fragmentElement) => {
                const fragment = Fragment.one(fragmentElement);
                if (!fragment) return;

                fragmentsMap.current.delete(fragment.uuid);
                setOutput(Array.from(fragmentsMap.current.entries()));
            }
        });
        return () => {
            query.stop();
        };
    }, []);

    return output.map((entry) => {
        const [id, fragment] = entry;
        return &lt;DynamicComponent fragment={fragment} key={fragment.uuid} />;
    });
}
</CODE-FRAGMENT></CODE-FOLDER></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Basic" id><CODE-FOLDER name="Utils"><WPM-PACKAGE name="Icon" id="Icon"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A util for themed icons using custom 3D models",
    "dependencies": [],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Icon" class="default component">import React from 'react';
import { Clone } from '@react-three/drei';



export const SELECTED_COLOR_PRIMARY = 'hsl(14, 100%, 50%)';
export const SELECTED_COLOR_SECONDARY = 'hsl(26, 100%, 60%)';
export const HOVERED_SELECTED_COLOR_PRIMARY = 'hsl(14, 100%, 65%)';
export const HOVERED_SELECTED_COLOR_SECONDARY = 'hsl(26, 100%, 75%)';



export const themes = {
    '': { primary: 'rgb(255,0,255)', secondary: 'rgb(255,255,0)' },
    ':hovered': { primary: 'rgb(255,0,0)', secondary: 'rgb(255,0,0)' },
    ':selected': { primary: 'rgb(0,255,0)', secondary: 'rgb(255,0,0)' },
    ':selected:hovered': { primary: 'rgb(0,255,255)', secondary: 'rgb(255,0,0)' }
};



export function Icon(props) {
    const { model, theme = '', themesOverride = false } = props;
    if (model == null) return null;

    const finalThemes = themesOverride || themes;

    try {
        if (model.materials['Primary']) model.materials['Primary'].color.set(finalThemes[theme].primary);
        if (model.materials['Secondary']) model.materials['Secondary'].color.set(finalThemes[theme].secondary);
    } catch (ex) {
        console.log('Missing colour for ' + theme);
    }

    return &lt;group {...props}>
        &lt;Clone object={model ? model.scene : null} deep={'materialsOnly'} />
    &lt;/group>;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE name="Text" id="Text"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A helper component to globally control the font and text rendering.",
    "dependencies": [],
    "assets": [
        "inter-medium.woff"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Text Component" class="default component">import React from 'react';
import { Text as TextDrei } from '@react-three/drei';



// https://www.cdnfonts.com/
// Inter: https://fonts.cdnfonts.com/s/19795/Inter-Medium.woff
// Poppins: https://fonts.cdnfonts.com/s/16009/Poppins-Medium.woff



// Set Global Properties for the Text Component
export function Text(props) {
    const { children, ...rest } = props;
    return (
        &lt;TextDrei
            font="inter-medium.woff"
            {...rest}>
            {children}
        &lt;/TextDrei>
    );
}
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Components"><WPM-PACKAGE id="Menu" name="Menu"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple menu GUI for Spatialstrates",
    "dependencies": [
        "#Spatialstrates"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Menu" class="default component dynamic-gui-component">import React from 'react';
const { useState, useEffect } = React;



if (!window.moduleMenu) {
    window.moduleMenu = {
        subMenus: new Map(),
        menuNeedsUpdate: true
    };
}

class MenuItem {
    constructor(id, element, weight) {
        this.id = id;
        this.element = element;
        this.weight = weight;
    }
}

class SubMenu {
    constructor(id, weight, alwaysVisible = false) {
        this.id = id;
        this.weight = weight;
        this.alwaysVisible = alwaysVisible;
        this.items = new Map();
    }

    addItem(item) {
        this.items.set(item.id, item);
    }
}

export const addSubMenu = (id, weight, alwaysVisible) => {
    if (window.moduleMenu.subMenus.has(id)) {
        return window.moduleMenu.subMenus.get(id);
    }
    const subMenu = new SubMenu(id, weight, alwaysVisible);
    window.moduleMenu.subMenus.set(id, subMenu);
    window.moduleMenu.menuNeedsUpdate = true;
    return subMenu;
};

export const addItemToSubMenu = (subMenuId, id, element, weight) => {
    const menuItem = new MenuItem(id, element, weight);
    const subMenu = window.moduleMenu.subMenus.get(subMenuId);
    if (!subMenu) {
        console.error(`SubMenu ${subMenuId} not found`);
        return;
    }
    subMenu.addItem(menuItem);
    window.moduleMenu.menuNeedsUpdate = true;
    return menuItem;
};

export function MenuTitle({ title }) {
    return &lt;div className="title">{title}&lt;/div>;
}

export function MenuSpacer() {
    return &lt;div className="spacer">&lt;/div>;
}

export function MenuButton({ onClick, toggled, children, className }) {
    return &lt;button className={className} onClick={onClick} toggled={toggled ? 'true' : null} tabIndex="-1">{children}&lt;/button>;
}

/**
 * A heads-up display with buttons
 */
function Menu() {
    const [output, setOutput] = useState(null);

    const updateMenu = () => {
        const subMenus = Array.from(window.moduleMenu.subMenus.values());
        subMenus.sort((a, b) => a.weight - b.weight);

        setOutput(&lt;div className="floating-menus">
            {subMenus.map(subMenu => {
                const items = Array.from(subMenu.items.values());
                items.sort((a, b) => a.weight - b.weight);
                return &lt;div key={subMenu.id} className={`floating-menu${subMenu.alwaysVisible ? ' always-visible' : ''}`}>
                    {items.map((item, index) => {
                        const componentWithKey = React.cloneElement(item.element, { key: index });
                        return componentWithKey;
                    })}
                &lt;/div>;
            })}
        &lt;/div>);
    };

    useEffect(() => {
        if (window.moduleMenu.menuNeedsUpdate) {
            window.moduleMenu.menuNeedsUpdate = false;
            updateMenu();
        }
    });

    useEffect(() => {
        updateMenu();
    }, []);

    return output;
}



export function Main() {
    return &lt;Menu />;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Menu Style" auto>@mixin heading-font {
    font-weight: 500;
    font-size: 13px;
    letter-spacing: 0.25px;
}

.floating-menus {
    position: absolute;
    bottom: 8px;
    left: 8px;
    right: 8px;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    align-items: flex-end;
    justify-content: space-between;
    gap: 8px;
}

.floating-menu {
    z-index: 99999;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60) !important;
    border-radius: 12px;
    border: 1px solid #cccccc70;
    box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.025);
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 12px;
    flex: 0 1 192px;

    max-height: 40px;
    overflow: hidden;
    transition: max-height 500ms ease-in-out;

    &:hover:not(.always-visible) {
        max-height: initial;

        .title {
            order: 999;
        }
    }

    &.always-visible {
        max-height: initial;
    }

    .spacer {
        border-bottom: 1px solid #63636370;
        margin: 0 32px;
    }

    .title {
        @include heading-font;
        min-height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;

        user-select: none;
        text-align: center;
        cursor: default;
        color: #636363dd;
    }

    button {
        @include heading-font;
        min-height: 40px;

        user-select: none;
        border-radius: 4px;
        padding: 4px 8px;
        background: #63636390;
        color: #fff;
        vertical-align: middle;
        text-align: center;
        cursor: pointer;
        border: none;

        &:hover {
            background: #848484cc;
        }

        &:active {
            background: #606060cc;
        }

        &.red {
            background: #d32f2f90 !important;

            &:hover {
                background: #ff6659cc !important;
            }

            &:active {
                background: #9a0007cc !important;
            }
        }

        &.green {
            background: #2e7d3290 !important;

            &:hover {
                background: #61ad5ecc !important;
            }

            &:active {
                background: #005005cc !important;
            }
        }

        &[toggled="true"] {
            background: #FF910090 !important;
        }
    }

    .upload-drop-zone {
        @include heading-font;
        min-height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;

        user-select: none;
        text-align: center;
        cursor: pointer;
        background: #ddd;
        border-radius: 4px;

        &.upload-drop-zone--over {
            background: #ccc;
            cursor: copy;
        }
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ControllerMenu" name="ControllerMenu"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple controller menu for immersive XR",
    "dependencies": [
        "#Spatialstrates",
        "#Icon",
        "#Text"
    ],
    "assets": [
        "button.glb"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Controller Menu" id class="default component dynamic-scene-component">import React from 'react';
let { useState, useEffect, useMemo } = React;
import { useXRInputSourceState } from '@react-three/xr';
import { createPortal } from '@react-three/fiber';
import { useGLTF } from '@react-three/drei';

import { Icon } from "#Icon .default";
import { Text } from '#Text .default';



if (!window.moduleControllerMenu) {
    window.moduleControllerMenu = {
        menu: new Map(),
        menuNeedsUpdate: true
    };
}

class MenuItem {
    constructor(id, element) {
        this.id = id;
        this.element = element;
    }
}

export const addItem = (id, element) => {
    const menuItem = new MenuItem(id, element);
    window.moduleControllerMenu.menu.set(id, menuItem);
    window.moduleControllerMenu.menuNeedsUpdate = true;
    return menuItem;
};



const themes = {
    'button': { primary: 'hsl(200, 18%, 50%)', secondary: 'hsl(198, 16%, 84%)' },
    'button:hovered': { primary: 'hsl(200, 18%, 60%)', secondary: 'hsl(198, 16%, 84%)' },
    'button:disabled': { primary: 'rgb(0,0,0)', secondary: 'rgb(0,0,0)' },
    'button:toggled': { primary: 'hsl(200, 18%, 50%)', secondary: 'hsl(47, 100%, 63%)' },
    'button:toggled:hovered': { primary: 'hsl(200, 18%, 60%)', secondary: 'hsl(47, 100%, 73%)' },

    'deleteButton': { primary: 'hsl(0, 73%, 40%)', secondary: 'hsl(4, 90%, 60%)' },
    'deleteButton:hovered': { primary: 'hsl(0, 73%, 50%)', secondary: 'hsl(4, 90%, 70%)' }
};
useGLTF.preload('button.glb');



export function ControllerMenuButton({ position, name, theme = 'button', callback }) {
    const controllerButton = useGLTF('button.glb');
    const [hovered, setHovered] = useState();

    return &lt;group position={position} scale={hovered ? 1.1 : 1} autoUpdateMatrix={false}>
        &lt;Icon theme={theme + (hovered ? ':hovered' : '')}
            model={controllerButton}
            themesOverride={themes}
            onClick={callback}
            onPointerOver={() => setHovered(true)}
            onPointerOut={() => setHovered(false)} />
        &lt;Text
            position={[0, 0, 0.005]} autoUpdateMatrix={false}
            maxWidth={0.045}
            textAlign="center"
            anchorX="center"
            anchorY="middle"
            color="black"
            fontSize={0.007}>
            {name}
        &lt;/Text>
    &lt;/group>;
}

function ControllerMenu() {
    const [showMenu, setShowMenu] = useState(false);
    const [output, setOutput] = useState(null);

    // Attach the menu
    const controllerLeft = useXRInputSourceState('controller', 'left');
    const handLeft = useXRInputSourceState('hand', 'left');

    // FIXME: Sometimes the parent is not set correclty and the menu only shows when switching back and forth between hands
    const parent = useMemo(() => controllerLeft ? controllerLeft.object : handLeft ? handLeft.object : null, [controllerLeft, handLeft]);

    const menuGroup = useMemo(() => parent ? createPortal(&lt;group position={[0, 0.06, -0.15]} rotation={false ? [-Math.PI / 2, 0.2, 0.2] : [-Math.PI / 2, 0, 0]}>
        &lt;ControllerMenuButton position={[0, -0.06, 0]} name={'Show Menu'} callback={() => setShowMenu(!showMenu)} theme={showMenu ? 'button:toggled' : 'button'} />
        {showMenu ? output : null}
    &lt;/group>, parent) : null, [parent, output, showMenu, controllerLeft, handLeft]);

    const updateMenu = () => {
        setOutput(Array.from(window.moduleControllerMenu.menu.values())
            .sort((a, b) => a.weight - b.weight)
            .map(menuItem => menuItem.element));
    }

    useEffect(() => {
        if (window.moduleControllerMenu.menuNeedsUpdate) {
            window.moduleControllerMenu.menuNeedsUpdate = false;
            updateMenu();
        }
    });

    useEffect(() => {
        updateMenu();
    }, []);

    return menuGroup;
}



export function Main() {
    return &lt;ControllerMenu />;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="BasicMenu" name="BasicMenu"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Basic menu entries to move the camera and toggle XR",
    "dependencies": [
        "#Spatialstrates",
        "#Menu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Basic Menu" class auto>import React from 'react';
import {
    addSubMenu,
    addItemToSubMenu,
    MenuTitle,
    MenuSpacer,
    MenuButton
} from '#Menu .default';



const toggleAR = async () => {
    if (!navigator?.xr) {
        alert('WebXR is not supported by your browser.');
        return;
    }

    const sessionMode = 'immersive-ar';
    if (!await navigator.xr.isSessionSupported(sessionMode)) {
        alert('AR sessions are not supported by your browser.');
        return;
    }

    if (!window.xrStore) {
        console.warn('No xrStore found');
        return;
    }
    if (!window.xrStore.getState().session) {
        window.xrStore?.enterAR();
    } else {
        await window.xrStore.getState().session.end();
        window.xrStore.setState({ session: null });
    }
};

const toggleVR = async () => {
    if (!navigator?.xr) {
        alert('WebXR is not supported by your browser.');
        return;
    }

    const sessionMode = 'immersive-vr';
    if (!await navigator.xr.isSessionSupported(sessionMode)) {
        alert('VR sessions are not supported by your browser.');
        return;
    }

    if (!window.xrStore) {
        console.warn('No xrStore found');
        return;
    }
    if (!window.xrStore.getState().session) {
        window.xrStore?.enterVR();
    } else {
        await window.xrStore.getState().session.end();
        window.xrStore.setState({ session: null });
    }
};

const shareLink = () => {
    let sendToQuestUrl = new URL('https://oculus.com/open_url/');
    sendToQuestUrl.searchParams.set('url', location.protocol + '//' + location.host + location.pathname);
    window.open(sendToQuestUrl, '_blank');
};



addSubMenu('camera', 1000, true);
addItemToSubMenu('camera', 'move-camera', &lt;MenuButton className="mouse-lock" onClick={() => {
    if (!window.moduleCameraControls?.controlsRef?.current) return;
    if (!window.moduleCameraControls.controlsRef.current.isLocked) {
        window.moduleCameraControls.controlsRef.current.lock();
    } else {
        window.moduleCameraControls.controlsRef.current.unlock();
    }
}}>Move Camera&lt;/MenuButton>, 0);
addItemToSubMenu('camera', 'spacer1', &lt;MenuSpacer />, 1);
addItemToSubMenu('camera', 'toggle-ar', &lt;MenuButton onClick={toggleAR}>Toggle AR&lt;/MenuButton>, 2);
addItemToSubMenu('camera', 'toggle-vr', &lt;MenuButton onClick={toggleVR}>Toggle VR&lt;/MenuButton>, 3);


addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'title', &lt;MenuTitle title="Media Sharing" />, 0);
addItemToSubMenu('media-sharing', 'share-link', &lt;MenuButton onClick={shareLink}>Send to Quest&lt;/MenuButton>, 1000);
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER></CODE-FOLDER><CODE-FOLDER name="Add-ons"><CODE-FOLDER name="Utils"><WPM-PACKAGE name="AIHelpers" id="AIHelpers"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Helper functions to call the OpenAI API",
    "dependencies": [],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="AI Helpers" class="default module">export const recordAudio = (duration) => {
    return new Promise((resolve, reject) => {
        let chunks = [];

        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
            const mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = (event) => {
                chunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(chunks, { type: 'audio/wav' });
                resolve(audioBlob);
            };

            mediaRecorder.start();

            setTimeout(() => {
                mediaRecorder.stop();
            }, duration);
        }).catch(error => {
            reject(error);
        });
    });
};

export const transcribeAudio = async (duration, audioBlob = false, recordingEndedCallback = false) => {
    if (!window.API_KEY) {
        window.API_KEY = prompt('Please enter your OpenAI API key:');
        if (!window.API_KEY) {
            if (recordingEndedCallback) recordingEndedCallback();
            console.error('An API_KEY is required to transcribe audio.');
            return;
        }
    }

    let audioBlobToTranscribe = audioBlob;
    if (!audioBlobToTranscribe) {
        audioBlobToTranscribe = await recordAudio(duration);
    }

    if (recordingEndedCallback) recordingEndedCallback();

    const formData = new FormData();
    formData.append('file', audioBlobToTranscribe, 'recording.wav');
    formData.append('model', 'whisper-1');

    const whisperResponse = await fetch('https://api.openai.com/v1/audio/transcriptions', {
        method: 'POST',
        mode: 'cors',
        headers: { 'Authorization': `Bearer ${API_KEY}` },
        body: formData,
    });
    const whisperData = await whisperResponse.json();

    return whisperData.text;
};

export const sendGPTPrompt = async (body) => {
    if (!window.API_KEY) {
        window.API_KEY = prompt('Please enter your OpenAI API key:');
        if (!window.API_KEY) {
            console.error('An API_KEY is required to transcribe audio.');
            return;
        }
    }

    const options = {
        method: 'POST',
        mode: 'cors',
        headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${API_KEY}`
        },
        body: JSON.stringify(body)
    };
    console.log('OpenAI API call options:', options);

    const gptResponse = await fetch('https://api.openai.com/v1/chat/completions', options);
    const gptData = await gptResponse.json();
    return gptData;
};

export const getGPTContent = (gptData) => gptData.choices[0].message.content;
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Components"><WPM-PACKAGE id="SpatialstratesLogo" name="SpatialstratesLogo"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Spatialstrates logo with version information",
    "dependencies": [],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Spatialstrates App Header" class="component dynamic-gui-component">import React from 'react';
const { useState } = React;



export function Main() {
    const [showDialog, setShowDialog] = useState(false);

    return &lt;>
        &lt;div className="spatialstrates-title" onClick={() => setShowDialog(!showDialog)}>
            &lt;h1>Spatialstrates&lt;/h1>
        &lt;/div>
        {showDialog ? &lt;div className="spatialstrates-dialog-modal" onClick={() => setShowDialog(false)}>
            &lt;div className="spatialstrates-dialog" onClick={(e) => e.stopPropagation()}>
                &lt;h2>Spatialstrates&lt;/h2>
                &lt;p>Version 0.1.0 | &lt;a href="https://github.com/Webstrates/Spatialstrates" target="_blank">GitHub&lt;/a>&lt;/p>
            &lt;/div>
        &lt;/div> : null}
    &lt;/>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="Spatialstrates App Style" auto>.spatialstrates-title {
    position: fixed;
    top: 12px;
    left: 12px;
    z-index: 1000;
    padding: 4px 5px;
    border-radius: 4px;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    gap: 8px;
    height: 32px;
    user-select: none;
    cursor: pointer;

    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(242, 242, 242, .60) !important;
    border: 1px solid #cccccc70;
    box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.025);

    &:hover {
        background: rgba(242, 242, 242, .80) !important;
    }

    h1 {
        margin: 0;
        font-size: 22px;
        line-height: 32px;
        font-weight: 600;
        letter-spacing: -0.01em;
        padding-left: 4px;
        padding-right: 4px;
    }
}

.spatialstrates-dialog-modal {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    z-index: 100000;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(5px);
    background: rgba(192, 192, 192, .60) !important;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 12px;
}

.spatialstrates-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    padding: 20px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    border: 1px solid #cccccc70;
    background: #fafafa;
    box-shadow: 0 0 12px 0 rgba(0, 0, 0, 0.25);

    h2, p {
        margin: 0;
    }
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="CalibrationPoint" name="CalibrationPoint"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Calibration widget for immersive XR",
    "dependencies": [
        "#Spatialstrates",
        "#Icon"
    ],
    "assets": [
        "calibration_point.glb"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Calibration Point" id class="default component dynamic-scene-component">import React from 'react';
const { useRef } = React;
import { useFrame, useThree } from '@react-three/fiber';
import { useXRInputSourceEvent, useXRInputSourceState, IfInSessionMode } from '@react-three/xr';
import { useGLTF } from '@react-three/drei';
import * as THREE from 'three';

import { Icon } from "#Icon .default";



const themes = {
    'calibrationPoint': { primary: 'hsl(65, 100%, 40%)', secondary: 'hsl(200, 18%, 50%)' },
    'calibrationPoint:hovered': { primary: 'hsl(65, 100%, 60%)', secondary: 'hsl(200, 18%, 60%)' }
};
useGLTF.preload('calibration_point.glb');

/**
 * Move the entire scene view based on a calibration marker or a cube that can be moved around
*/
function CalibrationPoint() {
    const calibrateIcon = useGLTF('calibration_point.glb');
    let offsetUpdate = false;
    const grabbingController = useRef();
    const previousTransform = React.useMemo(() => new THREE.Matrix4(), [])
    const dragRef = useRef();

    // If a new offset has been set, inform the XR manager
    useFrame((state) => {
        if (offsetUpdate) {
            const referenceSpace = state.gl.xr.getReferenceSpace()
            state.gl.xr.setReferenceSpace(referenceSpace.getOffsetReferenceSpace(offsetUpdate));
            offsetUpdate = false;
        }

        const controller = grabbingController.current;
        if (!controller) return;

        dragRef.current.applyMatrix4(previousTransform);
        dragRef.current.applyMatrix4(controller.matrixWorld);
        dragRef.current.rotation.reorder('YXZ');
        dragRef.current.rotation.x = 0;
        dragRef.current.rotation.z = 0;
        dragRef.current.updateMatrixWorld();
        previousTransform.copy(controller.matrixWorld).invert();
    });

    // When the reference has moved, store the offset and reset it back (but not in height)
    const calibrate = () => {
        if (!dragRef.current) return;
        dragRef.current.rotation.reorder('YXZ');
        dragRef.current.rotation.x = 0;
        dragRef.current.rotation.z = 0;
        offsetUpdate = new XRRigidTransform({
            x: dragRef.current.position.x,
            y: 0,
            z: dragRef.current.position.z
        }, dragRef.current.quaternion);
        dragRef.current.rotation.y = 0;
        dragRef.current.position.x = 0;
        dragRef.current.position.z = 0;
    };

    const { camera } = useThree();
    const controllerRight = useXRInputSourceState('controller', 'right');
    const controllerLeft = useXRInputSourceState('controller', 'left');
    const handRight = useXRInputSourceState('hand', 'right');
    const handLeft = useXRInputSourceState('hand', 'left');

    useXRInputSourceEvent('all', 'selectend', (e) => {
        if (e.target.controller === grabbingController.current) {
            grabbingController.current = undefined;
            calibrate();
        }
    }, []);

    return &lt;>
        &lt;group ref={dragRef} onPointerDown={(e) => {
            if (grabbingController.current) return;
            if (e.nativeEvent?.inputSource) {
                if (e.nativeEvent.inputSource.hand === null) {
                    grabbingController.current = e.nativeEvent.inputSource.handedness === 'right' ? controllerRight?.object : controllerLeft?.object;
                } else {
                    grabbingController.current = e.nativeEvent.inputSource.handedness === 'right' ? handRight?.object : handLeft?.object;
                }
            } else if (e.nativeEvent?.button === 0) {
                grabbingController.current = camera;
            }
            if (grabbingController.current) {
                previousTransform.copy(grabbingController.current.matrixWorld).invert();
            }
        }}
            onPointerUp={() => {
                if (grabbingController.current) {
                    grabbingController.current = undefined;
                    calibrate();
                }
            }}>
            &lt;Icon theme="calibrationPoint" model={calibrateIcon} themesOverride={themes} />
        &lt;/group>
    &lt;/>;
}



export function Main() {
    return &lt;IfInSessionMode allow={['immersive-ar', 'immersive-vr']}>
        &lt;CalibrationPoint />
    &lt;/IfInSessionMode>;
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="UserManager" name="UserManager"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple user manager component",
    "dependencies": [
        "#Spatialstrates",
        "webstrate-components-repos MaterialDesignOutlinedIcons"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="User Manager Concepts" auto>{
    "concepts": {
        "UserManager": {
            "schema": {
                "placeholder": "string",
                "localUser": "User"
            },
            "mappings": {
                "localUser": [ "memory", "cauldron" ]
            }
        },
        "User": {
            "schema": {
                "name": "string"
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="User Manager Component" id class="default component dynamic-gui-component">import React from 'react';
const { useState, useEffect } = React;
import { Varv, useProperty } from '#VarvReact';



function UserRenamer() {
    const [name, setName] = useProperty('name');
    return &lt;label>
        Rename User
        &lt;input value={name ? name : ''} onChange={e => setName(e.target.value)} title='Rename User' />
    &lt;/label>;
}

function UserSelector({ selectUser }) {
    const [name] = useProperty('name');
    const [localUser] = useProperty('localUser');
    const [uuid] = useProperty('concept::uuid');

    const deleteUser = (e) => {
        e.stopPropagation();
        VarvEngine.getConceptFromType('User').delete(uuid);
    };

    return &lt;div className='user' local={localUser == uuid ? 'true' : null} onClick={() => selectUser(uuid)} title={'Select User ' + name}>
        &lt;span className="user-name">{name}&lt;/span>
        &lt;span className="delete-icon material-icons-outlined" onClick={deleteUser} title="Delete User">delete&lt;/span>
    &lt;/div>;
}

function Login() {
    const [enabled, setEnabled] = useState(false);
    const [localUser, setLocalUser] = useProperty('localUser');
    const userConcept = VarvEngine.getConceptFromType('User');

    useEffect(() => {
        if (localUser) return;

        const runAsync = async () => {
            const users = await VarvEngine.lookupInstances('User');
            try {
                if (users.length > 0) {
                    await setLocalUser(users[0]);
                } else {
                    const uuid = await userConcept.create(null, { name: 'Guest' });
                    await setLocalUser(uuid);
                }
            } catch (e) {
                // Sometimes there are timing issues with `setLocalUser`
            }
        };

        runAsync();
    }, [setLocalUser]);

    const addUser = async () => {
        setLocalUser(await userConcept.create(null, { name: 'User ' + Math.floor(Math.random() * 1000) }));
    };

    const selectUser = (userId) => {
        setLocalUser(userId);
    };

    return &lt;>
        {enabled ? &lt;div className="user-manager-modal" onClick={() => setEnabled(false)}>
            &lt;div className="user-manager" onClick={(e) => e.stopPropagation()}>
                &lt;div className="user-headline">User Selection&lt;/div>
                &lt;div className="user-menu">
                    &lt;button title="Add User" onClick={addUser}>Add User&lt;/button>
                    &lt;Varv property="localUser">
                        &lt;UserRenamer />
                    &lt;/Varv>
                &lt;/div>
                &lt;div className="user-list">
                    &lt;Varv concept="User">
                        &lt;UserSelector selectUser={selectUser} />
                    &lt;/Varv>
                &lt;/div>
            &lt;/div>
        &lt;/div> : null}

        &lt;div className="user-manager-button" onClick={() => setEnabled(true)}>User Manager&lt;/div>
    &lt;/>;
}

export function Main() {
    return &lt;Varv concept="UserManager">
        &lt;Login />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/x-scss" name="User Manager Style" auto>@mixin heading-font {
    font-weight: 500;
    font-size: 13px;
    letter-spacing: 0.25px;
}

.user-manager-button {
    @include heading-font;
    height: 24px;
    line-height: 24px;
    border-radius: 4px;
    padding: 0 8px;
    background: #ddd;
    position: fixed;
    top: 12px;
    right: 64px;
    z-index: 99999;
    cursor: pointer;
    user-select: none;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(10px);
    background: rgba(255, 255, 255, .60);
    border: 1px solid #cccccc70;

    &.enabled {
        background: rgba(96, 173, 94, .80);
        border: 1px solid rgba(96, 173, 94, .439);
        color: #fff;
    }
}

.user-manager-modal {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    z-index: 100000;
    -webkit-backdrop-filter: saturate(180%) blur(10px);
    backdrop-filter: saturate(180%) blur(5px);
    background: rgba(192, 192, 192, .60) !important;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 12px;

    button {
        @include heading-font;

        user-select: none;
        border-radius: 4px;
        padding: 2px 8px;
        background: #636363;
        color: #fff;
        vertical-align: middle;
        text-align: center;
        cursor: pointer;
        border: none;

        &:hover {
            background: #848484;
        }

        &:active {
            background: #606060;
        }

        &.red {
            background: #d32f2f !important;

            &:hover {
                background: #ff6659 !important;
            }

            &:active {
                background: #9a0007 !important;
            }
        }

        &.green {
            background: #2e7d32 !important;

            &:hover {
                background: #60ad5e !important;
            }

            &:active {
                background: #005005 !important;
            }
        }
    }

    label {
        @include heading-font;

        user-select: none;
        white-space: nowrap;

        background: #eeeeee;
        color: #000000;

        border-radius: 4px;
        padding-left: 8px;
        padding-right: 8px;
        padding-right: 0;

        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        align-items: center;
        gap: 4px;

        input[type="checkbox"] {
            width: 24px;
        }

        input:not([type="checkbox"]),
        select {
            border-top-left-radius: 16px;
            border-bottom-left-radius: 16px;
            height: 100%;
        }
    }

    input:not([type="checkbox"]),
    select,
    textarea {
        border-radius: 4px;
        border: none;
        padding: 0 8px;
        text-overflow: ellipsis;
        outline: none;
        color: #000;
        width: 100%;
    }

    .user-manager {
        background: #fafafa;
        border-radius: 8px;
        padding: 16px;
        display: flex;
        flex-direction: column;
        flex-wrap: nowrap;
        gap: 12px;
        max-width: 100%;
        box-shadow: 0 0 12px 0 rgba(0, 0, 0, 0.25);
    }


    .user-headline {
        font-size: 24px;
        font-weight: 700;
        cursor: default;
        user-select: none;
    }

    .user-menu {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 8px;
        min-height: 32px;
        padding: 8px;
        border-radius: 4px;
        background: #ddd;
    }

    .user-list {
        display: flex;
        flex-direction: row;
        gap: 8px;
        padding: 8px;
        border-radius: 4px;
        background: #ddd;
    }

    .user {
        height: 32px;
        cursor: pointer;
        border-radius: 20px;
        background: #eeeeee;
        user-select: none;
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 8px;
        align-items: center;

        .user-name {
            padding-left: 8px;
        }

        .delete-icon {
            font-size: 20px;
            text-align: center;
            line-height: 32px;
            cursor: pointer;
            background: #d32f2f;
            color: #fff;
            border-radius: 50%;
            width: 32px;
            height: 32px;
        }
    }

    .user[local="true"] {
        background: #FFAB40;
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Init Manager Concept" auto>const initConcept = async () => {
    try {
        const managers = await VarvEngine.lookupInstances('UserManager');
        if (managers.length == 0) {
            await VarvEngine.getConceptFromType('UserManager').create(null, {});
        }
    } catch (e) {
        // Ignore
    }
};

VarvEngine.registerEventCallback('engineReloaded', () => {
    initConcept();
});

initConcept();
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Avatar" name="Avatar"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Awareness avatars for remote users",
    "dependencies": [
        "varv-repos varv-signaling",
        "#Spatialstrates",
        "#Text",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [
        "avatar-models.zip"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Avatar Concepts" auto>{
    "concepts": {
        "AvatarManager": {
            "schema": {
                "enabled": "boolean"
            }
        },
        "Avatar": {
            "schema": {
                "type": {
                    "string":{
                        "default": "camera",
                        "enum": [ "camera", "controllerLeft", "controllerRight", "handLeft", "handRight" ]
                    }
                },
                "userAgent": "string",
                "inputSourceProfile": "string",
                "client": "string",
                "clientVideoStream": { "array": {
                    "items": "VideoStream",
                    "derive": {
                        "concepts": [ "VideoStream" ],
                        "properties": [ "client" ],
                        "transform": [
                            { "get": { "property": "client", "as": "client" }},
                            { "select": {
                                "concept": "VideoStream",
                                "where": { "property": "client", "equals": "$client" },
                                "keepContext": true
                            }}
                        ]
                    }
                }},
                "userName": "string",
                "isMine": "boolean",
                "position": { "array": {
                    "items": "number",
                    "default": [ 0, 0, 0 ]
                }},
                "rotation": { "array": {
                    "items": "number",
                    "default": [ 0, 0, 0 ]
                }},
                "remoteControlled": "boolean",
                "remoteControllingClient": "string"
            },
            "defaultMappings": [ "signaling", "memory", "cauldron" ],
            "mappings": {
                "isMine": [ "memory", "cauldron" ]
            }
        }
    },
    "dataStores": {
        "signaling": { "type": "signaling" }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Avatar" class="default component dynamic-scene-component" id>import React from 'react';
let { useState, useEffect } = React;
import { Cone, Gltf, useGLTF } from '@react-three/drei';
import { useXR } from '@react-three/xr';
import { useFrame, useThree } from '@react-three/fiber';

import { Varv, useProperty } from '#VarvReact';
import { Text } from '#Text .default';
let VideoStream;
if (Fragment.one('#VideoStream .default')) {
    const videoStreamModule = await Fragment.one('#VideoStream .default').require();
    VideoStream = videoStreamModule.VideoStream;
}



useGLTF.preload("avatar-models.zip/model-camera.glb");
useGLTF.preload("avatar-models.zip/model-phone.glb");
useGLTF.preload("avatar-models.zip/model-headset.glb");
useGLTF.preload("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/meta-quest-touch-plus/left.glb");
useGLTF.preload("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/meta-quest-touch-plus/right.glb");
useGLTF.preload("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/generic-hand/left.glb");
useGLTF.preload("https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/generic-hand/right.glb");

const cameraModel = &lt;Gltf src="avatar-models.zip/model-camera.glb" scale={1} rotation={[0, Math.PI, 0]} />;
const phoneModel = &lt;Gltf src="avatar-models.zip/model-phone.glb" scale={0.01} />;
const headsetModel = &lt;Gltf src="avatar-models.zip/model-headset.glb" scale={0.9} rotation={[0, Math.PI, 0]} position={[0, 0.04, 0.11]} />;

const controllerLeftModel = &lt;Gltf src="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/meta-quest-touch-plus/left.glb" scale={1} rotation={[Math.PI / 4, 0, 0]} />;
const controllerRightModel = &lt;Gltf src="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/meta-quest-touch-plus/right.glb" scale={1} rotation={[Math.PI / 4, 0, 0]} />;
const handLeftModel = &lt;Gltf src="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/generic-hand/left.glb" scale={0.01} />;
const handRightModel = &lt;Gltf src="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.16/dist/profiles/generic-hand/right.glb" scale={0.01} />;

const viewCone = &lt;Cone args={[0.1, 0.1, 32]} position={[0, 0, -0.05]} rotation={[Math.PI / 2, 0, 0]}>
    &lt;meshStandardMaterial color="skyblue" transparent={true} opacity={0.66} />
&lt;/Cone>;



function Avatar() {
    const [type] = useProperty('type');
    const [userAgent] = useProperty('userAgent');
    const [inputSourceProfile] = useProperty('inputSourceProfile');
    const [position] = useProperty('position');
    const [rotation] = useProperty('rotation');
    const [userName] = useProperty('userName');
    const [client] = useProperty('client');

    const [remoteControlled, setRemoteControlled] = useProperty('remoteControlled');
    const [remoteControllingClient, setRemoteControllingClient] = useProperty('remoteControllingClient');

    const [model, setModel] = useState(cameraModel);

    useEffect(() => {
        switch (type) {
            case 'camera':
                if (userAgent.includes('OculusBrowser')) {
                    setModel(&lt;> {headsetModel} {viewCone} &lt;/>);
                } else if (/(iPad|iPhone|iPod|Android)/i.test(userAgent)) {
                    setModel(&lt;> {phoneModel} {viewCone} &lt;/>);
                } else {
                    setModel(&lt;> {cameraModel} {viewCone} &lt;/>);
                }
                break;
            // TODO: Use the inputSourceProfile to determine the correct model
            case 'controllerLeft':
                setModel(controllerLeftModel);
                break;
            case 'controllerRight':
                setModel(controllerRightModel);
                break;
            case 'handLeft':
                setModel(handLeftModel);
                break;
            case 'handRight':
                setModel(handRightModel);
                break;
            default:
                setModel(cameraModel);
        }
    }, [type, userAgent, inputSourceProfile]);

    const remoteControlCallback = (newValue) => {
        // TODO: This feature needs to be re-implemented
        setRemoteControlled(newValue);
        setRemoteControllingClient(newValue ? webstrate.clientId : '');
    };

    return &lt;group position={position} rotation={rotation}>
        {type == 'camera' ? &lt;group
            onPointerDown={() => remoteControlCallback(true)}
            onPointerUp={() => remoteControlCallback(false)}>
            {model}
        &lt;/group> : model}
        {VideoStream ? &lt;Varv property="clientVideoStream">
            &lt;VideoStream client={client} />
        &lt;/Varv> : null}
        {type == 'camera' ? &lt;Text
            position={[0, 0.11, 0]}
            rotation={[0, Math.PI, 0]}
            textAlign="center"
            anchorX="center"
            anchorY="middle"
            color="black"
            outlineWidth="5%"
            outlineColor="white"
            fontSize={0.05}>
            {userName}
        &lt;/Text> : null}
    &lt;/group >;
}

function AvatarRemoteController() {
    const [remoteControlled] = useProperty('remoteControlled');
    const [position] = useProperty('position');
    const [rotation] = useProperty('rotation');

    const camera = useThree(state => state.camera);

    useFrame(() => {
        if (remoteControlled) {
            camera.position.set(position[0], position[1], position[2]);
            camera.rotation.set(rotation[0], rotation[1], rotation[2]);
        }
    });
}

function Avatars() {
    return &lt;>
        &lt;Varv concept="Avatar" if="!isMine">
            &lt;Avatar />
        &lt;/Varv>
        &lt;Varv concept="Avatar" if="isMine">
            &lt;AvatarRemoteController />
        &lt;/Varv>
    &lt;/>;
}



export function Main() {
    return &lt;Varv concept="AvatarManager" if="enabled">
        &lt;Avatars />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Avatar Transmitter" id class="component dynamic-scene-component">import React from 'react';
let { useEffect, useRef } = React;
import { useXRInputSourceState } from '@react-three/xr';
import { useFrame, useThree } from '@react-three/fiber';
import { Varv } from '#VarvReact';



// Remove other people's Avatars when clients leave or join
const cleanup = () => {
    setTimeout(async () => {
        const concept = await VarvEngine.getConceptFromType('Avatar');
        const avatars = await VarvEngine.lookupInstances('Avatar');
        for (let avatar of avatars) {
            if (!webstrate.clients.includes(await concept.getPropertyValue(avatar, 'client'))) {
                concept.delete(avatar);
            }
        }
    }, 0);
};

const SLOW_WRITEBACK_TIMEOUT = 500;
function AvatarTransmitter({ device, type, inputSourceProfiles }) {
    const conceptRef = useRef(null);
    const avatarConcept = VarvEngine.getConceptFromType('Avatar');

    useEffect(() => {
        if (!device) return;

        const avatarFilter = FilterAction.constructFilter({
            and: [
                {
                    property: 'type',
                    equals: type
                },
                {
                    property: 'client',
                    equals: webstrate.clientId
                }
            ]
        });

        const runAsync = async () => {
            let uuid;
            const ids = await VarvEngine.lookupInstances('Avatar', avatarFilter);

            if (ids.length > 0) {
                // Reuse existing concept if available
                uuid = ids[0];
            } else {
                // Otherwise create a new one
                uuid = await avatarConcept.create(null, {
                    type: type,
                    userAgent: window.navigator.userAgent,
                    client: webstrate.clientId,
                    userName: webstrate.user.displayName || 'Anonymous',
                    inputSourceProfile: inputSourceProfiles ? JSON.stringify(inputSourceProfiles) : '',
                    isMine: true
                });
            }
            conceptRef.current = uuid;
        };

        runAsync();
    }, [device, type]);

    const slowWritebackTimeout = useRef(null);
    useFrame(() => {
        if (!device) return;
        if (!conceptRef.current) return;

        if (!slowWritebackTimeout.current) {
            avatarConcept.setPropertyValue(conceptRef.current, 'position', device.position.toArray());
            avatarConcept.setPropertyValue(conceptRef.current, 'rotation', [device.rotation.x, device.rotation.y, device.rotation.z]);

            slowWritebackTimeout.current = setTimeout(() => {
                slowWritebackTimeout.current = null;
            }, SLOW_WRITEBACK_TIMEOUT);
        }
    });
}

function AvatarTransmitters() {
    const { camera } = useThree();
    const controllerRight = useXRInputSourceState('controller', 'right');
    const controllerLeft = useXRInputSourceState('controller', 'left');
    const handRight = useXRInputSourceState('hand', 'right');
    const handLeft = useXRInputSourceState('hand', 'left');

    // Ensure that Avatars are updated in the environement
    useEffect(() => {
        webstrate.on('clientPart', cleanup);
        cleanup();
        return () => webstrate.off('clientPart', cleanup);
    }, []);

    return &lt;>
        &lt;AvatarTransmitter device={camera} type="camera" />
        {controllerRight ? &lt;AvatarTransmitter device={controllerRight?.object} type="controllerRight" inputSourceProfiles={controllerRight.profiles} /> : null}
        {controllerLeft ? &lt;AvatarTransmitter device={controllerLeft?.object} type="controllerLeft" inputSourceProfiles={controllerLeft.profiles} /> : null}
        {handRight ? &lt;AvatarTransmitter device={handRight?.object} type="handRight" inputSourceProfiles={handRight.profiles} /> : null}
        {handLeft ? &lt;AvatarTransmitter device={handLeft?.object} type="handLeft" inputSourceProfiles={handLeft.profiles} /> : null}
    &lt;/>;
}



export function Main() {
    return &lt;Varv concept="AvatarManager" if="enabled">
        &lt;AvatarTransmitters />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Avatar Menu" class auto>import React from 'react';
import {
    addSubMenu,
    addItemToSubMenu,
    MenuTitle,
    MenuSpacer,
    MenuButton
} from '#Menu .default';
import {
    addItem,
    ControllerMenuButton
} from '#ControllerMenu .default';
import { Varv, useProperty } from '#VarvReact';



function AvatarToggleButton() {
    const [enabled, setEnabled] = useProperty('enabled');
    return &lt;MenuButton onClick={() => setEnabled(!enabled)} toggled={enabled ? 'true' : null}>Toggle Avatars ({enabled ? 'On' : 'Off'})&lt;/MenuButton>;
}

addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'title', &lt;MenuTitle title="Media Sharing" />, 0);
addItemToSubMenu('media-sharing', 'avatars', &lt;Varv concept="AvatarManager">
    &lt;AvatarToggleButton />
&lt;/Varv>, 750);
addItemToSubMenu('media-sharing', 'spacer4', &lt;MenuSpacer />, 800);

function AvatarToggleControllerButton() {
    const [enabled, setEnabled] = useProperty('enabled');
    return &lt;ControllerMenuButton position={[-0.18, 0.06, 0]} name={'Toggle Avatars'} theme={enabled ? 'button:toggled' : null} callback={() => setEnabled(!enabled)} />;
}

addItem('avatars', &lt;Varv concept="AvatarManager">
    &lt;AvatarToggleControllerButton />
&lt;/Varv>);
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Init Manager Concept" auto>const initConcept = async () => {
    try {
        const managers = await VarvEngine.lookupInstances('AvatarManager');
        if (managers.length == 0) {
            await VarvEngine.getConceptFromType('AvatarManager').create(null, {});
        }
    } catch (e) {
        // Ignore
    }
};

VarvEngine.registerEventCallback('engineReloaded', () => {
    initConcept();
});

initConcept();
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER></CODE-FOLDER><CODE-FOLDER name="Streaming" id><CODE-FOLDER name="Utils"><WPM-PACKAGE name="StreamManager" id="StreamManager"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A generic stream sharing class for Webstrate servers with stream signaling support",
    "dependencies": [],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Stream Manager" id class="default module">const DEBUG = false;



export class StreamShare {
    /**
     * Creates a streamshare using the given element to signal
     * addition and removal of streams. Up to one stream per client
     * is possible for each element.
     */
    constructor(element) {
        let self = this;
        this.clientStreams = new Map();
        this.addedListeners = [];
        if (!element) throw new Error('Must provide an actual DOM element for signalling, was ', element);
        if (element.parentElement === undefined) throw new Error('StreamShare element must be in DOM');
        this.supported = true;
        if (!(element.webstrate && element.webstrate.signalStream)) {
            this.supported = false;
            if (DEBUG) console.log('StreamShare: The webstrate implementation or element does not support webstrate stream signalling, stream sharing is disabled', element);
            return;
        }
        this.element = element;

        this.element.webstrate.on('signalStream', function onSignalStream(clientId, meta, accept) {
            let con = accept(function (stream) {
                if (self.clientStreams.get(clientId)) {
                    if (DEBUG) console.log('StreamShare: Warning: Only one stream per client is supported per element but ' + clientId + ' shared another one...');
                }
                self.clientStreams.set(clientId, stream);
                self._onStreamAdded(clientId, stream);
            });
        });
    }

    stopSharing() {
        if (this.currentSignallingFunction) {
            this.element.webstrate.stopStreamSignal(this.currentSignallingFunction);
            this.currentSignallingFunction = null;
        }
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
            this.currentStream = null;
        }
    }

    async shareStream(media, displayOptions = null) {
        let self = this;
        if (!this.supported) {
            console.log('Tried to share a stream on an unsupported StreamShare, see previous warnings');
            return;
        }

        // Get the stream
        if (!displayOptions) {
            console.error('displayOptions are required to share a stream.');
        }

        if (this.currentStream) {
            this.stopSharing();
        }
        if (media == 'displayMedia') {
            this.currentStream = await navigator.mediaDevices.getDisplayMedia(displayOptions);
        } else {
            this.currentStream = await navigator.mediaDevices.getUserMedia(displayOptions);
        }
        this.currentSignallingFunction = function signalStream(clientId, accept) {
            let con = accept(self.currentStream, {}, () => {
                if (DEBUG) console.log('StreamShare: client ' + clientId + ' started receiving our streamshare');
            });
            con.onclose(() => {
                if (DEBUG) console.log('StreamShare: client ' + clientId + ' stopped receiving our streamshare');
            });
        };

        // Register the stream on the element
        if (DEBUG) console.log('StreamShare: Starting streamshare');
        this._onStreamAdded(webstrate.clientId, this.currentStream);
        this.element.webstrate.signalStream(this.currentSignallingFunction);
        return this.currentStream;
    }

    _onStreamAdded(client, stream) {
        // Notify listeners
        this.clientStreams.set(client, stream);
        this.addedListeners.forEach(listener => {
            listener(client, stream);
        });
    }
    addStreamAddedListener(listener) {
        this.addedListeners.push(listener);

        // Backfill with current streams
        for (let [key, value] of this.clientStreams) {
            listener(key, value);
        }
    }
    removeStreamAddedListener(listener) {
        const index = this.addedListeners.indexOf(listener);
        if (index > -1) {
            this.addedListeners.splice(index, 1);
        }
    }
}

if (!window.moduleStreamManager) {
    window.moduleStreamManager = {
        clicked: false,
        cleanupConceptTypes: []
    };
    document.addEventListener('click', () => { window.moduleStreamManager.clicked = true; });

    const cleanup = async () => {
        // Remove screenshares when a client leaves or joins
        for (const conceptType in window.moduleStreamManager.cleanupConceptTypes) {
            if (webstrate.clients.length &lt; 1) return;
            let concept = VarvEngine.getConceptFromType(conceptType);
            let shares = await (VarvEngine.lookupInstances(conceptType));
            shares.filter(share => !webstrate.clients.includes(concept.getPropertyValue(share, 'client'))).forEach(share => { concept.delete(share); });
        }
    };

    webstrate.on('clientPart', cleanup);
    webstrate.on('clientJoin', cleanup);
}

export const doIfClicked = (callback) => {
    if (window.moduleStreamManager.clicked) {
        setTimeout(() => {
            callback();
        }, 200);
    } else {
        document.addEventListener('click', () => {
            callback();
        });
    }
};

export const addCleanupConceptType = (type) => {
    window.moduleStreamManager.cleanupConceptTypes.push(type);
};
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="ScreenStreamManager" name="ScreenStreamManager"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stream manager for screen share streams",
    "dependencies": [
        "#StreamManager"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Screen Stream Manager" id class="default module">import { doIfClicked, StreamShare, addCleanupConceptType } from '#StreamManager .default';



const STREAM_ELEMENT = 'screen-signaling';
let DOM_ELEMENT = document.querySelector(STREAM_ELEMENT);
if (!DOM_ELEMENT) {
    DOM_ELEMENT = document.createElement(STREAM_ELEMENT);
    document.body.appendChild(DOM_ELEMENT);
    WPMv2.stripProtection(DOM_ELEMENT);
}
const CONCEPT_NAME = 'ScreenStream';
const ID_PREFIX = CONCEPT_NAME + '-';
export const QUERY_PREFIX = '#' + ID_PREFIX;



// Hook up new streams with a video element
if (!window.moduleScreenStreamManager) {
    window.moduleScreenStreamManager = {
        streamShare: new StreamShare(DOM_ELEMENT)
    };

    addCleanupConceptType(CONCEPT_NAME);

    window.moduleScreenStreamManager.streamShare.addStreamAddedListener((client, stream) => {
        console.log('Got screenStream from ' + client);

        // Find or create their element
        let element = document.querySelector(QUERY_PREFIX + client);
        if (!element) {
            element = document.createElement('video');
            element.style.position = 'fixed';
            element.style.width = '0px';
            element.id = ID_PREFIX + client;
            element.muted = true;
            document.body.appendChild(element);
        }
        element.srcObject = stream;
        doIfClicked(() => { element.play(); });
    });

    // Convenience functions for managing Varv spawning and despawning
    window.stopSharingMyScreen = async () => {
        window.moduleScreenStreamManager.streamShare.stopSharing();
        const concept = VarvEngine.getConceptFromType(CONCEPT_NAME);
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        instances.forEach(instance => concept.delete(instance));
    };
    window.shareMyScreen = async () => {
        const stream = await window.moduleScreenStreamManager.streamShare.shareStream('displayMedia', {
            video: {
                displaySurface: 'browser',
            },
            audio: {
                suppressLocalAudioPlayback: false,
            },
            preferCurrentTab: false,
            selfBrowserSurface: 'exclude',
            systemAudio: 'exclude',
            surfaceSwitching: 'include',
            monitorTypeSurfaces: 'include',
        });
        if (stream) {
            stream.getVideoTracks()[0].addEventListener('ended', () => {
                window.stopSharingMyScreen();
            });
            return VarvEngine.getConceptFromType(CONCEPT_NAME).create(null, { client: webstrate.clientId });
        }
    };
}

export const streamShare = window.moduleScreenStreamManager.streamShare;
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="VideoStreamManager" name="VideoStreamManager"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stream manager for camera video streams",
    "dependencies": [
        "#StreamManager"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Video Stream Manager" id class="default module">import { doIfClicked, StreamShare, addCleanupConceptType } from '#StreamManager .default';



const STREAM_ELEMENT = 'video-signaling';
let DOM_ELEMENT = document.querySelector(STREAM_ELEMENT);
if (!DOM_ELEMENT) {
    DOM_ELEMENT = document.createElement(STREAM_ELEMENT);
    document.body.appendChild(DOM_ELEMENT);
    WPMv2.stripProtection(DOM_ELEMENT);
}
const CONCEPT_NAME = 'VideoStream';
const ID_PREFIX = CONCEPT_NAME + '-';
export const QUERY_PREFIX = '#' + ID_PREFIX;



// Hook up new streams with a video element
if (!window.moduleVideoStreamManager) {
    window.moduleVideoStreamManager = {
        streamShare: new StreamShare(DOM_ELEMENT)
    };

    addCleanupConceptType(CONCEPT_NAME);

    window.moduleVideoStreamManager.streamShare.addStreamAddedListener((client, stream) => {
        console.log('Got videoStream from ' + client);

        // Find or create their element
        let element = document.querySelector(QUERY_PREFIX + client);
        if (!element) {
            element = document.createElement('video');
            element.style.position = 'fixed';
            element.style.width = '0px';
            element.id = ID_PREFIX + client;
            element.muted = true;
            document.body.appendChild(element);
        }
        element.srcObject = stream;
        doIfClicked(() => { element.play(); });
    });

    // Convenience functions for managing Varv spawning and despawning
    window.stopSharingMyVideo = async () => {
        window.moduleVideoStreamManager.streamShare.stopSharing();
        const concept = VarvEngine.getConceptFromType(CONCEPT_NAME);
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        instances.forEach(instance => concept.delete(instance));
    };
    window.shareMyVideo = async () => {
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        if (instances.length > 0) {
            console.log('Already sharing video');
            return;
        }
        const stream = await window.moduleVideoStreamManager.streamShare.shareStream('userMedia', {
            video: true,
            audio: false
        });
        if (stream) {
            stream.getVideoTracks()[0].addEventListener('ended', () => {
                window.stopSharingMyVideo();
            });
            return VarvEngine.getConceptFromType(CONCEPT_NAME).create(null, { client: webstrate.clientId });
        }
    };
}

export const streamShare = window.moduleVideoStreamManager.streamShare;
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="AudioStreamManager" name="AudioStreamManager"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stream manager for audio streams",
    "dependencies": [
        "#StreamManager"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Audio Stream Manager" id class="default module">import { doIfClicked, StreamShare, addCleanupConceptType } from '#StreamManager .default';



const STREAM_ELEMENT = 'audio-signaling';
let DOM_ELEMENT = document.querySelector(STREAM_ELEMENT);
if (!DOM_ELEMENT) {
    DOM_ELEMENT = document.createElement(STREAM_ELEMENT);
    document.body.appendChild(DOM_ELEMENT);
    WPMv2.stripProtection(DOM_ELEMENT);
}
const CONCEPT_NAME = 'AudioStream';
const ID_PREFIX = CONCEPT_NAME + '-';
export const QUERY_PREFIX = '#' + ID_PREFIX;



// Hook up new streams with a video element
if (!window.moduleAudioStreamManager) {
    window.moduleAudioStreamManager = {
        streamShare: new StreamShare(DOM_ELEMENT)
    };

    addCleanupConceptType(CONCEPT_NAME);

    window.moduleAudioStreamManager.streamShare.addStreamAddedListener((client, stream) => {
        console.log('Got audioStream from ' + client);

        // Find or create their element
        let element = document.querySelector(QUERY_PREFIX + client);
        if (!element) {
            element = document.createElement('video');
            element.style.position = 'fixed';
            element.style.width = '0px';
            element.id = ID_PREFIX + client;
            element.muted = client == webstrate.clientId;
            document.body.appendChild(element);
        }
        element.srcObject = stream;
        doIfClicked(() => { element.play(); });
    });

    // Convenience functions for managing Varv spawning and despawning
    window.stopSharingMyAudio = async () => {
        window.moduleAudioStreamManager.streamShare.stopSharing();
        const concept = VarvEngine.getConceptFromType(CONCEPT_NAME);
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        instances.forEach(instance => concept.delete(instance));
    };
    window.shareMyAudio = async () => {
        const instances = await VarvEngine.lookupInstances(CONCEPT_NAME, new FilterProperty('client', FilterOps.equals, webstrate.clientId));
        if (instances.length > 0) {
            console.log('Already sharing audio');
            return;
        }
        const stream = await window.moduleAudioStreamManager.streamShare.shareStream('userMedia', {
            video: false,
            audio: true
        });
        if (stream) {
            stream.getAudioTracks()[0].addEventListener('ended', () => {
                window.stopSharingMyAudio();
            });
            return VarvEngine.getConceptFromType(CONCEPT_NAME).create(null, { client: webstrate.clientId });
        }
    };
}



export const streamShare = window.moduleAudioStreamManager.streamShare;
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Components"><WPM-PACKAGE id="ScreenStream" name="ScreenStream"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stream component for screen streams",
    "dependencies": [
        "#Movable",
        "#StreamManager",
        "#ScreenStreamManager",
        "#Menu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Screen Stream Concepts" auto>{
    "concepts": {
        "ScreenStream": {
            "schema": {
                "client": "string"
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Screen Stream" class="default component dynamic-scene-component">import React from 'react';
const { useState, useEffect, useMemo } = React;
import { BoxGeometry, MeshStandardMaterial, PlaneGeometry, LinearMipmapLinearFilter } from 'three';
import * as THREE from 'three';
import { Plane } from '@react-three/drei';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { Varv, useProperty } from '#VarvReact';

import { Movable, SELECTED_COLOR_PRIMARY, HOVERED_SELECTED_COLOR_PRIMARY } from '#Movable .default';
import { doIfClicked } from '#StreamManager .default';
import { QUERY_PREFIX, streamShare } from '#ScreenStreamManager .default';


const MAX_SIZE = 0.75;

const frameGeometry = new RoundedBoxGeometry(1, 1, 0.005, 1);
const frameMaterial = new MeshStandardMaterial({ color: '#E0E0E0', metalness: 0.2, roughness: 0.5 });
const frameMaterialHovered = new MeshStandardMaterial({ color: '#FFFFFF', metalness: 0.2, roughness: 0.5 });
const frameMaterialSelected = new MeshStandardMaterial({ color: SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });
const frameMaterialHoveredSelected = new MeshStandardMaterial({ color: HOVERED_SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });



function ScreenStream() {
    const [client] = useProperty('client');

    const [screen, setScreen] = useState(document.querySelector(QUERY_PREFIX + client));
    const [width, setWidth] = useState(MAX_SIZE);
    const [height, setHeight] = useState(MAX_SIZE);

    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');

    const updateSize = (aspectRatio) => {
        if (aspectRatio > 1) {
            setWidth(MAX_SIZE);
            setHeight(MAX_SIZE / aspectRatio);
        } else {
            setWidth(MAX_SIZE * aspectRatio);
            setHeight(MAX_SIZE);
        }
    };

    useEffect(() => {
        if (screen) {
            // Playing immediately may fail, wait for interaction in that case
            doIfClicked(() => {
                updateSize(screen.videoWidth / screen.videoHeight || 1);
                screen.addEventListener('resize', () => {
                    updateSize(screen.videoWidth / screen.videoHeight || 1);
                })
            });
        }

        // Make sure to catch stream updates
        let listener = function (newStreamId) {
            if (newStreamId == client) setScreen(document.querySelector(QUERY_PREFIX + client));
        };
        streamShare.addStreamAddedListener(listener);

        return () => {
            streamShare.removeStreamAddedListener(listener);
        }
    }, [screen, client]);

    const texture = useMemo(() => screen ? &lt;videoTexture attach='map' args={[screen]} anisoptry={16} generateMipmaps={true} minFilter={THREE.LinearMipmapLinearFilter} colorSpace={THREE.SRGBColorSpace} /> : null, [screen]);

    const handle = useMemo(() => &lt;mesh
        geometry={frameGeometry}
        material={selected ? (hovered ? frameMaterialHoveredSelected : frameMaterialSelected) : (hovered ? frameMaterialHovered : frameMaterial)}
        scale={[width + 0.02, height + 0.02, 1]}
        position={[0, 0.125 - 0.0125, -0.0055]}
        autoUpdateMatrix={false}>
    &lt;/mesh>, [width, height, selected, hovered]);

    return &lt;Movable handle={handle} upright={false}>
        &lt;Plane args={[width, height]} position={[0, 0.125 - 0.0125, 0]}>
            &lt;meshBasicMaterial toneMapped={false} color={screen ? 'white' : 'darkgrey'}>
                {texture}
            &lt;/meshBasicMaterial>
        &lt;/Plane>
    &lt;/Movable>;
}

export function Main() {
    return &lt;Varv concept="ScreenStream">
        &lt;ScreenStream />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Screen Stream Menu" auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuSpacer, MenuButton } from '#Menu .default';



// Import in order to start the manager
import ScreenStreamManager from '#ScreenStreamManager .default';



addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'share-screen', &lt;MenuButton onClick={window.shareMyScreen}>Share Screenshare&lt;/MenuButton>, 100);
addItemToSubMenu('media-sharing', 'stop-screen', &lt;MenuButton onClick={window.stopSharingMyScreen}>Stop Screenshare&lt;/MenuButton>, 200);
addItemToSubMenu('media-sharing', 'spacer1', &lt;MenuSpacer />, 250);
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="VideoStream" name="VideoStream"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stream component for video streams",
    "dependencies": [
        "#StreamManager",
        "#VideoStreamManager",
        "#Menu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Video Stream Concepts" auto>{
    "concepts": {
        "VideoStream": {
            "schema": {
                "client": "string"
            }
        }
    }
}</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Video Stream" class="default component">import React from 'react';
const { useState, useEffect, useMemo } = React;
import { MeshStandardMaterial } from 'three';
import * as THREE from 'three';
import { Plane } from '@react-three/drei';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';

import { doIfClicked } from '#StreamManager .default';
import { QUERY_PREFIX, streamShare } from '#VideoStreamManager .default';



const frameGeometry = new RoundedBoxGeometry(1, 1, 0.005, 1);
const frameMaterial = new MeshStandardMaterial({ color: '#E0E0E0', metalness: 0.2, roughness: 0.5 });



export function VideoStream({ client }) {
    const [video, setVideo] = useState(document.querySelector(QUERY_PREFIX + client));
    const [aspectRatio, setAspectRatio] = useState(1);

    useEffect(() => {
        if (video) {
            // Playing immediately may fail, wait for interaction in that case
            doIfClicked(() => {
                setAspectRatio(video.videoWidth / video.videoHeight);
                video.addEventListener('resize', () => {
                    setAspectRatio(video.videoWidth / video.videoHeight);
                });
            });
        }

        // Make sure to catch stream updates
        let listener = function (newStreamId) {
            if (newStreamId == client) setVideo(document.querySelector(QUERY_PREFIX + client));
        };
        streamShare.addStreamAddedListener(listener);

        return () => {
            streamShare.removeStreamAddedListener(listener);
        }
    }, [video, client]);

    let texture = useMemo(() => video ? &lt;videoTexture attach='map' args={[video]} colorSpace={THREE.SRGBColorSpace} /> : null, [video]);

    return &lt;>
        &lt;mesh geometry={frameGeometry} material={frameMaterial}
            scale={[0.25 + 0.02, (0.25 / aspectRatio) + 0.02, 1]} position={[0, (0.125 / aspectRatio) + 0.2, 0.0055]} autoUpdateMatrix={false} />
        &lt;Plane args={[0.25, 0.25 / aspectRatio]} position={[0, (0.125 / aspectRatio) + 0.2, 0]} rotation={[0, Math.PI, 0]}>
            &lt;meshBasicMaterial toneMapped={false} color={video ? 'white' : 'darkgrey'}>
                {texture}
            &lt;/meshBasicMaterial>
        &lt;/Plane>
    &lt;/>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Video Stream Menu" auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuSpacer, MenuButton } from '#Menu .default';



// Import in order to start the manager
import VideoStreamManager from '#VideoStreamManager .default';



addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'share-video', &lt;MenuButton onClick={window.shareMyVideo}>Share Video&lt;/MenuButton>, 300);
addItemToSubMenu('media-sharing', 'stop-video', &lt;MenuButton onClick={window.stopSharingMyVideo}>Stop Video&lt;/MenuButton>, 400);
addItemToSubMenu('media-sharing', 'spacer2', &lt;MenuSpacer />, 450);
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="AudioStream" name="AudioStream"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Stream component for audio streams",
    "dependencies": [
        "#AudioStreamManager",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Audio Stream Concepts" auto>{
    "concepts": {
        "AudioStream": {
            "schema": {
                "client": "string",
                "muted": "boolean"
            }
        }
    }
}</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Audio Stream" class="default component dynamic-scene-component">import React from 'react';
const { useState, useEffect } = React;
import { Varv, useProperty } from '#VarvReact';

import { QUERY_PREFIX, streamShare } from '#AudioStreamManager .default';



function AudioStream() {
    const [client] = useProperty('client');
    const [muted] = useProperty('muted');

    const [audio, setAudio] = useState(document.querySelector(QUERY_PREFIX + client));

    useEffect(() => {
        // Make sure to catch stream updates
        let listener = function (newStreamId) {
            if (newStreamId == client) setAudio(document.querySelector(QUERY_PREFIX + client));
        };
        streamShare.addStreamAddedListener(listener);

        return () => {
            streamShare.removeStreamAddedListener(listener);
        };
    }, [audio, client]);

    useEffect(() => {
        if (audio && (client != webstrate.clientId)) {
            audio.muted = muted;
        }
    }, [muted, client]);
}

export function Main() {
    return &lt;Varv concept="AudioStream">
        &lt;AudioStream />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Audio Stream Menu" auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuSpacer, MenuButton } from '#Menu .default';
import { addItem, ControllerMenuButton } from '#ControllerMenu .default';



// Import in order to start the manager
import AudioStreamManager from '#AudioStreamManager .default';



addSubMenu('media-sharing', 500, false);
addItemToSubMenu('media-sharing', 'share-audio', &lt;MenuButton onClick={window.shareMyAudio}>Share Audio&lt;/MenuButton>, 500);
addItemToSubMenu('media-sharing', 'stop-audio', &lt;MenuButton onClick={window.stopSharingMyAudio}>Stop Audio&lt;/MenuButton>, 600);
addItemToSubMenu('media-sharing', 'spacer3', &lt;MenuSpacer />, 700);

addItem('share-audio', &lt;ControllerMenuButton position={[0.12, 0.06, 0]} name={'Start Audio'} callback={window.shareMyAudio} />);
addItem('stop-audio', &lt;ControllerMenuButton position={[0.12, 0, 0]} name={'Stop Audio'} callback={window.stopSharingMyAudio} />);
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER></CODE-FOLDER><CODE-FOLDER name="Movables" id><CODE-FOLDER name="Base"><WPM-PACKAGE name="Movable" id="Movable"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "Basic movable component and mechanism with helpers",
    "dependencies": [
        "#Spatialstrates",
        "#Icon",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Movable Concepts" auto>{
    "concepts": {
        "Movable": {
            "schema": {
                "position": { "array": {
                    "items": "number",
                    "default": [ 0, 1.5, 0 ]
                }},
                "rotation": { "array": {
                    "items": "number",
                    "default": [ 0, 0, 0 ]
                }},
                "selected": "boolean",
                "hovered": "boolean",
                "beingDragged": "boolean",
                "private": "boolean",
                "author": "User"
            },
            "mappings": {
                "selected": [ "memory", "cauldron" ],
                "hovered": [ "memory", "cauldron" ],
                "beingDragged": [ "memory", "cauldron" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript" name="Movable Actions" id auto>const DEBUG = false;
const MAX_DISTANCE = 0.5;



let positionProperty = null;
VarvEngine.registerEventCallback('engineReloaded', (evt) => {
    positionProperty = null;
});

async function getMovablePosition(movable) {
    if (!positionProperty) {
        let movableType = VarvEngine.getConceptFromType('Movable');
        if (DEBUG) console.log('Getting is');
        positionProperty = movableType.getProperty('position');
    }

    const [x, y, z] = await positionProperty.getValue(movable, true);

    return [x, y, z];
};

class ClosestMovableAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }
    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            const movable = options.movable || context.target;
            const otherMovables = options.otherMovables;

            const movablePosition = await getMovablePosition(movable);
            let closest = '';
            let closestDistance = false;

            for (let i = 0; i &lt; otherMovables.length; i++) {
                const currentPosition = await getMovablePosition(otherMovables[i]);
                const a = movablePosition[0] - currentPosition[0];
                const b = movablePosition[1] - currentPosition[1];
                const c = movablePosition[2] - currentPosition[2];
                const currentDistance = Math.sqrt(a * a + b * b + c * c);
                if (!closestDistance || (closestDistance > currentDistance)) {
                    if (currentDistance &lt; MAX_DISTANCE) {
                        closest = otherMovables[i];
                    }
                    closestDistance = currentDistance;
                }
            }

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, closest);

            return context;
        });
    }
}
Action.registerPrimitiveAction('closestMovable', ClosestMovableAction);
window.ClosestMovableAction = ClosestMovableAction;



class MovablesInRangeAction extends Action {
    constructor(name, options, concept) {
        super(name, options, concept);
    }
    async apply(contexts, actionArguments) {
        const self = this;

        return this.forEachContext(contexts, actionArguments, async (context, options) => {
            const movable = options.movable || context.target;
            const otherMovables = options.otherMovables;

            const maxDistance = options.maxDistance || MAX_DISTANCE;

            const movablePosition = await getMovablePosition(movable);
            let inRange = [];

            for (let i = 0; i &lt; otherMovables.length; i++) {
                const currentPosition = await getMovablePosition(otherMovables[i]);
                const a = movablePosition[0] - currentPosition[0];
                const b = movablePosition[1] - currentPosition[1];
                const c = movablePosition[2] - currentPosition[2];
                const currentDistance = Math.sqrt(a * a + b * b + c * c);
                if (currentDistance &lt; maxDistance) {
                    inRange.push(otherMovables[i]);
                }
            }

            let resultName = Action.defaultVariableName(self);
            if (options.as != null) {
                resultName = options.as;
            }

            Action.setVariable(context, resultName, inRange);

            return context;
        });
    }
}
Action.registerPrimitiveAction('movablesInRange', MovablesInRangeAction);
window.MovablesInRangeAction = MovablesInRangeAction;
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Movable" class="default component">import React from 'react';
const { useRef, useState, useEffect, useCallback } = React;
import * as THREE from 'three';
import { useXRInputSourceEvent } from '@react-three/xr';
import { useFrame } from '@react-three/fiber';
import { useProperty } from '#VarvReact';

import { useGlobalEvents } from '#Spatialstrates .global-events';
import { getDeviceFromInputEvent } from '#Spatialstrates .transform-helpers';
import { Icon } from '#Icon .default';
import { deselectMovables } from '#Movable .helpers';



const FAST_WRITEBACK_TIMEOUT = 33;
const SLOW_WRITEBACK_TIMEOUT = 500;

export const SELECTED_COLOR_PRIMARY = 'hsl(14, 100%, 50%)';
export const SELECTED_COLOR_SECONDARY = 'hsl(26, 100%, 60%)';
export const HOVERED_SELECTED_COLOR_PRIMARY = 'hsl(14, 100%, 65%)';
export const HOVERED_SELECTED_COLOR_SECONDARY = 'hsl(26, 100%, 75%)';



// Generic wrapper for Movable concept properties into ThreeJS transform properties
export function useTransform() {
    const [uuid] = useProperty('concept::uuid');

    const positionRef = useRef([0, 0, 0]);
    const rotationRef = useRef([0, 0, 0]);

    useEffect(() => {
        if (!uuid) return;
        const concept = VarvEngine.getConceptFromUUID(uuid);
        if (!concept) return;

        const updatePosition = async (changeUUID) => {
            if (changeUUID !== uuid) return;
            positionRef.current = await concept.getPropertyValue(uuid, 'position');
        };

        const updateRotation = async (changeUUID) => {
            if (changeUUID !== uuid) return;
            rotationRef.current = await concept.getPropertyValue(uuid, 'rotation');
        };

        updatePosition(uuid);
        updateRotation(uuid);

        concept.getProperty('position').addUpdatedCallback(updatePosition);
        concept.getProperty('rotation').addUpdatedCallback(updateRotation);

        return () => {
            if (!concept) return;
            try {
                concept.getProperty('position').removeUpdatedCallback(updatePosition);
                concept.getProperty('rotation').removeUpdatedCallback(updateRotation);
            } catch (e) {
                // Do nothing, this can crash when the VarvEngine restarts
            }
        };
    }, [uuid]);

    const setPosition = useCallback((pos) => {
        const concept = VarvEngine.getConceptFromUUID(uuid);
        if (!concept) return;
        concept.setPropertyValue(uuid, 'position', [pos.x, pos.y, pos.z], true);
    }, [uuid]);

    const setRotation = useCallback((rot) => {
        const concept = VarvEngine.getConceptFromUUID(uuid);
        if (!concept) return;
        concept.setPropertyValue(uuid, 'rotation', [rot.x, rot.y, rot.z], true);
    }, [uuid]);

    const transform = {
        get position() { return positionRef.current },
        set position(pos) { setPosition(pos) },
        get rotation() { return rotationRef.current },
        set rotation(rot) { setRotation(rot) },
    };

    return transform;
}

/**
 * Sugar wrapper for icons used inside movables that are
 * selectable and hoverable
 */
export function HandleIcon({ model, theme = '', themesOverride = '' }) {
    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');
    return &lt;Icon theme={theme + (selected ? ':selected' : '') + (hovered ? ':hovered' : '')} model={model} themesOverride={themesOverride} />
}

/**
 * Make a group of children moveable with a handle that allows
 * selecting them and dragging them around
 */
export function Movable({ children, handle, upright = true, onDragStart, onDragEnd, onDragging }) {
    const transform = useTransform();
    const [selected, setSelected] = useProperty('selected');
    const [hovered, setHovered] = useProperty('hovered');
    const [beingDragged, setBeingDragged] = useProperty('beingDragged');

    // Setup refs for dragging
    const grabbingController = useRef();
    const dragRef = useRef();

    // Setup dragging devices
    const [currentXRInputSource, setCurrentXRInputSource] = useState(null);
    const [uuid] = useProperty('concept::uuid');

    const { triggerEvent, subscribeEvent } = useGlobalEvents();

    // Handle input events for dragging and hovering
    const selectAndStartDrag = useCallback((e) => {
        if (e) e.stopPropagation();
        if (grabbingController.current) return;
        setSelected(true);
        setBeingDragged(true);
        setCurrentXRInputSource(e?.nativeEvent?.inputSource);

        deselectMovables();

        if (dragRef && dragRef.current) {
            triggerEvent('drag-start', { target: uuid });
            if (typeof onDragStart === 'function') onDragStart();
            grabbingController.current = getDeviceFromInputEvent(e);
            if (grabbingController.current) {
                previousTransform.copy(grabbingController.current.matrixWorld).invert();
            }
        }
    }, [setSelected, setBeingDragged]);

    const remoteInitiateDrag = useCallback((payload) => {
        if (payload.target === uuid) selectAndStartDrag(payload.e);
    }, [uuid]);

    useEffect(() => {
        const unsubscribe = subscribeEvent('initiate-drag', remoteInitiateDrag);
        return () => unsubscribe();
    }, [remoteInitiateDrag, subscribeEvent, uuid]);

    const stopDrag = useCallback((e) => {
        if (e) e.stopPropagation();
        setBeingDragged(false);
        setCurrentXRInputSource(null);

        if (grabbingController.current) {
            grabbingController.current = undefined;
            transform.position = dragRef.current.position;
            transform.rotation = dragRef.current.rotation;
            triggerEvent('drag-end', { target: uuid });
            if (typeof onDragEnd === 'function') onDragEnd();
        }
    }, [setBeingDragged, currentXRInputSource, setCurrentXRInputSource]);

    const startHover = useCallback((e) => {
        if (e) e.stopPropagation();
        setHovered(true);
    }, [setHovered]);

    const stopHover = useCallback(() => {
        setHovered(false);
    }, [setHovered]);

    // Always stop dragging when anything lets go
    useXRInputSourceEvent(currentXRInputSource, 'selectend', stopDrag, [stopDrag, currentXRInputSource]);
    useEffect(() => {
        document.body.addEventListener('pointerup', stopDrag);
        return () => {
            document.body.removeEventListener('pointerup', stopDrag);
        };
    }, [stopDrag]);

    // Update the transformation of the movable
    const previousTransform = React.useMemo(() => new THREE.Matrix4(), []);
    const fastWritebackTimeout = useRef();
    const slowWritebackTimeout = useRef();

    useFrame(() => {
        if (!beingDragged && dragRef.current) {
            dragRef.current.position.fromArray(transform.position);
            dragRef.current.rotation.fromArray(transform.rotation);
            dragRef.current.updateMatrix();
            return;
        }
        const controller = grabbingController.current;
        if (!controller) return;

        dragRef.current.applyMatrix4(previousTransform);
        dragRef.current.applyMatrix4(controller.matrixWorld);
        dragRef.current.rotation.reorder('YXZ');
        if (upright) {
            dragRef.current.rotation.x = 0;
            dragRef.current.rotation.z = 0;
        }
        dragRef.current.updateMatrix();
        previousTransform.copy(controller.matrixWorld).invert();

        // Update the Varv state
        if (!fastWritebackTimeout.current) {
            transform.position = dragRef.current.position;
            fastWritebackTimeout.current = setTimeout(() => {
                fastWritebackTimeout.current = null;
            }, FAST_WRITEBACK_TIMEOUT);
        }
        if (!slowWritebackTimeout.current) {
            transform.rotation = dragRef.current.rotation;
            if (typeof onDragging === 'function') onDragging();
            slowWritebackTimeout.current = setTimeout(() => {
                slowWritebackTimeout.current = null;
            }, SLOW_WRITEBACK_TIMEOUT);
        }
    });

    return &lt;group ref={dragRef}
        matrixAutoUpdate={false}
        matrixWorldAutoUpdate={true}>
        &lt;group
            onPointerDown={selectAndStartDrag}
            onPointerUp={stopDrag}
            onPointerOver={startHover}
            onPointerOut={stopHover}>
            {handle}
        &lt;/group>
        {children}
    &lt;/group>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Movable Helpers" class="module helpers">import { devicePositionWithOffset, deviceRotation } from '#Spatialstrates .transform-helpers';



const selectedFilter = FilterAction.constructFilter({
    property: 'selected',
    equals: true
});

const selectedAndNotDraggedFilter = FilterAction.constructFilter({
    and: [
        {
            property: 'selected',
            equals: true
        },
        {
            property: 'beingDragged',
            equals: false
        }
    ]
});



export const deselectMovables = async () => {
    const ids = await VarvEngine.getAllUUIDsFromType('Movable', true);
    for (const id of ids) {
        if (await selectedAndNotDraggedFilter.filter({ target: id })) {
            await VarvEngine.getConceptFromUUID(id).setPropertyValue(id, 'selected', false);
        }
    }
};

export const createMovable = async (conceptName, properties = {}) => {
    const [x, y, z] = devicePositionWithOffset(window.moduleDeviceManager.camera, 0.5);
    const [rx, ry, rz] = deviceRotation(window.moduleDeviceManager.camera);

    await deselectMovables();
    const concept = await VarvEngine.getConceptFromType(conceptName);
    return await concept.create(null, {
        selected: true,
        position: [x, y, z],
        rotation: [rx, ry, rz],
        ...properties
    });
};

export const deleteMovable = async (uuid) => {
    await VarvEngine.getConceptFromUUID(uuid).delete(uuid);
};

export const deleteSelectedMovable = async () => {
    const uuids = await VarvEngine.getAllUUIDsFromType('Movable', true);
    for (const uuid of uuids) {
        if (await selectedFilter.filter({ target: uuid })) {
            await deleteMovable(uuid);
        }
    }
};

export const cloneSelectedMovable = async () => {
    const ids = await VarvEngine.getAllUUIDsFromType('Movable', true);
    for (const id of ids) {
        if (await selectedFilter.filter({ target: id })) {
            // Clone and move it up by 20cm
            console.warn('Cloning not implemented yet');
            // TODO: Re-implement this feature
        }
    }
};
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Movable Menu" auto>import React from 'react';
import {
    addSubMenu,
    addItemToSubMenu,
    MenuTitle,
    MenuSpacer,
    MenuButton
} from '#Menu .default';
import {
    addItem,
    ControllerMenuButton
} from '#ControllerMenu .default';
import { Varv, useProperty } from '#VarvReact';
import { deselectMovables, deleteSelectedMovable, cloneSelectedMovable } from '#Movable .helpers';



// function MultiSelectButton() {
//     const [multiSelect, setMultiSelect] = useProperty('multiSelect');
//     return &lt;MenuButton onClick={() => setMultiSelect(!multiSelect)} toggled={multiSelect ? 'true' : null}>Toggle Multi-Select&lt;/MenuButton>;
// }

addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'clone', &lt;MenuButton onClick={cloneSelectedMovable}>Clone&lt;/MenuButton>, 500);
addItemToSubMenu('movables', 'delete', &lt;MenuButton className="red" onClick={deleteSelectedMovable}>Delete&lt;/MenuButton>, 500);
addItemToSubMenu('movables', 'spacer1', &lt;MenuSpacer />, 550);
// addItemToSubMenu('movables', 'multi-select', &lt;Varv concept="MovableManager">
//     &lt;MultiSelectButton />
// &lt;/Varv>, 600);
addItemToSubMenu('movables', 'deselect', &lt;MenuButton onClick={deselectMovables}>Deselect Objects&lt;/MenuButton>, 700);

// function MultiSelectControllerButton() {
//     const [multiSelect, setMultiSelect] = useProperty('multiSelect');
//     return &lt;ControllerMenuButton position={[-0.12, 0.06, 0]} name={'Toggle Multi-Select'} theme={multiSelect ? 'button:toggled' : null} callback={() => setMultiSelect(!multiSelect)} />;
// }

addItem('clone', &lt;ControllerMenuButton position={[-0.04, 0.06, 0]} name={'Clone'} callback={cloneSelectedMovable} />);
addItem('delete', &lt;ControllerMenuButton position={[-0.04, 0, 0]} name={'Delete'} theme="deleteButton" callback={deleteSelectedMovable} />);
// addItem('multi-select', &lt;Varv concept="MovableManager">
//     &lt;MultiSelectControllerButton />
// &lt;/Varv>);
addItem('deselect', &lt;ControllerMenuButton position={[-0.12, 0, 0]} name={'Deselect All'} callback={deselectMovables} />);
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Components"><WPM-PACKAGE id="StickyNote" name="StickyNote" class><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple sticky note component",
    "dependencies": [
        "#Movable",
        "#Icon",
        "#AIHelpers",
        "#Menu",
        "#ControllerMenu",
        "#Text"
    ],
    "assets": [
        "microphone.glb"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Sticky Note Concepts" auto>{
    "concepts": {
        "StickyNote": {
            "schema": {
                "text": "string"
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Sticky Note Component" class="default component dynamic-scene-component">import React from 'react';
const { useState, useMemo, useRef } = React;
import { MeshStandardMaterial } from 'three';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useFrame } from '@react-three/fiber';
import { Varv, useProperty } from '#VarvReact';
import { useGLTF } from '@react-three/drei';

import { Movable, SELECTED_COLOR_PRIMARY, HOVERED_SELECTED_COLOR_PRIMARY } from '#Movable .default';
import { Icon } from '#Icon .default';
import { transcribeAudio } from '#AIHelpers .default';
import { Text } from '#Text .default';



const frameGeometry = new RoundedBoxGeometry(0.15, 0.15, 0.005, 1);
const frameMaterial = new MeshStandardMaterial({ color: '#FDD835', metalness: 0.2, roughness: 0.5 });
const frameMaterialHovered = new MeshStandardMaterial({ color: '#FFF176', metalness: 0.2, roughness: 0.5 });
const frameMaterialSelected = new MeshStandardMaterial({ color: SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });
const frameMaterialHoveredSelected = new MeshStandardMaterial({ color: HOVERED_SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });
useGLTF.preload('microphone.glb');



function StickyNote() {
    const iconRef = useRef();
    const microphoneIcon = useGLTF('microphone.glb');
    const [listening, setListening] = useState(false);
    const [text, setText] = useProperty('text');
    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');

    async function updateText() {
        if (listening) return;

        setListening(true);
        const newText = await transcribeAudio(5000, false, () => { setListening(false); });
        if (newText) setText(newText);
    }

    const handle = useMemo(() => &lt;mesh
        geometry={frameGeometry}
        material={selected ? (hovered ? frameMaterialHoveredSelected : frameMaterialSelected) : (hovered ? frameMaterialHovered : frameMaterial)}
        position={[0, 0.025, 0]}
        autoUpdateMatrix={false}
    />, [hovered, selected]);

    useFrame((state) => {
        if (!iconRef.current) return;
        const minScale = 0.4;
        const maxScale = 0.6;
        const targetScale = listening ? minScale + (maxScale - minScale) * (Math.sin(state.clock.elapsedTime * 5) * 0.5 + 0.5) : 0.5;
        iconRef.current.scale.setScalar(targetScale);
    });

    return &lt;Movable handle={handle} upright={false}>
        &lt;Text
            position={[0, 0.025, 0.003]} autoUpdateMatrix={false}
            maxWidth={0.13}
            textAlign='left'
            anchorX='center'
            anchorY='middle'
            color='black'
            fontSize={0.01}>
            {text}
        &lt;/Text>
        {selected ? &lt;group ref={iconRef} rotation={[0, -Math.PI, 0]} position={[0.1, 0.025, 0]}>
            &lt;Icon model={microphoneIcon} onClick={updateText} />
        &lt;/group> : null}
    &lt;/Movable>;
}



export function Main() {
    return &lt;Varv concept="StickyNote">
        &lt;StickyNote />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Sticky Note Menu" auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { addItem, ControllerMenuButton } from '#ControllerMenu .default';
import { createMovable } from '#Movable .helpers';



addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'add-sticky-note', &lt;MenuButton onClick={() => createMovable('StickyNote')}>New Sticky Note&lt;/MenuButton>, 200);
addItemToSubMenu('movables', 'spacer-items', &lt;MenuSpacer />, 400);

addItem('add-sticky-note', &lt;ControllerMenuButton position={[0.04, 0, 0]} name={'New Sticky Note'} callback={(e) => createMovable('StickyNote')} />);
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Image" name="Image"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A simple image component",
    "dependencies": [
        "#Movable",
        "#Menu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Image Concepts" auto>{
    "concepts": {
        "Image": {
            "schema": {
                "url": "string"
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" id name="Image Component" class="default component dynamic-scene-component">import React from 'react';
const { useRef, useState, useEffect, useMemo } = React;
import { MeshStandardMaterial } from 'three';
import { Image } from '@react-three/drei';
import { ErrorBoundary } from 'react-error-boundary';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { Varv, useProperty } from '#VarvReact';

import { Movable, SELECTED_COLOR_PRIMARY, HOVERED_SELECTED_COLOR_PRIMARY } from '#Movable .default';



const MAX_SIZE = 0.4;

// Reuseable geometry for the image frame
const frameGeometry = new RoundedBoxGeometry(1, 1, 0.005, 1);
const frameMaterial = new MeshStandardMaterial({ color: '#E0E0E0', metalness: 0.2, roughness: 0.5 });
const frameMaterialHovered = new MeshStandardMaterial({ color: '#FFFFFF', metalness: 0.2, roughness: 0.5 });
const frameMaterialSelected = new MeshStandardMaterial({ color: SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });
const frameMaterialHoveredSelected = new MeshStandardMaterial({ color: HOVERED_SELECTED_COLOR_PRIMARY, metalness: 0.2, roughness: 0.5 });

function CustomImage() {
    const boundaryRef = useRef();
    const imageRef = useRef();
    const [width, setWidth] = useState(1);
    const [height, setHeight] = useState(1);
    const [url] = useProperty('url');

    const [selected] = useProperty('selected');
    const [hovered] = useProperty('hovered');

    // Update the aspect ratio
    useEffect(() => {
        if (boundaryRef.current) boundaryRef.current.resetErrorBoundary();
        if (imageRef.current) {
            const aspectRatio = imageRef.current.material.__r3f.memoizedProps.imageBounds[0] / imageRef.current.material.__r3f.memoizedProps.imageBounds[1] || 1;
            if (aspectRatio > 1) {
                setWidth(MAX_SIZE);
                setHeight(MAX_SIZE / aspectRatio);
            } else {
                setWidth(MAX_SIZE * aspectRatio);
                setHeight(MAX_SIZE);
            }
        }
    }, [url, imageRef]);

    const handle = useMemo(() => &lt;mesh
        geometry={frameGeometry}
        material={selected ? (hovered ? frameMaterialHoveredSelected : frameMaterialSelected) : (hovered ? frameMaterialHovered : frameMaterial)}
        scale={[width + 0.02, height + 0.02, 1]}
        position={[0, 0.125 - 0.025, -0.0029]}
        autoUpdateMatrix={false}>
    &lt;/mesh>, [width, height, selected, hovered]);

    return &lt;Movable handle={handle} upright={false}>
        &lt;ErrorBoundary ref={boundaryRef} fallback={null}>
            {url ? &lt;Image ref={imageRef} url={url} position={[0, 0.125 - 0.025, 0]} scale={[width, height, 1]} autoUpdateMatrix={false}>
                &lt;planeGeometry args={[1, 1]} />
            &lt;/Image> : null}
        &lt;/ErrorBoundary>
    &lt;/Movable>;
}

export function Main() {
    return &lt;Varv concept="Image">
        &lt;CustomImage />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Image Uploader" id class auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuTitle } from '#Menu .default';
import { devicePositionWithOffset, deviceRotation } from '#Spatialstrates .transform-helpers';



if (!window.moduleImageUploader) {
    window.moduleImageUploader = {
        active: true
    };

    // Setup menu item
    addSubMenu('file-upload', 500, false);
    addItemToSubMenu('file-upload', 'title', &lt;MenuTitle title="Upload Files" />, 0);
    addItemToSubMenu('file-upload', 'upload-image', &lt;div className="upload-drop-zone" id="image-upload-drop-zone">Upload Image&lt;/div>, 1000);

    // Setup drop zone for image uploads
    const handleUploadImage = (file) => {
        const formData = new FormData();
        formData.append('file', file, file.name);

        const request = new XMLHttpRequest();
        request.open('POST', window.location.pathname);
        request.send(formData);

        return new Promise((resolve, reject) => {
            request.addEventListener('load', async (e) => {
                const asset = JSON.parse(request.responseText);
                const [x, y, z] = devicePositionWithOffset(window.moduleDeviceManager.camera, 0.5);
                const [rx, ry, rz] = deviceRotation(window.moduleDeviceManager.camera);

                const imageConcept = await VarvEngine.getConceptFromType('Image');
                imageConcept.create(null, {
                    url: asset.fileName,
                    position: [x, y, z],
                    rotation: [rx, ry, rz]
                });
                resolve(asset);
            });
            request.addEventListener('error', (e) => {
                reject(new Error('Failed to upload image'));
            });
        });
    };

    const handleUploadFile = (file) => {
        if (file.type === 'image/jpeg' || file.type === 'image/png') {
            handleUploadImage(file);
        } else {
            alert('File type not supported.');
        }
    };

    const activateDropZone = (element, type) => {
        element.addEventListener('dragover', (e) => {
            e.preventDefault();
            element.classList.add('upload-drop-zone--over');
        });

        element.addEventListener('dragleave', () => {
            element.classList.remove('upload-drop-zone--over');
        });

        element.addEventListener('drop', (e) => {
            e.preventDefault();
            element.classList.remove('upload-drop-zone--over');
            const files = e.dataTransfer.files;
            for (let i = 0; i &lt; files.length; i++) {
                const file = files[i];
                handleUploadFile(file, type);
            }
        });

        element.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = 'multiple';
            input.accept = type === 'image' ? 'image/jpeg, image/png' : '';
            input.onchange = (e) => {
                for (let i = 0; i &lt; e.target.files.length; i++) {
                    handleUploadFile(e.target.files[i], type);
                }
            };
            input.click();
        });
    };

    cQuery(document.body).liveQuery('.upload-drop-zone', {
        'added': (element) => {
            if (element.id === 'image-upload-drop-zone') {
                activateDropZone(element, 'image');
            }
        }
    });
}
</CODE-FRAGMENT></WPM-PACKAGE><WPM-PACKAGE id="Trashcan" name="Trashcan"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A trashcan component that can be used to delete movables",
    "dependencies": [
        "#Movable",
        "#Icon",
        "#Menu",
        "#ControllerMenu"
    ],
    "assets": [
        "trash.glb"
    ],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/varv" name="Trashcan Concepts" auto>{
    "concepts": {
        "Trashcan": {
            "schema": {
                "placeholder": "string"
            },
            "extensions": {
                "inject": [ "Movable" ]
            }
        }
    }
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Trashcan Component" class="default component dynamic-scene-component">import React from 'react';
const { useEffect, useCallback } = React;
import * as THREE from 'three';
import { Varv, useProperty } from '#VarvReact';
import { useGLTF } from '@react-three/drei';

import { useGlobalEvents } from '#Spatialstrates .global-events';
import { Movable, HandleIcon } from '#Movable .default';
import {
    SELECTED_COLOR_PRIMARY,
    SELECTED_COLOR_SECONDARY,
    HOVERED_SELECTED_COLOR_PRIMARY,
    HOVERED_SELECTED_COLOR_SECONDARY
} from '#Icon .default';
import { deleteMovable } from '#Movable .helpers';



const MAX_DISTANCE = 0.2;

const themes = {
    'trash': { primary: 'hsl(0, 0%, 20%)', secondary: 'hsl(0, 0%, 60%)' },
    'trash:hovered': { primary: 'hsl(0, 0%, 50%)', secondary: 'hsl(0, 0%, 70%)' },
    'trash:selected': { primary: SELECTED_COLOR_PRIMARY, secondary: SELECTED_COLOR_SECONDARY },
    'trash:selected:hovered': { primary: HOVERED_SELECTED_COLOR_PRIMARY, secondary: HOVERED_SELECTED_COLOR_SECONDARY },
};
useGLTF.preload('trash.glb');

function Trashcan() {
    const trashcanIcon = useGLTF('trash.glb');
    const handle = &lt;HandleIcon theme="trash" model={trashcanIcon} themesOverride={themes} />
    const [position] = useProperty('position');
    const [uuid] = useProperty('concept::uuid');

    const { subscribeEvent } = useGlobalEvents();

    const onDragEnd = useCallback(async (data) => {
        if (data.target === uuid) return;

        const movablePositionArray = await VarvEngine.getConceptFromUUID(data.target).getPropertyValue(data.target, 'position');

        const trashcanPosition = new THREE.Vector3(...position);
        const movablePosition = new THREE.Vector3(...movablePositionArray);

        if (trashcanPosition.distanceTo(movablePosition) &lt; MAX_DISTANCE) {
            await deleteMovable(data.target);
        }
    }, [position]);

    useEffect(() => {
        const unsubscribe = subscribeEvent('drag-end', onDragEnd);
        return () => unsubscribe();
    }, [subscribeEvent, position]);

    return &lt;Movable handle={handle} />;
}



export function Main() {
    return &lt;Varv concept="Trashcan">
        &lt;Trashcan />
    &lt;/Varv>;
}
</CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Trashcan Menu" auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { addItem, ControllerMenuButton } from '#ControllerMenu .default';
import { createMovable } from '#Movable .helpers';



addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'add-trashcan', &lt;MenuButton onClick={() => createMovable('Trashcan')}>New Trashcan&lt;/MenuButton>, 100);
addItemToSubMenu('movables', 'spacer-items', &lt;MenuSpacer />, 400);

addItem('add-trashcan', &lt;ControllerMenuButton position={[0.04, 0.06, 0]} name={'New Trashcan'} callback={(e) => createMovable('Trashcan')} />);
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER><CODE-FOLDER name="Add-ons"><WPM-PACKAGE id="Screenshots" name="Screenshots"><CODE-FRAGMENT data-type="wpm/descriptor"><WPM-DESCRIPTOR>{
    "description": "A screenshot function that creates images in Spatialstrates",
    "dependencies": [
        "#Image",
        "#Menu"
    ],
    "assets": [],
    "version": "0.1.0"
}
</WPM-DESCRIPTOR></CODE-FRAGMENT><CODE-FRAGMENT data-type="text/javascript+babel" name="Screenshots" id class="default module" auto>import React from 'react';
import { addSubMenu, addItemToSubMenu, MenuTitle, MenuSpacer, MenuButton } from '#Menu .default';
import { devicePositionWithOffset, deviceRotation } from '#Spatialstrates .transform-helpers';



const createFileName = () => {
    const date = new Date();
    return `screenshot_${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}_${date.getHours()}-${date.getMinutes()}-${date.getSeconds()}`;
};

const dataURLToBlob = (dataURL) => {
    const byteString = atob(dataURL.split(',')[1]);
    const mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i &lt; byteString.length; i += 1) {
        ia[i] = byteString.charCodeAt(i);
    }
    return new Blob([ab], { type: mimeString });
};

const uploadAsset = async (dataURL, fileName) => {
    const formData = new FormData();
    const blob = dataURLToBlob(dataURL);
    formData.append('file', blob, fileName);

    const request = new XMLHttpRequest();
    request.open('POST', window.location.pathname);
    request.send(formData);

    return new Promise((resolve, reject) => {
        request.addEventListener('load', (e) => {
            const asset = JSON.parse(request.responseText);
            resolve(asset);
        });
        request.addEventListener('error', (e) => {
            reject(new Error('Failed to upload screenshot'));
        });
    });
};

const captureScreenshot = async () => {
    const canvas = document.querySelector('body transient canvas[data-engine]');
    if (!canvas) {
        console.warn('Screenshot failed: No canvas found');
        return;
    }

    const dataURL = canvas.toDataURL('image/png');
    const asset = await uploadAsset(dataURL, createFileName() + '.png');

    const [x, y, z] = devicePositionWithOffset(window.moduleDeviceManager.camera, 0.5);
    const [rx, ry, rz] = deviceRotation(window.moduleDeviceManager.camera);

    const imageConcept = await VarvEngine.getConceptFromType('Image');
    imageConcept.create(null, {
        url: asset.fileName,
        position: [x, y, z],
        rotation: [rx, ry, rz]
    });
};


addSubMenu('movables', 100, false);
addItemToSubMenu('movables', 'title', &lt;MenuTitle title="Menu" />, 0);
addItemToSubMenu('movables', 'spacer2', &lt;MenuSpacer />, 750);
addItemToSubMenu('movables', 'screenshot', &lt;MenuButton onClick={captureScreenshot}>Capture Screenshot&lt;/MenuButton>, 800);
</CODE-FRAGMENT></WPM-PACKAGE></CODE-FOLDER></CODE-FOLDER></body></html>
